//******************************************************************************/
// SkypeKit .NET wrapper version 1.4 
// Expected to work with SDK version 4.2 Windows runtimes. 

/*! \file skt_skypekit_2008.cs
    \brief 
This is the main module of the .NET wrapper, that contains all the user-servicable
SkypeKit API classes, plus a special <b><tt>SktEvents</tt></b> class for events. 
<b>NB!</b> This is a script-generated file. Manual modifications will be lost. */

/*******************************************************************************/
 
using System;
using System.Windows.Forms;
using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

namespace SkypeKit
{

/*! \class SktParticipant
  \brief
  Conversation participant class. Instances of this class represent contacts when in the context of conversations.
  Amongst others, this class has a Ring method for requesting live status with the target contact. This
  class also holds typing indicator property and access rights for the contact in context of public conversations.
 
 @n <h2>Events</h2>
<tt>void <b>SktEvents.OnParticipantIncomingDTMF</b> (SktParticipant sender, SktEvents.OnParticipantIncomingDTMFArgs e)</tt>@n
 
  This event gets fired on receiving a DTMF signal sent by Participant. Note that this event will only
  fire if the Participant is also using a Skype client. Skype audio library does not monitor incoming voice
  streams for dial tones. DTMF events are propagated to remote participants via data channel. Incoming
  DTMF tones transmitted from, for example, mobile phones, will not cause this event to fire. In case of
  incoming DTMF signals from Skype clients, DTMF tones are also inserted into the audio stream. You don't
  have to inject those into local audio playback yourself.
  @param dtmf  Returns SktParticipant.DTMF value. (SktParticipant.DTMF)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnParticipantLiveSessionVideosChanged</b> (SktParticipant sender, SktEvents.OnParticipantLiveSessionVideosChangedArgs e)</tt>@n
 
 
<hr />
 @n 
 */
public class SktParticipant : SktObject
{
    public override String ClassName { get { return "Participant"; } }
    
    public override uint ClassId { get { return 19; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktParticipant (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(21);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktParticipant objects.
     */
    public class List : SktObjectList
    {
        new public SktParticipant this[int index]
        {
            get { return (SktParticipant)base[index]; }
        }

        public void Add(SktParticipant item)
        {
            base.Add((SktParticipant)item);
        }
    }
    

    /* SktParticipant property cache fields */
    private volatile SktConversation             cache_convo_id;
    private volatile String                      cache_identity;
    private volatile SktParticipant.RANK         cache_rank;
    private volatile SktParticipant.RANK         cache_requested_rank;
    private volatile SktParticipant.TEXT_STATUS  cache_text_status;
    private volatile SktParticipant.VOICE_STATUS cache_voice_status;
    private volatile SktParticipant.VIDEO_STATUS cache_video_status;
    private volatile String                      cache_live_identity;
    private volatile String                      cache_live_price_for_me;
    private volatile String                      cache_live_fwd_identities;
    private volatile uint                        cache_live_start_timestamp;
    private volatile uint                        cache_sound_level;
    private volatile String                      cache_debuginfo;
    private volatile String                      cache_last_voice_error;
    private volatile String                      cache_quality_problems;
    private volatile SktSkype.IDENTITYTYPE       cache_live_type;
    private volatile String                      cache_live_country;
    private volatile String                      cache_transferred_by;
    private volatile String                      cache_transferred_to;
    private volatile String                      cache_adder;
    private volatile SktSkype.LEAVE_REASON       cache_last_leavereason;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 930: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 930: /* Participant.P_CONVO_ID */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_id = (SktConversation)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_CONVO_ID = " + cache_convo_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_CONVO_ID - update without value");
                skypeRef.events.FireOnParticipantConvoId(this, cache_convo_id);
                break;
                
            case 931: /* Participant.P_IDENTITY */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_identity = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_IDENTITY = " + cache_identity.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_IDENTITY - update without value");
                skypeRef.events.FireOnParticipantIdentity(this, cache_identity);
                break;
                
            case 932: /* Participant.P_RANK */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_rank = (SktParticipant.RANK)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_RANK = " + cache_rank.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_RANK - update without value");
                skypeRef.events.FireOnParticipantRank(this, cache_rank);
                break;
                
            case 933: /* Participant.P_REQUESTED_RANK */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_requested_rank = (SktParticipant.RANK)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_REQUESTED_RANK = " + cache_requested_rank.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_REQUESTED_RANK - update without value");
                skypeRef.events.FireOnParticipantRequestedRank(this, cache_requested_rank);
                break;
                
            case 934: /* Participant.P_TEXT_STATUS */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_text_status = (SktParticipant.TEXT_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_TEXT_STATUS = " + cache_text_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_TEXT_STATUS - update without value");
                skypeRef.events.FireOnParticipantTextStatus(this, cache_text_status);
                break;
                
            case 935: /* Participant.P_VOICE_STATUS */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_voice_status = (SktParticipant.VOICE_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_VOICE_STATUS = " + cache_voice_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_VOICE_STATUS - update without value");
                skypeRef.events.FireOnParticipantVoiceStatus(this, cache_voice_status);
                break;
                
            case 936: /* Participant.P_VIDEO_STATUS */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_video_status = (SktParticipant.VIDEO_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_VIDEO_STATUS = " + cache_video_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_VIDEO_STATUS - update without value");
                skypeRef.events.FireOnParticipantVideoStatus(this, cache_video_status);
                break;
                
            case 943: /* Participant.P_LIVE_IDENTITY */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_identity = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_IDENTITY = " + cache_live_identity.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_IDENTITY - update without value");
                skypeRef.events.FireOnParticipantLiveIdentity(this, cache_live_identity);
                break;
                
            case 938: /* Participant.P_LIVE_PRICE_FOR_ME */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_price_for_me = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_PRICE_FOR_ME = " + cache_live_price_for_me.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_PRICE_FOR_ME - update without value");
                skypeRef.events.FireOnParticipantLivePriceForMe(this, cache_live_price_for_me);
                break;
                
            case 948: /* Participant.P_LIVE_FWD_IDENTITIES */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_fwd_identities = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_FWD_IDENTITIES = " + cache_live_fwd_identities.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_FWD_IDENTITIES - update without value");
                skypeRef.events.FireOnParticipantLiveFwdIdentities(this, cache_live_fwd_identities);
                break;
                
            case 939: /* Participant.P_LIVE_START_TIMESTAMP */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_start_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_START_TIMESTAMP = " + cache_live_start_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_START_TIMESTAMP - update without value");
                skypeRef.events.FireOnParticipantLiveStartTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_live_start_timestamp));
                break;
                
            case 941: /* Participant.P_SOUND_LEVEL */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_sound_level = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_SOUND_LEVEL = " + cache_sound_level.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_SOUND_LEVEL - update without value");
                skypeRef.events.FireOnParticipantSoundLevel(this, cache_sound_level);
                break;
                
            case 942: /* Participant.P_DEBUGINFO */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_debuginfo = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_DEBUGINFO = " + cache_debuginfo.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_DEBUGINFO - update without value");
                skypeRef.events.FireOnParticipantDebuginfo(this, cache_debuginfo);
                break;
                
            case 947: /* Participant.P_LAST_VOICE_ERROR */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_last_voice_error = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LAST_VOICE_ERROR = " + cache_last_voice_error.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LAST_VOICE_ERROR - update without value");
                skypeRef.events.FireOnParticipantLastVoiceError(this, cache_last_voice_error);
                break;
                
            case 949: /* Participant.P_QUALITY_PROBLEMS */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_quality_problems = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_QUALITY_PROBLEMS = " + cache_quality_problems.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_QUALITY_PROBLEMS - update without value");
                skypeRef.events.FireOnParticipantQualityProblems(this, cache_quality_problems);
                break;
                
            case 950: /* Participant.P_LIVE_TYPE */
                cache[15] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_type = (SktSkype.IDENTITYTYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_TYPE = " + cache_live_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_TYPE - update without value");
                skypeRef.events.FireOnParticipantLiveType(this, cache_live_type);
                break;
                
            case 951: /* Participant.P_LIVE_COUNTRY */
                cache[16] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_country = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_COUNTRY = " + cache_live_country.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LIVE_COUNTRY - update without value");
                skypeRef.events.FireOnParticipantLiveCountry(this, cache_live_country);
                break;
                
            case 952: /* Participant.P_TRANSFERRED_BY */
                cache[17] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_transferred_by = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_TRANSFERRED_BY = " + cache_transferred_by.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_TRANSFERRED_BY - update without value");
                skypeRef.events.FireOnParticipantTransferredBy(this, cache_transferred_by);
                break;
                
            case 953: /* Participant.P_TRANSFERRED_TO */
                cache[18] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_transferred_to = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_TRANSFERRED_TO = " + cache_transferred_to.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_TRANSFERRED_TO - update without value");
                skypeRef.events.FireOnParticipantTransferredTo(this, cache_transferred_to);
                break;
                
            case 954: /* Participant.P_ADDER */
                cache[19] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_adder = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_ADDER = " + cache_adder.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_ADDER - update without value");
                skypeRef.events.FireOnParticipantAdder(this, cache_adder);
                break;
                
            case 955: /* Participant.P_LAST_LEAVEREASON */
                cache[20] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_last_leavereason = (SktSkype.LEAVE_REASON)value;
                    if (skypeRef.logging) skypeRef.Log("Participant.P_LAST_LEAVEREASON = " + cache_last_leavereason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Participant.P_LAST_LEAVEREASON - update without value");
                skypeRef.events.FireOnParticipantLastLeavereason(this, cache_last_leavereason);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Participant class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktParticipant property accessors **/
    
    /**  [ALL] ID of corresponding conversation. Here and below, [ALL] tag indicates that the property has meaning
      and is set in context of all participants in the conversation. [OTHERS] tag has meaning only for participants
      who are not the local user.
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantConvoId(SktParticipant sender, SktEvents.OnParticipantConvoIdArgs e)</b></tt>
     */
    public SktConversation P_CONVO_ID
    {
        get { if (!cache[0]) FetchConvoIdFromRuntime(); return cache_convo_id; }
    }
    
    internal void FetchConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 930, this.OID);
        if (skypeRef.transport.PropResponseWasOk(930))
        {
            cache_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] skypename OR pstn_number OR namespace:identity
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantIdentity</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantIdentity(SktParticipant sender, SktEvents.OnParticipantIdentityArgs e)</b></tt>
     */
    public String P_IDENTITY
    {
        get { if (!cache[1]) FetchIdentityFromRuntime(); return cache_identity; }
    }
    
    internal void FetchIdentityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IDENTITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 931, this.OID);
        if (skypeRef.transport.PropResponseWasOk(931))
        {
            cache_identity = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] SktParticipant.RANK
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantRank</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantRank(SktParticipant sender, SktEvents.OnParticipantRankArgs e)</b></tt>
     */
    public SktParticipant.RANK P_RANK
    {
        get { if (!cache[2]) FetchRankFromRuntime(); return cache_rank; }
    }
    
    internal void FetchRankFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_RANK from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 932, this.OID);
        if (skypeRef.transport.PropResponseWasOk(932))
        {
            cache_rank = (SktParticipant.RANK)skypeRef.decoder.DecodeUint();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Not set (should be: requested SktParticipant.RANK, higher than the current one)
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantRequestedRank</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantRequestedRank(SktParticipant sender, SktEvents.OnParticipantRequestedRankArgs e)</b></tt>
     */
    public SktParticipant.RANK P_REQUESTED_RANK
    {
        get { if (!cache[3]) FetchRequestedRankFromRuntime(); return cache_requested_rank; }
    }
    
    internal void FetchRequestedRankFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_REQUESTED_RANK from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 933, this.OID);
        if (skypeRef.transport.PropResponseWasOk(933))
        {
            cache_requested_rank = (SktParticipant.RANK)skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] the typing indicator
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantTextStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantTextStatus(SktParticipant sender, SktEvents.OnParticipantTextStatusArgs e)</b></tt>
     */
    public SktParticipant.TEXT_STATUS P_TEXT_STATUS
    {
        get { if (!cache[4]) FetchTextStatusFromRuntime(); return cache_text_status; }
    }
    
    internal void FetchTextStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TEXT_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 934, this.OID);
        if (skypeRef.transport.PropResponseWasOk(934))
        {
            cache_text_status = (SktParticipant.TEXT_STATUS)skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] voice status
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantVoiceStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantVoiceStatus(SktParticipant sender, SktEvents.OnParticipantVoiceStatusArgs e)</b></tt>
     */
    public SktParticipant.VOICE_STATUS P_VOICE_STATUS
    {
        get { if (!cache[5]) FetchVoiceStatusFromRuntime(); return cache_voice_status; }
    }
    
    internal void FetchVoiceStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_VOICE_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 935, this.OID);
        if (skypeRef.transport.PropResponseWasOk(935))
        {
            cache_voice_status = (SktParticipant.VOICE_STATUS)skypeRef.decoder.DecodeUint();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] video status
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantVideoStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantVideoStatus(SktParticipant sender, SktEvents.OnParticipantVideoStatusArgs e)</b></tt>
     */
    public SktParticipant.VIDEO_STATUS P_VIDEO_STATUS
    {
        get { if (!cache[6]) FetchVideoStatusFromRuntime(); return cache_video_status; }
    }
    
    internal void FetchVideoStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_VIDEO_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 936, this.OID);
        if (skypeRef.transport.PropResponseWasOk(936))
        {
            cache_video_status = (SktParticipant.VIDEO_STATUS)skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] identity that was used to establish current live session with that participant (can be different
      from participant identity)
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLiveIdentity</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLiveIdentity(SktParticipant sender, SktEvents.OnParticipantLiveIdentityArgs e)</b></tt>
     */
    public String P_LIVE_IDENTITY
    {
        get { if (!cache[7]) FetchLiveIdentityFromRuntime(); return cache_live_identity; }
    }
    
    internal void FetchLiveIdentityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_IDENTITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 943, this.OID);
        if (skypeRef.transport.PropResponseWasOk(943))
        {
            cache_live_identity = skypeRef.decoder.DecodeString();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] 'price_per_minute_float currency' - eg '0.01 EUR'. Note that this property obtains value only
      after the participant goes into live state. It cannot be used to display call rates before the call starts.
     
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLivePriceForMe</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLivePriceForMe(SktParticipant sender, SktEvents.OnParticipantLivePriceForMeArgs e)</b></tt>
     */
    public String P_LIVE_PRICE_FOR_ME
    {
        get { if (!cache[8]) FetchLivePriceForMeFromRuntime(); return cache_live_price_for_me; }
    }
    
    internal void FetchLivePriceForMeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_PRICE_FOR_ME from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 938, this.OID);
        if (skypeRef.transport.PropResponseWasOk(938))
        {
            cache_live_price_for_me = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] list of identities where the live session is being forwarded (if they are disclosed), space
      separated
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLiveFwdIdentities</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLiveFwdIdentities(SktParticipant sender, SktEvents.OnParticipantLiveFwdIdentitiesArgs e)</b></tt>
     */
    public String P_LIVE_FWD_IDENTITIES
    {
        get { if (!cache[9]) FetchLiveFwdIdentitiesFromRuntime(); return cache_live_fwd_identities; }
    }
    
    internal void FetchLiveFwdIdentitiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_FWD_IDENTITIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 948, this.OID);
        if (skypeRef.transport.PropResponseWasOk(948))
        {
            cache_live_fwd_identities = skypeRef.decoder.DecodeString();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] time of joining the live session
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLiveStartTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLiveStartTimestamp(SktParticipant sender, SktEvents.OnParticipantLiveStartTimestampArgs e)</b></tt>
     */
    public DateTime P_LIVE_START_TIMESTAMP
    {
        get { if (!cache[10]) FetchLiveStartTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_live_start_timestamp); }
    }
    
    internal void FetchLiveStartTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_START_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 939, this.OID);
        if (skypeRef.transport.PropResponseWasOk(939))
        {
            cache_live_start_timestamp = skypeRef.decoder.DecodeUint();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] current 'loudness' level when SPEAKING (0..10)
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantSoundLevel</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantSoundLevel(SktParticipant sender, SktEvents.OnParticipantSoundLevelArgs e)</b></tt>
     */
    public uint P_SOUND_LEVEL
    {
        get { if (!cache[11]) FetchSoundLevelFromRuntime(); return cache_sound_level; }
    }
    
    internal void FetchSoundLevelFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SOUND_LEVEL from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 941, this.OID);
        if (skypeRef.transport.PropResponseWasOk(941))
        {
            cache_sound_level = skypeRef.decoder.DecodeUint();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] call (audio and video) debug info
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantDebuginfo</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantDebuginfo(SktParticipant sender, SktEvents.OnParticipantDebuginfoArgs e)</b></tt>
     */
    public String P_DEBUGINFO
    {
        get { if (!cache[12]) FetchDebuginfoFromRuntime(); return cache_debuginfo; }
    }
    
    internal void FetchDebuginfoFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DEBUGINFO from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 942, this.OID);
        if (skypeRef.transport.PropResponseWasOk(942))
        {
            cache_debuginfo = skypeRef.decoder.DecodeString();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] DEPRECATED, use last_leavereason instead
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLastVoiceError</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLastVoiceError(SktParticipant sender, SktEvents.OnParticipantLastVoiceErrorArgs e)</b></tt>
     */
    public String P_LAST_VOICE_ERROR
    {
        get { if (!cache[13]) FetchLastVoiceErrorFromRuntime(); return cache_last_voice_error; }
    }
    
    internal void FetchLastVoiceErrorFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LAST_VOICE_ERROR from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 947, this.OID);
        if (skypeRef.transport.PropResponseWasOk(947))
        {
            cache_last_voice_error = skypeRef.decoder.DecodeString();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] space separated tokens values: CPU_INUSE CPU_SLOW CPU_HIGH HIGH_ECHO HIGH_NOISE MUTED_INPUT LOW_INPUT
      MUTED_INPUT_ACTIVITY FW_STRONG FW_BAD NOT_UDP CALL_BW_LOW RECORD_ERROR + values in video debug info
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantQualityProblems</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantQualityProblems(SktParticipant sender, SktEvents.OnParticipantQualityProblemsArgs e)</b></tt>
     */
    public String P_QUALITY_PROBLEMS
    {
        get { if (!cache[14]) FetchQualityProblemsFromRuntime(); return cache_quality_problems; }
    }
    
    internal void FetchQualityProblemsFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_QUALITY_PROBLEMS from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 949, this.OID);
        if (skypeRef.transport.PropResponseWasOk(949))
        {
            cache_quality_problems = skypeRef.decoder.DecodeString();
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] participant type during livesession as specified in IDENTITYTYPE
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLiveType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLiveType(SktParticipant sender, SktEvents.OnParticipantLiveTypeArgs e)</b></tt>
     */
    public SktSkype.IDENTITYTYPE P_LIVE_TYPE
    {
        get { if (!cache[15]) FetchLiveTypeFromRuntime(); return cache_live_type; }
    }
    
    internal void FetchLiveTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 950, this.OID);
        if (skypeRef.transport.PropResponseWasOk(950))
        {
            cache_live_type = (SktSkype.IDENTITYTYPE)skypeRef.decoder.DecodeUint();
            cache[15] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] participant livesession country code - used for emergency calls only atm
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLiveCountry</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLiveCountry(SktParticipant sender, SktEvents.OnParticipantLiveCountryArgs e)</b></tt>
     */
    public String P_LIVE_COUNTRY
    {
        get { if (!cache[16]) FetchLiveCountryFromRuntime(); return cache_live_country; }
    }
    
    internal void FetchLiveCountryFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_COUNTRY from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 951, this.OID);
        if (skypeRef.transport.PropResponseWasOk(951))
        {
            cache_live_country = skypeRef.decoder.DecodeString();
            cache[16] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] Transferor identity (transferee side)
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantTransferredBy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantTransferredBy(SktParticipant sender, SktEvents.OnParticipantTransferredByArgs e)</b></tt>
     */
    public String P_TRANSFERRED_BY
    {
        get { if (!cache[17]) FetchTransferredByFromRuntime(); return cache_transferred_by; }
    }
    
    internal void FetchTransferredByFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TRANSFERRED_BY from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 952, this.OID);
        if (skypeRef.transport.PropResponseWasOk(952))
        {
            cache_transferred_by = skypeRef.decoder.DecodeString();
            cache[17] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] Identity of recipient of transfer (transferor side, caller side)
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantTransferredTo</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantTransferredTo(SktParticipant sender, SktEvents.OnParticipantTransferredToArgs e)</b></tt>
     */
    public String P_TRANSFERRED_TO
    {
        get { if (!cache[18]) FetchTransferredToFromRuntime(); return cache_transferred_to; }
    }
    
    internal void FetchTransferredToFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TRANSFERRED_TO from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 953, this.OID);
        if (skypeRef.transport.PropResponseWasOk(953))
        {
            cache_transferred_to = skypeRef.decoder.DecodeString();
            cache[18] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [ALL] Identity of the user who added this participant to the conversation, type: SktSid.String
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantAdder</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantAdder(SktParticipant sender, SktEvents.OnParticipantAdderArgs e)</b></tt>
     */
    public String P_ADDER
    {
        get { if (!cache[19]) FetchAdderFromRuntime(); return cache_adder; }
    }
    
    internal void FetchAdderFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ADDER from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 954, this.OID);
        if (skypeRef.transport.PropResponseWasOk(954))
        {
            cache_adder = skypeRef.decoder.DecodeString();
            cache[19] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  [OTHERS] Last reason for leaving conversation or live session. Provides an enum alternative to last_voice_error
      as well as the reason this participant RETIRED from the conversation.
     @n Assign your own event handler method to the <tt><b>skype.events.OnParticipantLastLeavereason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnParticipantLastLeavereason(SktParticipant sender, SktEvents.OnParticipantLastLeavereasonArgs e)</b></tt>
     */
    public SktSkype.LEAVE_REASON P_LAST_LEAVEREASON
    {
        get { if (!cache[20]) FetchLastLeavereasonFromRuntime(); return cache_last_leavereason; }
    }
    
    internal void FetchLastLeavereasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LAST_LEAVEREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(19, 955, this.OID);
        if (skypeRef.transport.PropResponseWasOk(955))
        {
            cache_last_leavereason = (SktSkype.LEAVE_REASON)skypeRef.decoder.DecodeUint();
            cache[20] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktParticipant class PropKeys */
    
    public enum PropKeys 
    {
        P_CONVO_ID              =  930,
        P_IDENTITY              =  931,
        P_RANK                  =  932,
        P_REQUESTED_RANK        =  933,
        P_TEXT_STATUS           =  934,
        P_VOICE_STATUS          =  935,
        P_VIDEO_STATUS          =  936,
        P_LIVE_IDENTITY         =  943,
        P_LIVE_PRICE_FOR_ME     =  938,
        P_LIVE_FWD_IDENTITIES   =  948,
        P_LIVE_START_TIMESTAMP  =  939,
        P_SOUND_LEVEL           =  941,
        P_DEBUGINFO             =  942,
        P_LAST_VOICE_ERROR      =  947,
        P_QUALITY_PROBLEMS      =  949,
        P_LIVE_TYPE             =  950,
        P_LIVE_COUNTRY          =  951,
        P_TRANSFERRED_BY        =  952,
        P_TRANSFERRED_TO        =  953,
        P_ADDER                 =  954,
        P_LAST_LEAVEREASON      =  955 
    }
    
    /* SktParticipant class enums */
    
    /**  Recognized values for the P_RANK property. The P_RANK controls participant's privileges in the conversation.
      See SktParticipant.CanSetRankTo and SktParticipant.SetRankTo methods.
     */
    public enum RANK
    {
        CREATOR     =    1, /*!< Creator of the chat. There can be only one participant with this type per conversation. Other participants cannot be promoted to Creator rank.   */
        ADMIN       =    2, /*!< Participant who has administrator privileges   */
        SPEAKER     =    3, /*!< Participant who can speak and write   */
        WRITER      =    4, /*!< Participant who can write but not speak   */
        SPECTATOR   =    5, /*!< Participant who can read but not write/speak   */
        APPLICANT   =    6, /*!< Participant who is applying to join the conversation. Member cannot be demoted to applicants once they have been accepted.    */
        RETIRED     =    7, /*!< Participant who has eft or has been kicked from the conversation   */
        OUTLAW      =    8  /*!< Participant who has been banned from the chat   */
    }
    
    /**  Recognized values for the P_TEXT_STATUS property. The P_TEXT_STATUS property has two uses. Firstly, you
      can use it to implement typing indicators in your UI, to notify the local user that an incoming chat
      message from this Participant is imminent. To set the P_TEXT_STATUS value, so that remote client UIs can display the local user's typing indicator
      in their UI, use SktConversation.SetMyTextStatusTo method. Transmission of P_TEXT_STATUS updates to remote participants of conversations is controlled via SETUPKEY_DISABLE_CHAT_ACTIVITY_INDICATION
      setup key. Secondly, the TEXT_NA value enables you to detect participants who are running clients with no chat capability.
     
     */
    public enum TEXT_STATUS
    {
        TEXT_UNKNOWN       =    0, /*!< Fallback state in case the text status is not (yet) deternmined.   */
        TEXT_NA            =    1, /*!< Text status is not applicable as the participant is using a Skype client that does not support chat (for example: voice-only USB phones).   */
        READING            =    2, /*!< Participant is currently not typing.   */
        WRITING            =    3, /*!< Participant is currently typing.   */
        WRITING_AS_ANGRY   =    4, /*!< This state should be set when following two conditions are true: @li interval between keypresses are less than 20 ms; @li at least one of the keys adjacent to current key are pressed down.   */
        WRITING_AS_CAT     =    5  /*!< The "Cat on keyboard detection" algorthm in Skype is implemented in the UI level, and as such is not present in the SkypeKit API. Should you wish to implement similar algorthm in your own UI, you can get the basic logic from the PawSense FAQ - http://www.bitboost.com/pawsense/pawsense-faq.html   */
    }
    
    /**  Recognized values for the P_VOICE_STATUS property.
     */
    public enum VOICE_STATUS
    {
        VOICE_UNKNOWN      =    0, /*!< Participant voice status is not (yet) determined.   */
        VOICE_NA           =    1, /*!< Participant is using a Skype client with no audio capability.   */
        VOICE_AVAILABLE    =    2, /*!< Participant is using a Skype client that supports audio.   */
        VOICE_CONNECTING   =    3, /*!< Participant is in process of joining current live session. This is a transitional state.   */
        RINGING            =    4, /*!< Participant has been invited to join the live session but has not yet accepted.   */
        EARLY_MEDIA        =    5, /*!< Participant is in process of joining current live session. This is another transitional state.   */
        LISTENING          =    6, /*!< Participant has joined the current live session but is currently not transmitting audio.   */
        SPEAKING           =    7, /*!< Participant has joined the current live session and is transmitting audio. The UI can either use this state to display appropriate "speaking" notification, or alternatively use Participant::P_SOUND_LEVEL if you want your speaking indicator to also reflect audio volume coming from the Participant.   */
        VOICE_ON_HOLD      =    8, /*!< Participant has joined the current live session but the audio is currently on hold.   */
        VOICE_STOPPED      =    9  /*!< Participant will be placed in this state for some seconds after live session has finished. This is another transitional state.   */
    }
    
    /**  Recognized values for the P_VIDEO_STATUS property. This property applies to Participant's video send
      capability, not capability to receive video.
     */
    public enum VIDEO_STATUS
    {
        VIDEO_UNKNOWN      =    0, /*!< Video status is not (yet) determined.   */
        VIDEO_NA           =    1, /*!< Indicates that this Participant does not have video available..   */
        VIDEO_AVAILABLE    =    2, /*!< Indicates that video is available for this participant. When the Participant::P_VIDEO_STATUS obtains this state, it is possible to retrieve the Video object, using Participant::GetVideo method. Further operations, such as starting or stopping the video send/receive will then go through the Video object.   */
        VIDEO_CONNECTING   =    3, /*!< Transitional state indicating that the Participant is attempting to initiate video send.   */
        STREAMING          =    4, /*!< Indicates that the participant is currently sending video.   */
        VIDEO_ON_HOLD      =    5  /*!< Indicates that the participant video send is currently paused.   */
    }
    
    /**  DTMF
     */
    public enum DTMF
    {
        DTMF_0       =    0, /*!<   */
        DTMF_1       =    1, /*!<   */
        DTMF_2       =    2, /*!<   */
        DTMF_3       =    3, /*!<   */
        DTMF_4       =    4, /*!<   */
        DTMF_5       =    5, /*!<   */
        DTMF_6       =    6, /*!<   */
        DTMF_7       =    7, /*!<   */
        DTMF_8       =    8, /*!<   */
        DTMF_9       =    9, /*!<   */
        DTMF_STAR    =   10, /*!<   */
        DTMF_POUND   =   11  /*!<   */
    }
    
    /* SktParticipant class methods */
    
    /**  Checks whether the current user can set this Participant's conversation privileges to the specified RANK.
      This enables you to gray out or disable in your UI all the unavailable options for SktParticipant.SetRankTo
      method.
        @returns result Returns true if local user can set participant's rank to the value given in rank argument. 
        @param [in] rank - SktParticipant.RANK value to check for.
     */
    public Boolean CanSetRankTo (SktParticipant.RANK rank)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.CanSetRankTo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)rank);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktParticipant.CanSetRankTo");
        return (Boolean)args[0];
    }
    
    /**  Sets Participant's conversation privileges to the given RANK
        @param [in] rank - Target SktParticipant.RANK value.
     */
    public void SetRankTo (SktParticipant.RANK rank)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.SetRankTo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)rank);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.SetRankTo");
    }
    
    /**  Initiates live conversation attempt with Participant.
        @param [in] identityToUse - Ring an alternate identity, such as a PSTN number. Default value is ""
        @param [in] videoCall - Enable video. Default value is false
        @param [in] nrofRedials - Unused. Default value is 0
        @param [in] redialPeriod - Unused. Default value is 0
        @param [in] autoStartVM - Unused. On dialog, if falling on VM, greeting and recording will be automatically started. Default value is false
        @param [in] origin - When call is initiated from web link, must contain the URI that was used Default value is ""
     */
    public void Ring (
        String  identityToUse,
        Boolean videoCall,
        uint    nrofRedials,
        uint    redialPeriod,
        Boolean autoStartVM,
        String  origin)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.Ring");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.encoder.AddStringParam(1, identityToUse);
        skypeRef.encoder.AddBoolParam(2, videoCall);
        skypeRef.encoder.AddUintParam(3, nrofRedials);
        skypeRef.encoder.AddUintParam(4, redialPeriod);
        skypeRef.encoder.AddBoolParam(5, autoStartVM);
        skypeRef.encoder.AddStringParam(6, origin);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.Ring");
    }
    
    /**  Rings this participant, using P_LIVE_IDENTITY property if set.
     */
    public void RingIt ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.RingIt");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.RingIt");
    }
    
    /**  Sets LIVE_IDENTITY property, an alternate identity to use when ringing, such as a PSTN.
        @param [in] identityToUse - Empty string will reset it to default, i.e IDENTITY property value Default value is ""
     */
    public void SetLiveIdentityToUse (String identityToUse)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.SetLiveIdentityToUse");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddStringParam(1, identityToUse);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.SetLiveIdentityToUse");
    }
    
    /**  Retrieves a reference to the Video object that corresponds to the Participant. It can be either local
      video - you can check if this participant's name (P_IDENTITY property) matches the name of the currently
      logged in account (P_SKYPENAME property) or incoming video from a remote participant. Note that for GetVideo
      to be successful, the video has to be available for that participant. This can be checked for by examining Participant VIDEO_STATUS property - once it becomes VIDEO_AVAILABLE - you
      can use GetVideo to obtain the Video object.
        @returns video Returns reference to a constructed video object. 
     */
    public SktVideo GetVideo ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.GetVideo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{11}, ref tagMap, "SktParticipant.GetVideo");
        return (SktVideo)args[0];
    }
    
    /**  Removes this participant from the current live session. Note that this does not remove the participant
      from conversation (for this, use SktParticipant.Retire). It only removes participant from live state.
     
     */
    public void Hangup ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.Hangup");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.Hangup");
    }
    
    /**  Forcibly removes this participant from conversation. This method is for removing other people from conversations
      (for example: as administrative punishment for flooding conversation with spam messages). For local user
      to leave a conversation, use SktConversation.RetireFrom instead.
     */
    public void Retire ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.Retire");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktParticipant.Retire");
    }
    
    /**  For myself participant returns a list of attached send videos. For non-myself - list of recv videos.
     
        @returns videos
     */
    public SktVideo.List GetLiveSessionVideos ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Participant.GetLiveSessionVideos");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 145, OID);
        SktVideo.List videos = new SktVideo.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktParticipant.GetLiveSessionVideos failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        videos = (SktVideo.List)skypeRef.decoder.DecodeObjectList(11);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktParticipant.GetLiveSessionVideos", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return videos;
    } // SktParticipant.GetLiveSessionVideos
    
    internal override void DispatchEvent (uint eventId)
    {
        switch (eventId)
        {
            case 1:
                skypeRef.events.ProcessOnParticipantIncomingDTMF(this);
                break;
            case 146:
                skypeRef.events.ProcessOnParticipantLiveSessionVideosChanged(this);
                break;
            default:
                skypeRef.Error(String.Format("Invalid event ID {0} received for class Participant", eventId)); break;
        }
    }
}

/*! \class SktSkype
  \brief
  The main class that exposes Skype-related functionality to your application. Currently the SDK only supports
  one Skype class instance per runtime. Note that most of the Skype class methods will fail until you have
  successfully logged in with an account. For more information on constructing a Skype object and the login
  sequence, see first tutorial example.
 @n <h2>Events</h2>
<tt>void <b>SktEvents.OnSkypeNewCustomContactGroup</b> (SktSkype sender, SktEvents.OnSkypeNewCustomContactGroupArgs e)</tt>@n
 
  @param group  eg, new contact group loaded from CBL (SktContactGroup)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeContactOnlineAppearance</b> (SktSkype sender, SktEvents.OnSkypeContactOnlineAppearanceArgs e)</tt>@n
 
  This contact has appeared online. display alert
  @param contact  (SktContact)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeContactGoneOffline</b> (SktSkype sender, SktEvents.OnSkypeContactGoneOfflineArgs e)</tt>@n
 
  This contact has gone offline. display alert
  @param contact  (SktContact)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeConversationListChange</b> (SktSkype sender, SktEvents.OnSkypeConversationListChangeArgs e)</tt>@n
 
  This event gets fired when a Conversation item is added or removed from the list specified in the type
  argument. The primary use of this event is to detect creation of new Conversation objects. It can also
  be used for detecting occurance of live sessions - by monitoring added = true in SktConversation.LIVE_CONVERSATIONS.
  Note that this method is not entirely sufficient for detecting live session termination (added = false
  and type = SktConversation.LIVE_CONVERSATIONS). When the live session goes down, the default behaviour
  is that the Conversation object remains in the LIVE_CONVERSATIONS list for approximately 10 seconds.
  When another live session comes up within the same Conversation, the OnConversationListChange event will
  not fire - because the conversation was already in that list. There are two ways of getting around that.
  Firstly you can have all the conversations referenced at all times and then monitor SktConversation.P_LOCAL_LIVESTATUS
  property changes, in which case you can pick up incoming live sessions from there. Alternatively, you
  can remove the delay between live session termination and conversation's removal from the LIVE_CONVERSATIONS
  list. This delay is controlled by the SETUPKEY_RECENTLY_LIVE_TIMEOUT setup key. To remove the delay,
  use SktSkype.SetInt(SETUPKEY_RECENTLY_LIVE_TIMEOUT, 0). Note that this setup key is account-based. You
  will need to have an account logged in in order to modify its value.
  @param conversation  Conversation object that was added or removed to a list specified in the type argument. (SktConversation)
  @param type  Specifies the list, into which the conversation was added or removed from. (SktConversation.LIST_TYPE)
  @param added  Specifies whether the conversation was added or removed. For ALL_CONVERSATIONS list, the removed event
  is only fired when the conversation is actually deleted. (Boolean)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeMessage</b> (SktSkype sender, SktEvents.OnSkypeMessageArgs e)</tt>@n
 
  @param message  (SktMessage)
  @param changesInboxTimestamp  if changesInboxTimestamp==true is a hint that tray alert should probably be displayed (Boolean)
  @param supersedesHistoryMessage  DEPRECATED, not set anymore (SktMessage)
  @param conversation  (SktConversation)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeAvailableVideoDeviceListChange</b> (SktSkype sender, SktEvents.OnSkypeAvailableVideoDeviceListChangeArgs e)</tt>@n
 
  This callback gets fired when there are changes in the system video device list (USB webcam gets plugged
  in or is detached.) Note that local webcams are unavailable immediately after account login. It takes
  several seconds to populate and verify the webcam list. Thus, if your UI makes use of local video, you
  should always use this event for enabling video-related features in your UI.
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeH264Activated</b> (SktSkype sender, SktEvents.OnSkypeH264ActivatedArgs e)</tt>@n
 
  Event is implemented only in SkypeKit builds. Fired when Skype video library uses software H264 codec
  for the first time on the particular hardware by particular SkypeKit-based application
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeQualityTestResult</b> (SktSkype sender, SktEvents.OnSkypeQualityTestResultArgs e)</tt>@n
 
  @param testType  (SktSkype.QUALITYTESTTYPE)
  @param testResult  (SktSkype.QUALITYTESTRESULT)
  @param withUser  (String)
  @param details  (String)
  @param xmlDetails  (String)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeAvailableDeviceListChange</b> (SktSkype sender, SktEvents.OnSkypeAvailableDeviceListChangeArgs e)</tt>@n
 
  This callback gets fired when there are changes in the system audio device list (USB headset gets plugged
  in or is detached.)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeNrgLevelsChange</b> (SktSkype sender, SktEvents.OnSkypeNrgLevelsChangeArgs e)</tt>@n
 
  This callback gets fired when the audio strength changes in either playback or recording audio streams.
  Useful for providing visual indicators of audio activity in your UI.
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeProxyAuthFailure</b> (SktSkype sender, SktEvents.OnSkypeProxyAuthFailureArgs e)</tt>@n
 
  @param type  (SktSkype.PROXYTYPE)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeApp2AppDatagram</b> (SktSkype sender, SktEvents.OnSkypeApp2AppDatagramArgs e)</tt>@n
 
  This event gets fired on incoming app2app datagram.
  @param appname  App2app application ID. (String)
  @param stream  App2app stream ID - see OnApp2AppStreamListChange event for obtaining stream IDs. (String)
  @param data  Datagram payload - limited to 1500 bytes. (byte[])
 
<hr />
 @n 
<tt>void <b>SktEvents.OnSkypeApp2AppStreamListChange</b> (SktSkype sender, SktEvents.OnSkypeApp2AppStreamListChangeArgs e)</tt>@n
 
  In context of datagrams, this event will fire when: @li Connection is established between two app2app
  applications. That is, when both parties have an app up with the same name and -both- used App2AppConnect
  In that case, both parties get this event, with listType ALL_STREAMS @li When a datagram is sent, the
  sender will get this event with listType SENDING_STREAMS Receiver of the datagram will get OnApp2AppDatagram
  event instead. @li When the remote party drops app2app connection, the local user will get OnApp2AppStreamListChange
  with listType ALL_STREAMS and streams.size() zero. In context of stream reads/writes, this event will fire for both the sender (listType == SENDING_STREAMS)and
  the receiver (listType == RECEIVED_STREAMS). For receiver side, this is the place to put your reading
  code - App2AppRead.
  @param appname  application ID - the name you supplied in App2AppCreate. (String)
  @param listType  application list type (read/write/all) (SktSkype.APP2APP_STREAMS)
  @param streams  SEStringlist with affected stream IDs. (List<String>)
  @param receivedSizes  For RECEIVED_STREAMS, contains the number of bytes in each stream waiting to be read (List<uint>)
 
<hr />
 @n 
 */
public class SktSkype : SktSkypeBase
{
    public override String ClassName { get { return "Skype"; } }
    
    public override uint ClassId { get { return 0; } }
    
    /** Skype constructor for Windows Forms applications.
    
    NB! You should only use the logging switches during development and testing. Do not leave them ON in
    your production code. The logging, particularly transport logging, can cause substantial drop in your
    application's performane. To give you the picture - transport logging does a file append operation
    every time a byte is read from or written to the IPC socket.
    
    @param form Normally, this should be the main form of your application. The purpose of coupling the SkypeKit wrapper
    with a GUI form is that the asynchronous events that come in from the runtime side, such as events
    or property updates could be executed within GUI thread.
    
    @param cert X509 certificate, extracted from your keypair file. NB! The X509Certificate2 assumes the keyfile 
    being in .pfx format. If your keyfile is still in pem format, you will need to convert it to .pfx.
    
    @param wrapperLog Enables generation of wrapper debug log. This log records wrapper internal activity. You can use 
    this two ways. By default, simply switching this argument true, will create a "wrapper.log" file in your 
    application's executable directory. The name of this file cannot be changed, each client run will overwrite 
    the existing file. Secondly, you can assign your own callback to skype.events.OnLog event. 
    With this callback you can get the log in real time, in your UI. If the OnLog event is assigned, the "wrapper.log" 
    will no longer be generated.
    
    @param transportLog Enables generation of wrapper transport log. The transport log contains IPC traffic 
    between the wrapper and the runtime. The log file is named "transport.log" and is also placed in your 
    application's executable directory.
    
    @param port local TCP port for wrapper-runtime communication. If you launch the runtime automatically with 
    SktSkype.LaunchRuntime then the runtime will also take the communication port from this value.
    */
    
    public SktSkype (
        Form form, 
        X509Certificate2 cert, 
        bool wrapperLog, 
        bool transportLog,
        int port)
        :base(cert, wrapperLog, transportLog, port)
    {
        debugMode = false;
        RegisterDefaultClasses();
        events = new SktEvents(form, this);
        events.OnConnect += events.OnConnectInternalCallback;    
    }
    
    /** Skype constructor for console applications. In console applications, all the callbacks you assign to events
    and property change updates will fire in individual threads. You will need to synchronize data with your main thread,
    as necessary.
    
    NB! You should only use the logging switches during development and testing. Do not leave them ON in
    your production code. The logging, particularly transport logging, can cause substantial drop in your
    application's performane. To give you the picture - transport logging does a file append operation
    every time a byte is read from or written to the IPC socket.
    
    @param cert X509 certificate, extracted from your keypair file. NB! The X509Certificate2 assumes the keyfile 
    being in .pfx format. If your keyfile is still in pem format, you will need to convert it to .pfx.
    
    @param wrapperLog Enables generation of wrapper debug log. This log records wrapper internal activity. You can use 
    this two ways. By default, simply switching this argument true, will create a "wrapper.log" file in your 
    application's executable directory. The name of this file cannot be changed, each client run will overwrite 
    the existing file. Secondly, you can assign your own callback to skype.events.OnLog event. 
    With this callback you can get the log in real time, in your UI. If the OnLog event is assigned, the "wrapper.log" 
    will no longer be generated.
    
    @param transportLog Enables generation of wrapper transport log. The transport log contains IPC traffic 
    between the wrapper and the runtime. The log file is named "transport.log" and is also placed in your 
    application's executable directory.
    
    @param port local TCP port for wrapper-runtime communication. If you launch the runtime automatically with 
    SktSkype.LaunchRuntime then the runtime will also take the communication port from this value.
    */
    
    public SktSkype (
        X509Certificate2 cert, 
        bool wrapperLog, 
        bool transportLog,
        int port) 
        :base(cert, wrapperLog, transportLog, port)
    {
        debugMode = false;
        RegisterDefaultClasses();
        events = new SktEvents(null, this);    
        events.OnConnect += events.OnConnectInternalCallback;    
    }
    
    /** Returns version of the wrapper library. */
    public override String WrapperVersion { get { return "1.4"; } }
    
    /** Returns version of SkypeKit runtime version that the wrapper was tested on.
     *  <b>NB!</b> You should not use this library with mismatching runtimes.
     *  Even if things seem to work at first. The IPC protocol is resilient enough to
     *  survive most interface level changes. However, this resilience is strongly less than infinite.
     */
    public override String SupportedRuntimeVersion { get { return "4.2"; } }
    
    /** Runtime version check. Returns false if version number reported by the runtime on 
     * connect and the wrapper SupportedRuntimeVersion property fail to match.
     * This check is not fatal - it does not drop out with an exception.
     * <b>NB!</b> You should not use this library with mismatching runtimes.
     * Even if things seem to work at first. The IPC protocol is resilient enough to
     * survive most interface level changes. The changes that will kill it are thus harder to find.
     */
    public override Boolean CheckVersion()
    {
        String runtimeVersion = "";
        runtimeVersion = GetVersionString();
        string[] sections = runtimeVersion.Split('/');
        Boolean ok = sections[0].Equals(SupportedRuntimeVersion);
        if (!ok) { Log(String.Format("WARNING! Runtime version {0} and supported runtime version ({1})mismatch", sections[0], SupportedRuntimeVersion)); }
        return ok;
    }
    
    
    /** Returns a property subscription string. This string is used during the wrapper-runtime handshake.
     * The string consists of comma-separated <classID>:<propID> pairs and tells the runtime to always 
     * send the new values, together with property update notifications.
     */
    public override string GetPropSubscriptionString()
    {
            return "SkypeKit/SubscridedProperties=" +
            "19:930,19:931,19:932,19:933,19:934,19:935,19:936,19:943,19:938,19:948,19:939,19:941,19:942,19:947,19:949,19:950," +
            "19:951,19:952,19:953,19:954,19:955,10:155,10:154,10:151,10:152,10:153,11:130,11:131,11:132,11:133,11:134,11:1104," +
            "11:1105,9:960,9:120,9:122,9:123,9:792,9:790,9:121,9:961,9:962,9:968,9:222,9:223,9:963,9:964,9:127," +
            "9:125,9:966,9:126,9:982,7:100,7:101,7:102,7:103,7:104,7:105,7:106,7:107,7:108,7:109,7:830,7:831," +
            "6:80,6:81,6:82,6:83,6:84,6:85,6:86,6:87,6:88,6:89,6:90,6:91,6:92,6:93,6:98,2:202," +
            "2:4,2:6,2:5,2:7,2:8,2:9,2:10,2:11,2:12,2:13,2:14,2:15,2:16,2:17,2:18,2:37," +
            "2:26,2:205,2:27,2:36,2:19,2:28,2:29,2:182,2:183,2:20,2:25,2:35,2:34,2:21,2:22,2:23," +
            "2:33,2:180,2:39,2:41,2:184,2:185,2:186,2:187,2:188,2:189,2:42,18:972,18:902,18:918,18:974,18:996," +
            "18:920,18:921,18:925,18:924,18:927,18:928,18:973,18:975,18:976,18:977,18:970,18:971,18:979,18:981,18:915,18:903," +
            "18:904,18:919,18:922,18:906,18:907,18:909,18:980,18:910,18:911,18:913,18:914,1:200,12:190,12:1211,12:191,12:192," +
            "12:48,12:198,12:193,12:49,12:194,12:199,12:195,12:196,12:197,12:840,5:70,5:71,5:73,5:78,5:72,5:74," +
            "5:75,5:804,5:76,5:79,5:77,5:160,5:161,5:162,5:163,5:164,5:165,5:166,5:168,5:169,5:773,5:800," +
            "5:801,5:802,5:4,5:5,5:7,5:8,5:9,5:10,5:11,5:12,5:13,5:14,5:15,5:16,5:17,5:18," +
            "5:19,5:26,5:27,5:28,5:34,5:37,5:182,5:183,5:205";
    }
    
    /** This is a Participant class override registration method. Every time you write your own subclass derived 
     *  from SktParticipant you will need to inform your skype object, so that when a new Participant needs to be
     *  created, it can create your version of Participant instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewParticipant = (oid, skp) => { return new MyParticipant(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyParticipant by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewParticipant;
    
    internal SktParticipant DefaultNewParticipant (uint oid, SktSkype skype) { return new SktParticipant(oid, skype); }
    
    /** This is a ContactGroup class override registration method. Every time you write your own subclass derived 
     *  from SktContactGroup you will need to inform your skype object, so that when a new ContactGroup needs to be
     *  created, it can create your version of ContactGroup instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewContactGroup = (oid, skp) => { return new MyContactGroup(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyContactGroup by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewContactGroup;
    
    internal SktContactGroup DefaultNewContactGroup (uint oid, SktSkype skype) { return new SktContactGroup(oid, skype); }
    
    /** This is a Video class override registration method. Every time you write your own subclass derived 
     *  from SktVideo you will need to inform your skype object, so that when a new Video needs to be
     *  created, it can create your version of Video instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewVideo = (oid, skp) => { return new MyVideo(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyVideo by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewVideo;
    
    internal SktVideo DefaultNewVideo (uint oid, SktSkype skype) { return new SktVideo(oid, skype); }
    
    /** This is a Message class override registration method. Every time you write your own subclass derived 
     *  from SktMessage you will need to inform your skype object, so that when a new Message needs to be
     *  created, it can create your version of Message instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewMessage = (oid, skp) => { return new MyMessage(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyMessage by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewMessage;
    
    internal SktMessage DefaultNewMessage (uint oid, SktSkype skype) { return new SktMessage(oid, skype); }
    
    /** This is a Voicemail class override registration method. Every time you write your own subclass derived 
     *  from SktVoicemail you will need to inform your skype object, so that when a new Voicemail needs to be
     *  created, it can create your version of Voicemail instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewVoicemail = (oid, skp) => { return new MyVoicemail(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyVoicemail by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewVoicemail;
    
    internal SktVoicemail DefaultNewVoicemail (uint oid, SktSkype skype) { return new SktVoicemail(oid, skype); }
    
    /** This is a Transfer class override registration method. Every time you write your own subclass derived 
     *  from SktTransfer you will need to inform your skype object, so that when a new Transfer needs to be
     *  created, it can create your version of Transfer instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewTransfer = (oid, skp) => { return new MyTransfer(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyTransfer by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewTransfer;
    
    internal SktTransfer DefaultNewTransfer (uint oid, SktSkype skype) { return new SktTransfer(oid, skype); }
    
    /** This is a Contact class override registration method. Every time you write your own subclass derived 
     *  from SktContact you will need to inform your skype object, so that when a new Contact needs to be
     *  created, it can create your version of Contact instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewContact = (oid, skp) => { return new MyContact(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyContact by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewContact;
    
    internal SktContact DefaultNewContact (uint oid, SktSkype skype) { return new SktContact(oid, skype); }
    
    /** This is a Conversation class override registration method. Every time you write your own subclass derived 
     *  from SktConversation you will need to inform your skype object, so that when a new Conversation needs to be
     *  created, it can create your version of Conversation instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewConversation = (oid, skp) => { return new MyConversation(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyConversation by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewConversation;
    
    internal SktConversation DefaultNewConversation (uint oid, SktSkype skype) { return new SktConversation(oid, skype); }
    
    /** This is a ContactSearch class override registration method. Every time you write your own subclass derived 
     *  from SktContactSearch you will need to inform your skype object, so that when a new ContactSearch needs to be
     *  created, it can create your version of ContactSearch instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewContactSearch = (oid, skp) => { return new MyContactSearch(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyContactSearch by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewContactSearch;
    
    internal SktContactSearch DefaultNewContactSearch (uint oid, SktSkype skype) { return new SktContactSearch(oid, skype); }
    
    /** This is a Sms class override registration method. Every time you write your own subclass derived 
     *  from SktSms you will need to inform your skype object, so that when a new Sms needs to be
     *  created, it can create your version of Sms instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewSms = (oid, skp) => { return new MySms(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MySms by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewSms;
    
    internal SktSms DefaultNewSms (uint oid, SktSkype skype) { return new SktSms(oid, skype); }
    
    /** This is a Account class override registration method. Every time you write your own subclass derived 
     *  from SktAccount you will need to inform your skype object, so that when a new Account needs to be
     *  created, it can create your version of Account instead. You can do this by adding the following line,
     *  someplace between your skype construction and skype.Connect (f.e. in your Form constructor:
     *  @code
     *  skype.NewAccount = (oid, skp) => { return new MyAccount(oid, skp); };
     *  @endcode
     *  This will cause all the objects with matching class ID to be created as instances of your MyAccount by the wrapper.
     *  
     *   Alternatively, if your language does not support lambda expressions, you can do it like this:
     *  @code
     *  public MyContact NewMyContact (uint objectId, SktSkype skype)
     *  {
     *      return new MyContact(objectId, skype);
     *  }
     *  
     *  skype.NewContact = NewMyContact;
     *  @endcode
     */
    public SktNewObjectDelegate NewAccount;
    
    internal SktAccount DefaultNewAccount (uint oid, SktSkype skype) { return new SktAccount(oid, skype); }
    
    /** Register creator methods for default (non-subclassed) SkypeKit classes.
     * This is called from SktSkype constructors.
     */
    internal void RegisterDefaultClasses ()
    {
        NewParticipant       = DefaultNewParticipant;
        NewContactGroup      = DefaultNewContactGroup;
        NewVideo             = DefaultNewVideo;
        NewMessage           = DefaultNewMessage;
        NewVoicemail         = DefaultNewVoicemail;
        NewTransfer          = DefaultNewTransfer;
        NewContact           = DefaultNewContact;
        NewConversation      = DefaultNewConversation;
        NewContactSearch     = DefaultNewContactSearch;
        NewSms               = DefaultNewSms;
        NewAccount           = DefaultNewAccount;
    }
    
    internal override SktObject CreateObject(uint classId, uint objectId)
    {
        SktObject newObject;
        switch (classId)
        {
            case  19 : newObject = NewParticipant(objectId, this); break;
            case  10 : newObject = NewContactGroup(objectId, this); break;
            case  11 : newObject = NewVideo(objectId, this); break;
            case   9 : newObject = NewMessage(objectId, this); break;
            case   7 : newObject = NewVoicemail(objectId, this); break;
            case   6 : newObject = NewTransfer(objectId, this); break;
            case   2 : newObject = NewContact(objectId, this); break;
            case  18 : newObject = NewConversation(objectId, this); break;
            case   1 : newObject = NewContactSearch(objectId, this); break;
            case  12 : newObject = NewSms(objectId, this); break;
            case   5 : newObject = NewAccount(objectId, this); break;
            default: skypeRef.Error(String.Format("Attempt to construct an object with invalid class ID {0}", classId)); return null;
        }
        return newObject;
    }
    
    internal override SktObjectList CreateObjectList(uint classId)
    {
        SktObjectList newList;
        switch (classId)
        {
            case  19 : newList = new SktParticipant.List(); break;
            case  10 : newList = new SktContactGroup.List(); break;
            case  11 : newList = new SktVideo.List(); break;
            case   9 : newList = new SktMessage.List(); break;
            case   7 : newList = new SktVoicemail.List(); break;
            case   6 : newList = new SktTransfer.List(); break;
            case   2 : newList = new SktContact.List(); break;
            case  18 : newList = new SktConversation.List(); break;
            case   1 : newList = new SktContactSearch.List(); break;
            case  12 : newList = new SktSms.List(); break;
            case   5 : newList = new SktAccount.List(); break;
            default: skypeRef.Error(String.Format("Attempt to construct a list object with invalid class ID {0}", classId)); return null;
        }
        return newList;
    }
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        skypeRef.Error("MapPropIdToClassId called for Skype - the wrapper has no object properties for this class.");
        return 0;
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            default:
                skypeRef.Error(String.Format("Invalid Skype class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /* SktSkype class PropKeys */
    
    public enum PropKeys 
    {
    }
    
    /* SktSkype class enums */
    
    /**  IDENTITYTYPE
     */
    public enum IDENTITYTYPE
    {
        UNRECOGNIZED        =    0, /*!<   */
        SKYPE               =    1, /*!<   */
        SKYPE_MYSELF        =    2, /*!<   */
        SKYPE_UNDISCLOSED   =    3, /*!< Not used */
        PSTN                =    4, /*!<   */
        PSTN_EMERGENCY      =    5, /*!<   */
        PSTN_FREE           =    6, /*!<   */
        PSTN_UNDISCLOSED    =    7, /*!<   */
        CONFERENCE          =    8, /*!< Multi-party conversation identity */
        EXTERNAL            =    9  /*!<   */
    }
    
    /**  NORMALIZERESULT
     */
    public enum NORMALIZERESULT
    {
        IDENTITY_OK                      =    0, /*!<   */
        IDENTITY_EMPTY                   =    1, /*!<   */
        IDENTITY_TOO_LONG                =    2, /*!<   */
        IDENTITY_CONTAINS_INVALID_CHAR   =    3, /*!<   */
        PSTN_NUMBER_TOO_SHORT            =    4, /*!<   */
        PSTN_NUMBER_HAS_INVALID_PREFIX   =    5, /*!< identity looks like pstn number but does not start with +/00/011 */
        SKYPENAME_STARTS_WITH_NONALPHA   =    6, /*!<   */
        SKYPENAME_SHORTER_THAN_6_CHARS   =    7  /*!< returned only when isNewSkypeName */
    }
    
    /**  sync failure reasons when starting a transfer
     */
    public enum TRANSFER_SENDFILE_ERROR
    {
        TRANSFER_OPEN_SUCCESS        =    0, /*!<   */
        TRANSFER_BAD_FILENAME        =    1, /*!<   */
        TRANSFER_OPEN_FAILED         =    2, /*!<   */
        TRANSFER_TOO_MANY_PARALLEL   =    3  /*!<   */
    }
    
    /**  Conversation and live state leave reasons for Participants. This type is used for the SktParticipant.P_LAST_LEAVEREASON
      property. The primary use of this type is to provide detailed cause in case of a call failure.
     */
    public enum LEAVE_REASON
    {
        LEAVE_REASON_NONE                            =    0, /*!<   */
        RETIRED_USER_INCAPABLE                       =    2, /*!< automatic, user cannot chat (only some older versions might set this) */
        RETIRED_ADDER_MUST_BE_FRIEND                 =    3, /*!< automatic */
        RETIRED_ADDER_MUST_BE_AUTHORIZED             =    4, /*!< automatic */
        RETIRED_DECLINE_ADD                          =    5, /*!< manual reason (afaik no UI uses this) */
        RETIRED_UNSUBSCRIBE                          =    6, /*!< manual reason */
        LIVE_NO_ANSWER                               =  100, /*!<   */
        LIVE_MANUAL                                  =  101, /*!< live: User hung up */
        LIVE_BUSY                                    =  102, /*!<   */
        LIVE_CONNECTION_DROPPED                      =  103, /*!<   */
        LIVE_NO_SKYPEOUT_SUBSCRIPTION                =  104, /*!<   */
        LIVE_INSUFFICIENT_FUNDS                      =  105, /*!<   */
        LIVE_INTERNET_CONNECTION_LOST                =  106, /*!<   */
        LIVE_SKYPEOUT_ACCOUNT_BLOCKED                =  107, /*!<   */
        LIVE_PSTN_COULD_NOT_CONNECT_TO_SKYPE_PROXY   =  108, /*!<   */
        LIVE_PSTN_INVALID_NUMBER                     =  109, /*!<   */
        LIVE_PSTN_NUMBER_FORBIDDEN                   =  110, /*!<   */
        LIVE_PSTN_CALL_TIMED_OUT                     =  111, /*!<   */
        LIVE_PSTN_BUSY                               =  112, /*!<   */
        LIVE_PSTN_CALL_TERMINATED                    =  113, /*!<   */
        LIVE_PSTN_NETWORK_ERROR                      =  114, /*!<   */
        LIVE_NUMBER_UNAVAILABLE                      =  115, /*!<   */
        LIVE_PSTN_CALL_REJECTED                      =  116, /*!<   */
        LIVE_PSTN_MISC_ERROR                         =  117, /*!<   */
        LIVE_INTERNAL_ERROR                          =  118, /*!<   */
        LIVE_UNABLE_TO_CONNECT                       =  119, /*!<   */
        LIVE_RECORDING_FAILED                        =  120, /*!< live: Voicemail recording failed */
        LIVE_PLAYBACK_ERROR                          =  121, /*!< live: Voicemail playback failed */
        LIVE_LEGACY_ERROR                            =  122, /*!<   */
        LIVE_BLOCKED_BY_PRIVACY_SETTINGS             =  123, /*!<   */
        LIVE_ERROR                                   =  124, /*!< live: Fallback error */
        LIVE_TRANSFER_FAILED                         =  125, /*!<   */
        LIVE_TRANSFER_INSUFFICIENT_FUNDS             =  126, /*!<   */
        LIVE_BLOCKED_BY_US                           =  127, /*!<   */
        LIVE_EMERGENCY_CALL_DENIED                   =  128  /*!<   */
    }
    
    /**  QUALITYTESTTYPE
     */
    public enum QUALITYTESTTYPE
    {
        QTT_AUDIO_IN    =    0, /*!<   */
        QTT_AUDIO_OUT   =    1, /*!<   */
        QTT_VIDEO_OUT   =    2, /*!<   */
        QTT_CPU         =    3, /*!<   */
        QTT_NETWORK     =    4, /*!<   */
        QTT_VIDEO_IN    =    5  /*!<   */
    }
    
    /**  QUALITYTESTRESULT
     */
    public enum QUALITYTESTRESULT
    {
        QTR_UNDEFINED   =    0, /*!<   */
        QTR_CRITICAL    =    1, /*!<   */
        QTR_POOR        =    2, /*!<   */
        QTR_AVERAGE     =    3, /*!<   */
        QTR_GOOD        =    4, /*!<   */
        QTR_EXCELLENT   =    5  /*!<   */
    }
    
    /**  PREPARESOUNDRESULT
     */
    public enum PREPARESOUNDRESULT
    {
        PREPARESOUND_SUCCESS                   =    0, /*!<   */
        PREPARESOUND_MISC_ERROR                =    1, /*!<   */
        PREPARESOUND_FILE_NOT_FOUND            =    2, /*!<   */
        PREPARESOUND_FILE_TOO_BIG              =    3, /*!<   */
        PREPARESOUND_FILE_READ_ERROR           =    4, /*!<   */
        PREPARESOUND_UNSUPPORTED_FILE_FORMAT   =    5, /*!<   */
        PREPARESOUND_PLAYBACK_NOT_SUPPORTED    =    6  /*!<   */
    }
    
    /**  AUDIODEVICE_CAPABILITIES
     */
    public enum AUDIODEVICE_CAPABILITIES
    {
        HAS_VIDEO_CAPTURE          =    1, /*!<   */
        HAS_USB_INTERFACE          =    2, /*!<   */
        POSSIBLY_HEADSET           =    4, /*!<   */
        HAS_AUDIO_CAPTURE          =    8, /*!<   */
        HAS_AUDIO_RENDERING        =   16, /*!<   */
        HAS_LOWBANDWIDTH_CAPTURE   =   32, /*!<   */
        IS_WEBCAM                  =   64, /*!<   */
        IS_HEADSET                 =  128, /*!<   */
        POSSIBLY_WEBCAM            =  256, /*!<   */
        HAS_VIDEO_RENDERING        = 2048, /*!<   */
        HAS_BLUETOOTH_INTERFACE    = 4096  /*!<   */
    }
    
    /**  OPERATING_MEDIA
     */
    public enum OPERATING_MEDIA
    {
        OM_UNKNOWN         =    0, /*!<   */
        OM_FREE            =    1, /*!<   */
        OM_FREE_WIRELESS   =    2, /*!<   */
        OM_3G              =    3, /*!<   */
        OM_4G              =    4  /*!<   */
    }
    
    /**  A value of this type can be returned by one of the following methods (of Skype class): ValidateAvatar,
      ValidateProfileString, ValidatePassword.
     */
    public enum VALIDATERESULT
    {
        NOT_VALIDATED              =    0, /*!< Given property could not be validated. The length of the field was within limits and the value is assumed to be Ok. Your client should treat this value as equivalent to VALIDATED_OK.   */
        VALIDATED_OK               =    1, /*!< Avatar or profile string validation succeeded.   */
        TOO_SHORT                  =    2, /*!< Password is too short.   */
        TOO_LONG                   =    3, /*!< The value exceeds max size limit for the given property.   */
        CONTAINS_INVALID_CHAR      =    4, /*!< Value contains illegal characters.   */
        CONTAINS_SPACE             =    5, /*!< Value contains whitespace.   */
        SAME_AS_USERNAME           =    6, /*!< Password cannot be the same as skypename.   */
        INVALID_FORMAT             =    7, /*!< Value has invalid format.   */
        CONTAINS_INVALID_WORD      =    8, /*!< Value contains invalid word.   */
        TOO_SIMPLE                 =    9, /*!< Password is too simple.   */
        STARTS_WITH_INVALID_CHAR   =   10  /*!< Value starts with an invalid character.   */
    }
    
    /**  PROXYTYPE
     */
    public enum PROXYTYPE
    {
        HTTPS_PROXY   =    0, /*!<   */
        SOCKS_PROXY   =    1  /*!<   */
    }
    
    /**  APP2APP_STREAMS
     */
    public enum APP2APP_STREAMS
    {
        ALL_STREAMS        =    0, /*!<   */
        SENDING_STREAMS    =    1, /*!<   */
        RECEIVED_STREAMS   =    2  /*!<   */
    }
    
    /* SktSkype class methods */
    
    /**  returns the runtime version as a string
        @returns version
     */
    public String GetVersionString ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetVersionString");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 28, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetVersionString");
        return (String)args[0];
    }
    
    /**  Returns the time as used in SkypeKit, in the form of a Unix timestamp (number of seconds since 1.1.1970).
      If the local system time is incorrect my more than one year, the time provided by the Skype network will
      be provided, which is correct. Therefore this function can be used to adjust the system time if set incorrectly
      (e.g. if set to 1.1.1970).
        @returns timestamp
     */
    public DateTime GetUnixTimestamp ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetUnixTimestamp");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 134, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetUnixTimestamp");
        return (DateTime)args[0];
    }
    
    /** 
        @returns started
     */
    public Boolean Start ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.Start");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 145, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.Start");
        return (Boolean)args[0];
    }
    
    /**  Takes TYPE argument (TYPE comes from ContactGroup class) and returns reference to the corresponding hardwired
      contact group. For example (C++): Sktskype->GetHardwiredContactGroup(ContactGroup.ONLINE_BUDDIES, GroupRef)
      would return the list of all contacts that are currently online.
        @returns contactGroup
        @param [in] type
     */
    public SktContactGroup GetHardwiredContactGroup (SktContactGroup.TYPE type)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetHardwiredContactGroup");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{10}, ref tagMap, "SktSkype.GetHardwiredContactGroup");
        return (SktContactGroup)args[0];
    }
    
    /**  Returns a list of custom contact group references, i.e. all contact groups that are not hardwired.
        @returns groups
     */
    public SktContactGroup.List GetCustomContactGroups ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetCustomContactGroups");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        SktContactGroup.List groups = new SktContactGroup.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetCustomContactGroups failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        groups = (SktContactGroup.List)skypeRef.decoder.DecodeObjectList(10);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetCustomContactGroups", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return groups;
    } // SktSkype.GetCustomContactGroups
    
    /**  Creates a new empty contact group object and returns a reference to it. The group will then show up in
      the custom group list that you can get with Skype class GetCustomContactGroups method. Existing contacts
      can be added to the new group with ContactGroup class AddContact method and a custom name can be given
      to it with GiveDisplayName method. Note that no check is made for existing of displaynames with the same
      name - if you wish to force uniqueness in custom group names you will have to check that yourself before creating the group.
        @returns group
     */
    public SktContactGroup CreateCustomContactGroup ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateCustomContactGroup");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{10}, ref tagMap, "SktSkype.CreateCustomContactGroup");
        return (SktContactGroup)args[0];
    }
    
    /**  analyzes the identity for contact type
        @returns type
        @param [in] identity
     */
    public SktContact.TYPE GetContactType (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetContactType");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetContactType");
        return (SktContact.TYPE)args[0];
    }
    
    /**  Returns a Contact object reference. If a matching contact is not found in the existing contact list,
      a new Contact object will be created. Note that if you pass in a phone number in the identity argument,
      the type for the newly created Contact will be automatically set to SktContact.PSTN Skt(Contact.SKYPE
      otherwise).
        @returns contact Returns a contact object. 
        @param [in] identity - Either skypename or a phone number
     */
    public SktContact GetContact (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetContact");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {2, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{2}, ref tagMap, "SktSkype.GetContact");
        return (SktContact)args[0];
    }
    
    /** 
        @param [out] found
        @param [out] contact
        @param [out] foundInKey type is actually PROPKEY
        @param [in] number
     */
    public void FindContactByPstnNumber (
        out Boolean found,
        out SktContact contact,
        out uint    foundInKey,
        String      number)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.FindContactByPstnNumber");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.encoder.AddStringParam(1, number);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2}, {3, 3} };
        object[] args = new object[3];
        args[0] = false;
        args[1] = null;
        args[2] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(3, ref args, new uint[3]{0,2,0}, ref tagMap, "SktSkype.FindContactByPstnNumber");
        found = (Boolean)args[0];
        contact = (SktContact)args[1];
        foundInKey = (uint)args[2];
    }
    
    /**  This takes skypename or a phone number string as argument and returns corresponding identity type (SKYPE,
      SKYPE_MYSELF, PSTN, etc.)
        @returns type
        @param [in] identity
     */
    public SktSkype.IDENTITYTYPE GetIdentityType (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetIdentityType");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 19, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetIdentityType");
        return (SktSkype.IDENTITYTYPE)args[0];
    }
    
    /**  compares two identities to see if they match
        @returns result
        @param [in] identityA
        @param [in] identityB
     */
    public Boolean IdentitiesMatch (String identityA, String identityB)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.IdentitiesMatch");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 88, OID);
        skypeRef.encoder.AddStringParam(1, identityA);
        skypeRef.encoder.AddStringParam(2, identityB);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.IdentitiesMatch");
        return (Boolean)args[0];
    }
    
    /**  This method is deprecated. Use ValidateProfileString method instead.
        @param [out] result
        @param [out] normalized
        @param [in] original
        @param [in] isNewSkypeName Default value is false
     */
    public void NormalizeIdentity (
        out SktSkype.NORMALIZERESULT result,
        out String   normalized,
        String       original,
        Boolean      isNewSkypeName)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.NormalizeIdentity");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 9, OID);
        skypeRef.encoder.AddStringParam(1, original);
        skypeRef.encoder.AddBoolParam(2, isNewSkypeName);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.NormalizeIdentity");
        result = (SktSkype.NORMALIZERESULT)args[0];
        normalized = (String)args[1];
    }
    
    /**  NormalizePSTNWithCountry checks if the phone number starts with + if it doesn't, it prefixes the output
      with +XXX (where XXX is the country code). It also converts letters to numbers based on the standard
      phone keypad, so that the phone number string 212CALLME1 with country code 372 (Estonia) would be normalized
      to +3722122255631. If the method cannot normalize the phone number (because it's too long, too short,
      etc.), it returns an error code in &result.
        @param [out] result
        @param [out] normalized
        @param [in] original
        @param [in] countryPrefix Default value is 0
     */
    public void NormalizePSTNWithCountry (
        out SktSkype.NORMALIZERESULT result,
        out String  normalized,
        String      original,
        uint        countryPrefix)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.NormalizePSTNWithCountry");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 205, OID);
        skypeRef.encoder.AddStringParam(1, original);
        skypeRef.encoder.AddUintParam(2, countryPrefix);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.NormalizePSTNWithCountry");
        result = (SktSkype.NORMALIZERESULT)args[0];
        normalized = (String)args[1];
    }
    
    /**  list of (min,max) pairs
        @returns rangeList
     */
    public List<uint> GetOptimalAgeRanges ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetOptimalAgeRanges");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 77, OID);
        List<uint> rangeList = new List<uint>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetOptimalAgeRanges failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        rangeList = skypeRef.decoder.DecodeUintList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetOptimalAgeRanges", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return rangeList;
    } // SktSkype.GetOptimalAgeRanges
    
    /**  Creates a blank contact search object, in which you can add your custom search terms. For more information
      how asynchronous contact search works, see ContactSearch class details.
        @returns search Returns blank ContactSearch object. 
     */
    public SktContactSearch CreateContactSearch ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateContactSearch");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{1}, ref tagMap, "SktSkype.CreateContactSearch");
        return (SktContactSearch)args[0];
    }
    
    /**  searches skypenames, aliases, fullnames, emails. false if not valid
        @returns search
        @param [in] text
     */
    public SktContactSearch CreateBasicContactSearch (String text)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateBasicContactSearch");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 11, OID);
        skypeRef.encoder.AddStringParam(1, text);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{1}, ref tagMap, "SktSkype.CreateBasicContactSearch");
        return (SktContactSearch)args[0];
    }
    
    /**  searches skypenames and aliases. returns 0 or 1 results. false if not valid
        @returns search
        @param [in] identity
     */
    public SktContactSearch CreateIdentitySearch (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateIdentitySearch");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{1}, ref tagMap, "SktSkype.CreateIdentitySearch");
        return (SktContactSearch)args[0];
    }
    
    /**  Creates a new empty conversation object and returns a reference to it.
        @returns conference
     */
    public SktConversation CreateConference ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateConference");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktSkype.CreateConference");
        return (SktConversation)args[0];
    }
    
    /**  Returns reference tp conversation object by conversation ID string (equivalent of old chat ID). NB! ID
      here is that of conversation, rather than skypename of dialog partner. If you want to retrieve a conversation
      object with any particular person, then Skype class GetConversationByParticipants method is what you
      are looking for.
        @returns conversation
        @param [in] convoIdentity
        @param [in] matchPSTN - The matchPSTN parameter changes the behaviour of the method for PSTN numbers. When matchPSTN is true,
      the method will look if there is a skypename that has this PSTN number associated (in his profile or
      as user-assigned phone number), and if there is, the method returns the conversation with that skypename.
      When matchPSTN is false, the method will simply return the conversation whose identity is that PSTN number.
      Default value is true
     */
    public SktConversation GetConversationByIdentity (String convoIdentity, Boolean matchPSTN)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetConversationByIdentity");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 15, OID);
        skypeRef.encoder.AddStringParam(1, convoIdentity);
        skypeRef.encoder.AddBoolParam(2, matchPSTN);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktSkype.GetConversationByIdentity");
        return (SktConversation)args[0];
    }
    
    /**  myself not included
        @returns conversation
        @param [in] participantIdentities
        @param [in] createIfNonExisting Default value is false
        @param [in] ignoreBookmarkedOrNamed Default value is false
     */
    public SktConversation GetConversationByParticipants (
        List<String>      participantIdentities,
        Boolean           createIfNonExisting,
        Boolean           ignoreBookmarkedOrNamed)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetConversationByParticipants");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 16, OID);
        skypeRef.encoder.AddStringListParam(1, participantIdentities);
        skypeRef.encoder.AddBoolParam(2, createIfNonExisting);
        skypeRef.encoder.AddBoolParam(3, ignoreBookmarkedOrNamed);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktSkype.GetConversationByParticipants");
        return (SktConversation)args[0];
    }
    
    /**  Retrieves a Conversation object by Public Conversation BLOB. Public conversation blobs are globally unique
      conversation IDs that provide a method for joining conversation without explicitly being added to the
      conversation by someone already in it. Programmatically, a Conversation BLOB can be retrieved with SktConversation.GetJoinBlob
      method. In Skype desktop clients, the BLOB can be retrieved by typing "/get uri" in a conversation. The
      conversation can then be joined by people who have somehow received that BLOB.
        @returns conversation Returns Conversation object if successful. 
        @param [in] joinBlob - The BLOB string.
        @param [in] alsoJoin - If set to true, automatically joins current user into the Conversation. Default value is true
     */
    public SktConversation GetConversationByBlob (String joinBlob, Boolean alsoJoin)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetConversationByBlob");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 17, OID);
        skypeRef.encoder.AddStringParam(1, joinBlob);
        skypeRef.encoder.AddBoolParam(2, alsoJoin);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktSkype.GetConversationByBlob");
        return (SktConversation)args[0];
    }
    
    /**  Returns a list of Conversation objects by SktConversation.LIST_TYPE filter.
        @returns conversations List of conversations matching the filter. 
        @param [in] type - Filter. Default value is SktConversation.LIST_TYPE.ALL_CONVERSATIONS
     */
    public SktConversation.List GetConversationList (SktConversation.LIST_TYPE type)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetConversationList");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 18, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        SktConversation.List conversations = new SktConversation.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetConversationList failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        conversations = (SktConversation.List)skypeRef.decoder.DecodeObjectList(18);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetConversationList", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return conversations;
    } // SktSkype.GetConversationList
    
    /**  Retrieves a Message object by the P_GUID property (globally unique ID, same for all the participants
      of the conversation, in which this message occured).
        @returns message Returns a Message object if a match was found. 
        @param [in] guid - Globally unique ID of the message.
     */
    public SktMessage GetMessageByGuid (byte[] guid)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetMessageByGuid");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 21, OID);
        skypeRef.encoder.AddBinaryParam(1, guid);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{9}, ref tagMap, "SktSkype.GetMessageByGuid");
        return (SktMessage)args[0];
    }
    
    /**  Returns all messages of the given type
        @returns messages
        @param [in] type - Type of messages requested. For POSTED_TEXT or POSTED_EMOTE, returns a list with both types
        @param [in] latestPerConvOnly - Whether to return only the most recent message per conversation
        @param [in] fromTimestampInc - Starting timestamp for reqested range, inclusive
        @param [in] toTimestampExc - Ending timestamp for requested range, exclusive
     */
    public SktMessage.List GetMessageListByType (
        SktMessage.TYPE      type,
        Boolean              latestPerConvOnly,
        DateTime             fromTimestampInc,
        DateTime             toTimestampExc)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetMessageListByType");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 136, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.encoder.AddBoolParam(2, latestPerConvOnly);
        skypeRef.encoder.AddTimeStampParam(3, fromTimestampInc);
        skypeRef.encoder.AddTimeStampParam(4, toTimestampExc);
        SktMessage.List messages = new SktMessage.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetMessageListByType failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        messages = (SktMessage.List)skypeRef.decoder.DecodeObjectList(9);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetMessageListByType", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return messages;
    } // SktSkype.GetMessageListByType
    
    /**  This method returns a table in form of two string lists of equal length and an uint argument that returns
      the count of items i both lists. The first list contains video recording device handles and the second
      list descriptive names of those devices. NB! This method will return empty lists immediately after account
      login. It takes several seconds to populate and check the local webcams and until this check is complete,
      local video remains unavailable. The correct procedure is to handle the SktSkype.OnAvailableVideoDeviceListChange
      event, and only enable UI features that require webcam, after you get non-empty webcam lists in this
      event callback.
        @param [out] deviceNames
        @param [out] devicePaths
        @param [out] count
     */
    public void GetAvailableVideoDevices (
        out List<String> deviceNames,
        out List<String> devicePaths,
        out uint count)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetAvailableVideoDevices");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 80, OID);
        deviceNames = new List<String>(); // We always guarantee non-null list is returned
        devicePaths = new List<String>(); // We always guarantee non-null list is returned
        count = 0;
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetAvailableVideoDevices failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        deviceNames = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        devicePaths = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        count = skypeRef.decoder.DecodeUint();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetAvailableVideoDevices", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.GetAvailableVideoDevices
    
    /**  Queries whether the given video device has a specific SktVideo.VIDEO_DEVICE_CAPABILITY. Use SktSkype.GetAvailableVideoDevices
      method to retrieve sstring lists with available deviceName and devicePath values.
        @returns result Returns true if the given device has given capability. 
        @param [in] deviceName - Human readable device name.
        @param [in] devicePath - Device ID.
        @param [in] cap - Any of the SktVideo.VIDEO_DEVICE_CAPABILITY values.
     */
    public Boolean HasVideoDeviceCapability (
        String                                deviceName,
        String                                devicePath,
        SktVideo.VIDEO_DEVICE_CAPABILITY      cap)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.HasVideoDeviceCapability");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 33, OID);
        skypeRef.encoder.AddStringParam(1, deviceName);
        skypeRef.encoder.AddStringParam(2, devicePath);
        skypeRef.encoder.AddEnumParam(3, (uint)cap);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.HasVideoDeviceCapability");
        return (Boolean)args[0];
    }
    
    /** 
        @param [in] deviceName
        @param [in] devicePath
     */
    public void DisplayVideoDeviceTuningDialog (String deviceName, String devicePath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.DisplayVideoDeviceTuningDialog");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 34, OID);
        skypeRef.encoder.AddStringParam(1, deviceName);
        skypeRef.encoder.AddStringParam(2, devicePath);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.DisplayVideoDeviceTuningDialog");
    }
    
    /**  Warning: Will be deprecated soon
        @returns video
        @param [in] type
        @param [in] deviceName - name and path to be used only with media type VIDEO Default value is ""
        @param [in] devicePath Default value is ""
     */
    public SktVideo GetPreviewVideo (
        SktVideo.MEDIATYPE      type,
        String                  deviceName,
        String                  devicePath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetPreviewVideo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 35, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.encoder.AddStringParam(2, deviceName);
        skypeRef.encoder.AddStringParam(3, devicePath);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{11}, ref tagMap, "SktSkype.GetPreviewVideo");
        return (SktVideo)args[0];
    }
    
    /** 
        @returns video
        @param [in] type
        @param [in] deviceName - name and path to be used only with media type VIDEO Default value is ""
        @param [in] devicePath Default value is ""
     */
    public SktVideo CreateLocalVideo (
        SktVideo.MEDIATYPE      type,
        String                  deviceName,
        String                  devicePath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateLocalVideo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 143, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.encoder.AddStringParam(2, deviceName);
        skypeRef.encoder.AddStringParam(3, devicePath);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{11}, ref tagMap, "SktSkype.CreateLocalVideo");
        return (SktVideo)args[0];
    }
    
    /**  Will return same object id for same device repeatedly
        @returns video
        @param [in] type
        @param [in] deviceName - name and path to be used only with media type VIDEO Default value is ""
        @param [in] devicePath Default value is ""
     */
    public SktVideo CreatePreviewVideo (
        SktVideo.MEDIATYPE      type,
        String                  deviceName,
        String                  devicePath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreatePreviewVideo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 144, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.encoder.AddStringParam(2, deviceName);
        skypeRef.encoder.AddStringParam(3, devicePath);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{11}, ref tagMap, "SktSkype.CreatePreviewVideo");
        return (SktVideo)args[0];
    }
    
    /**  Avaible to Video Engines using the Video RTP API
        @returns response
        @param [in] command
     */
    public String VideoCommand (String command)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.VideoCommand");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 59, OID);
        skypeRef.encoder.AddStringParam(1, command);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.VideoCommand");
        return (String)args[0];
    }
    
    /** 
        @param [in] withUser - if empty, network test results would reflect status of local node only
        @param [in] excludeNetworkTest
     */
    public void StartMonitoringQuality (String withUser, Boolean excludeNetworkTest)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.StartMonitoringQuality");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 140, OID);
        skypeRef.encoder.AddStringParam(1, withUser);
        skypeRef.encoder.AddBoolParam(2, excludeNetworkTest);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.StartMonitoringQuality");
    }
    
    /** 
        @returns result
        @param [in] withUser
        @param [in] justStop Default value is false
     */
    public SktSkype.QUALITYTESTRESULT StopMonitoringQuality (String withUser, Boolean justStop)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.StopMonitoringQuality");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 141, OID);
        skypeRef.encoder.AddStringParam(1, withUser);
        skypeRef.encoder.AddBoolParam(2, justStop);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.StopMonitoringQuality");
        return (SktSkype.QUALITYTESTRESULT)args[0];
    }
    
    /** 
        @returns greeting
        @param [in] skypeName
     */
    public SktVoicemail GetGreeting (String skypeName)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetGreeting");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 45, OID);
        skypeRef.encoder.AddStringParam(1, skypeName);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{7}, ref tagMap, "SktSkype.GetGreeting");
        return (SktVoicemail)args[0];
    }
    
    /**  Takes audio data that comes from the sound argument and mixes it into playback or notification device,
      depending on the value passed in the useCallOutDevice argument. The sound argument contains the audio
      data in in follwing format: first 4 bytes of the binary contain the sample rate, followed by 16 bit (mono)
      samples. The soundid argument is an arbitrary ID that you can pass in and then later use as an argument
      for Skype class PlayStop method. To mix the audio into playback device stream, set useCallOutDevice to
      true, to mic it into notification stream, set useCallOutDevice to false.
        @param [in] soundid
        @param [in] sound
        @param [in] loop
        @param [in] useCallOutDevice Default value is false
     */
    public void PlayStart (
        uint    soundid,
        byte[]  sound,
        Boolean loop,
        Boolean useCallOutDevice)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.PlayStart");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 48, OID);
        skypeRef.encoder.AddUintParam(1, soundid);
        skypeRef.encoder.AddBinaryParam(2, sound);
        skypeRef.encoder.AddBoolParam(3, loop);
        skypeRef.encoder.AddBoolParam(4, useCallOutDevice);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.PlayStart");
    }
    
    /** 
        @returns result
        @param [in] soundid
        @param [in] datafile
        @param [in] loop
        @param [in] useCallOutDevice Default value is false
     */
    public SktSkype.PREPARESOUNDRESULT PlayStartFromFile (
        uint         soundid,
        String       datafile,
        Boolean      loop,
        Boolean      useCallOutDevice)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.PlayStartFromFile");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 212, OID);
        skypeRef.encoder.AddUintParam(1, soundid);
        skypeRef.encoder.AddFileNameParam(2, datafile);
        skypeRef.encoder.AddBoolParam(3, loop);
        skypeRef.encoder.AddBoolParam(4, useCallOutDevice);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.PlayStartFromFile");
        return (SktSkype.PREPARESOUNDRESULT)args[0];
    }
    
    /**  Stops playback of the soundfile. The argument is the same ID you passed in the Skype class StartPlayback
      method.
        @param [in] soundid
     */
    public void PlayStop (uint soundid)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.PlayStop");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 49, OID);
        skypeRef.encoder.AddUintParam(1, soundid);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.PlayStop");
    }
    
    /** 
        @param [in] recordAndPlaybackData Default value is false
     */
    public void StartRecordingTest (Boolean recordAndPlaybackData)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.StartRecordingTest");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 50, OID);
        skypeRef.encoder.AddBoolParam(1, recordAndPlaybackData);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.StartRecordingTest");
    }
    
    /** 
     */
    public void StopRecordingTest ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.StopRecordingTest");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 51, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.StopRecordingTest");
    }
    
    /**  This method returns a table in form of three string lists of equal lengths. The first list contains audio
      output device handles ('hw:0,0', 'hw:0,1', etc.) The second list contains descriptive names of those
      devices (Ensoniq AudioPCI etc.) The third list contains device product IDs. Note that the values in these
      lists depend on which audio engine you are running (SAL, PCM, RTP).
        @param [out] handleList
        @param [out] nameList
        @param [out] productIdList
     */
    public void GetAvailableOutputDevices (
        out List<String> handleList,
        out List<String> nameList,
        out List<String> productIdList)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetAvailableOutputDevices");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 53, OID);
        handleList = new List<String>(); // We always guarantee non-null list is returned
        nameList = new List<String>(); // We always guarantee non-null list is returned
        productIdList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetAvailableOutputDevices failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        handleList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        nameList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        productIdList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetAvailableOutputDevices", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.GetAvailableOutputDevices
    
    /**  This method returns a table in form of three string lists of equal length. The first list contains audio
      recording device handles ('hw:0,0', 'hw:0,1', etc.) The second list contains descriptive names of those
      devices (Ensoniq AudioPCI etc.) The third list contains device product IDs. Note that the values in these
      lists depend on which audio engine you are running (SAL, PCM, RTP).
        @param [out] handleList
        @param [out] nameList
        @param [out] productIdList
     */
    public void GetAvailableRecordingDevices (
        out List<String> handleList,
        out List<String> nameList,
        out List<String> productIdList)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetAvailableRecordingDevices");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 54, OID);
        handleList = new List<String>(); // We always guarantee non-null list is returned
        nameList = new List<String>(); // We always guarantee non-null list is returned
        productIdList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetAvailableRecordingDevices failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        handleList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        nameList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        productIdList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetAvailableRecordingDevices", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.GetAvailableRecordingDevices
    
    /**  Sets audio devices given in arguments as active audio devices. This command selects all three devices
      - microphone, playback and the notification channel. Valid input values for this method come from the
      first string list you get back from Skype class GetAvailableOutputDevices (handleList).
        @param [in] callInDevice
        @param [in] callOutDevice
        @param [in] waveOutDevice
     */
    public void SelectSoundDevices (
        String callInDevice,
        String callOutDevice,
        String waveOutDevice)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SelectSoundDevices");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 55, OID);
        skypeRef.encoder.AddStringParam(1, callInDevice);
        skypeRef.encoder.AddStringParam(2, callOutDevice);
        skypeRef.encoder.AddStringParam(3, waveOutDevice);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SelectSoundDevices");
    }
    
    /**  The uint argument returns AUDIODEVICE_CAPABILITIES (declared in Skype class)
        @param [out] interfaceString
        @param [out] capabilities bit set of AUDIODEVICE_CAPABILITIES
        @param [in] deviceHandle
     */
    public void GetAudioDeviceCapabilities (
        out String  interfaceString,
        out uint    capabilities,
        String      deviceHandle)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetAudioDeviceCapabilities");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 56, OID);
        skypeRef.encoder.AddStringParam(1, deviceHandle);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = "";
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.GetAudioDeviceCapabilities");
        interfaceString = (String)args[0];
        capabilities = (uint)args[1];
    }
    
    /**  Returns current audio stream volume for both playback and microphone streams. Useful for displaying visual
      audio indicators in you UI. See also Skype class OnNrgLevelsChange callback that gets fired each time
      the these values are changed.
        @param [out] micLevel
        @param [out] speakerLevel
     */
    public void GetNrgLevels (out uint micLevel, out uint speakerLevel)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetNrgLevels");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 57, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.GetNrgLevels");
        micLevel = (uint)args[0];
        speakerLevel = (uint)args[1];
    }
    
    /**  NB! This command only works if its implemented in external audiohost (RTP or PCM host). The command can
      be is used for passing custom commands from client UI to the audio implementation.
        @returns response
        @param [in] command
     */
    public String VoiceCommand (String command)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.VoiceCommand");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 58, OID);
        skypeRef.encoder.AddStringParam(1, command);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.VoiceCommand");
        return (String)args[0];
    }
    
    /**  Returns value of audio playback volume setting (0..100).
        @returns volume
     */
    public uint GetSpeakerVolume ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetSpeakerVolume");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 60, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetSpeakerVolume");
        return (uint)args[0];
    }
    
    /**  This method is for setting speaker volume. It will set the level for Skype digital gain control. Skype
      audio library will not control gain of audio device itself.
        @param [in] volume
     */
    public void SetSpeakerVolume (uint volume)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetSpeakerVolume");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 61, OID);
        skypeRef.encoder.AddUintParam(1, volume);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetSpeakerVolume");
    }
    
    /**  Returns value of microphone volume setting (0..100). It will return the analog gain of audio device set
      by Skype AGC. For real-time microphone volume, use GetNrgLevels method or OnNrgLevelsChange callback
      (both are methods of Skype class).
        @returns micVolume
     */
    public uint GetMicVolume ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetMicVolume");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 62, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetMicVolume");
        return (uint)args[0];
    }
    
    /**  This method is for setting the microphone volume level. This does not work when Skype AGC (Automatic
      Gain Control) is enabled, which it is by default. It is currently impossible to disable AGC, so for now
      this method is here for purpose of future compatibility.
        @param [in] volume
     */
    public void SetMicVolume (uint volume)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetMicVolume");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 63, OID);
        skypeRef.encoder.AddUintParam(1, volume);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetMicVolume");
    }
    
    /**  Returns true in &muted argument if the currently selected playback device is muted.
        @returns muted
     */
    public Boolean IsSpeakerMuted ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.IsSpeakerMuted");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 64, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.IsSpeakerMuted");
        return (Boolean)args[0];
    }
    
    /**  Returns true in &muted argument if the currently selected microphone is muted.
        @returns muted
     */
    public Boolean IsMicrophoneMuted ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.IsMicrophoneMuted");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 65, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.IsMicrophoneMuted");
        return (Boolean)args[0];
    }
    
    /**  Sets currently selected playback device mute status according to argument.
        @param [in] mute
     */
    public void MuteSpeakers (Boolean mute)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.MuteSpeakers");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 66, OID);
        skypeRef.encoder.AddBoolParam(1, mute);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.MuteSpeakers");
    }
    
    /**  Sets currently selected microphone mute status according to argument.
        @param [in] mute
     */
    public void MuteMicrophone (Boolean mute)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.MuteMicrophone");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 67, OID);
        skypeRef.encoder.AddBoolParam(1, mute);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.MuteMicrophone");
    }
    
    /** 
        @param [in] media
        @param [in] maxUplinkBps
        @param [in] maxDownlinkBps
     */
    public void SetOperatingMedia (
        SktSkype.OPERATING_MEDIA media,
        uint                     maxUplinkBps,
        uint                     maxDownlinkBps)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetOperatingMedia");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 255, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)media);
        skypeRef.encoder.AddUintParam(2, maxUplinkBps);
        skypeRef.encoder.AddUintParam(3, maxDownlinkBps);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetOperatingMedia");
    }
    
    /**  creates and sends a CONFIRMATION_CODE_REQUEST message this sends a confirmation code to the number provided
     
        @returns sms
        @param [in] type
        @param [in] number
     */
    public SktSms RequestConfirmationCode (SktSms.CONFIRM_TYPE type, String number)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.RequestConfirmationCode");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 29, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)type);
        skypeRef.encoder.AddStringParam(2, number);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{12}, ref tagMap, "SktSkype.RequestConfirmationCode");
        return (SktSms)args[0];
    }
    
    /**  creates and sends a CONFIRMATION_CODE_SUBMIT message this authorizes the number with the server for the
      purpose given in RequestConfirmationCode
        @returns sms
        @param [in] number
        @param [in] code
     */
    public SktSms SubmitConfirmationCode (String number, String code)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SubmitConfirmationCode");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 30, OID);
        skypeRef.encoder.AddStringParam(1, number);
        skypeRef.encoder.AddStringParam(2, code);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{12}, ref tagMap, "SktSkype.SubmitConfirmationCode");
        return (SktSms)args[0];
    }
    
    /**  creates an OUTGOING/COMPOSING SMS message
        @returns sms
     */
    public SktSms CreateOutgoingSms ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.CreateOutgoingSms");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 70, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{12}, ref tagMap, "SktSkype.CreateOutgoingSms");
        return (SktSms)args[0];
    }
    
    /**  Retrieves an Account object by Skype name (identity). This should normally be one of the first method
      calls after Skype object initialization. Nearly all the other methods require successful account login
      in order to work properly. The list of accounts that have been used on the local machine/database can
      be retrieved with SktSkype.GetExistingAccounts method. If a matching identity is not found, a new Account
      object is created. This object can then be used to populate requred fields and then use SktAccount.Register
      method for new account creation. This method returns false on error.
        @returns account Returns account object if successful. 
        @param [in] identity - Account skypename.
     */
    public SktAccount GetAccount (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetAccount");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 115, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{5}, ref tagMap, "SktSkype.GetAccount");
        return (SktAccount)args[0];
    }
    
    /**  Returns a list of possible profiles used before on this machine
        @returns accountNameList
     */
    public List<String> GetExistingAccounts ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetExistingAccounts");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 113, OID);
        List<String> accountNameList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetExistingAccounts failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        accountNameList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetExistingAccounts", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return accountNameList;
    } // SktSkype.GetExistingAccounts
    
    /**  return most recently used account that has pwd saved. empty string if none
        @returns account
     */
    public String GetDefaultAccountName ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetDefaultAccountName");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 114, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetDefaultAccountName");
        return (String)args[0];
    }
    
    /**  suggest a nice skypename to go with given fullname
        @returns suggestedName
        @param [in] fullname
     */
    public String GetSuggestedSkypename (String fullname)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetSuggestedSkypename");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 116, OID);
        skypeRef.encoder.AddStringParam(1, fullname);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetSuggestedSkypename");
        return (String)args[0];
    }
    
    /** 
        @param [out] result
        @param [out] freeBytesLeft
        @param [in] value
     */
    public void ValidateAvatar (
        out SktSkype.VALIDATERESULT result,
        out int     freeBytesLeft,
        byte[]      value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.ValidateAvatar");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 119, OID);
        skypeRef.encoder.AddBinaryParam(1, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.ValidateAvatar");
        result = (SktSkype.VALIDATERESULT)args[0];
        freeBytesLeft = (int)args[1];
    }
    
    /**  This method should be used for validating skypenames before registering new accounts, if the propKey
      is set to SKYPENAME (Contact class) and forRegistration argument is set to true. If the forRegistration
      argument is false, only string length check is applied. It is also useful to probe, what the size limits
      are, for each string property (e.g. 300 characters for moodmessage)
        @param [out] result
        @param [out] freeBytesLeft
        @param [in] propKey
        @param [in] strValue
        @param [in] forRegistration Default value is false
     */
    public void ValidateProfileString (
        out SktSkype.VALIDATERESULT result,
        out int      freeBytesLeft,
        int          propKey,
        String       strValue,
        Boolean      forRegistration)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.ValidateProfileString");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 102, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddStringParam(2, strValue);
        skypeRef.encoder.AddBoolParam(3, forRegistration);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.ValidateProfileString");
        result = (SktSkype.VALIDATERESULT)args[0];
        freeBytesLeft = (int)args[1];
    }
    
    /**  This method is for pre-validating account passwords before account creation or password change. The result
      will return either VALIDATED_OK or one of many possible reasons the password is unacceptable (too short,
      too simple, etc.)
        @returns result
        @param [in] username
        @param [in] password
     */
    public SktSkype.VALIDATERESULT ValidatePassword (String username, String password)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.ValidatePassword");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 71, OID);
        skypeRef.encoder.AddStringParam(1, username);
        skypeRef.encoder.AddStringParam(2, password);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.ValidatePassword");
        return (SktSkype.VALIDATERESULT)args[0];
    }
    
    /**  Port number that the runtime ended up listening to. Usually equal to SETUPKEY_PORT. 0 if none used (disconnected
      or binding failed).
        @returns port
     */
    public uint GetUsedPort ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetUsedPort");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 130, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetUsedPort");
        return (uint)args[0];
    }
    
    /**  This is used for retrieving local setup keys of type string. For more information, see Defines section
      in the skype-embedded_2.h
        @returns value
        @param [in] key
     */
    public String GetStr (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetStr");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 120, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetStr");
        return (String)args[0];
    }
    
    /**  This is used for retrieving local setup keys of type int. For more information, see Defines section in
      the skype-embedded_2.h
        @returns value
        @param [in] key
     */
    public int GetInt (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetInt");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 121, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetInt");
        return (int)args[0];
    }
    
    /**  This is used for retrieving local setup keys of type binary. For more information, see Defines section
      in the skype-embedded_2.h
        @returns value
        @param [in] key
     */
    public byte[] GetBin (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetBin");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 122, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetBin");
        return (byte[])args[0];
    }
    
    /**  This is used for setting local setup keys of type string. For more information, see Defines section in
      the skype-embedded_2.h
        @param [in] key
        @param [in] value
     */
    public void SetStr (String key, String value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetStr");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 123, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.encoder.AddStringParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetStr");
    }
    
    /**  This is used for setting local setup keys of type int. For more information, see Defines section in the
      skype-embedded_2.h
        @param [in] key
        @param [in] value
     */
    public void SetInt (String key, int value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetInt");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 124, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.encoder.AddIntParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetInt");
    }
    
    /**  This is used for setting local setup keys of type binary. For more information, see Defines section in
      the skype-embedded_2.h
        @param [in] key
        @param [in] value
     */
    public void SetBin (String key, byte[] value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.SetBin");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 125, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.encoder.AddBinaryParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.SetBin");
    }
    
    /**  Returns true if the given setup key is defined in local setup. For more information, see Defines section
      in the skype-embedded_2.h
        @returns value
        @param [in] key
     */
    public Boolean IsDefined (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.IsDefined");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 126, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.IsDefined");
        return (Boolean)args[0];
    }
    
    /** 
        @param [in] key
     */
    public void Delete (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.Delete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 127, OID);
        skypeRef.encoder.AddStringParam(1, key);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktSkype.Delete");
    }
    
    /** 
        @returns value
        @param [in] key
     */
    public List<String> GetSubKeys (String key)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetSubKeys");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 128, OID);
        skypeRef.encoder.AddStringParam(1, key);
        List<String> value = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetSubKeys failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        value = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetSubKeys", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return value;
    } // SktSkype.GetSubKeys
    
    /**  Returns two string lists. First of them will contain list of two-letter language codes (ISO 639-1) The
      second list contains names of corresponding languages.
        @param [out] languageCodeList
        @param [out] languageNameList assumes UI has set correct language (UIPROP_LANGUAGE)
     */
    public void GetISOLanguageInfo (out List<String> languageCodeList, out List<String> languageNameList)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetISOLanguageInfo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 207, OID);
        languageCodeList = new List<String>(); // We always guarantee non-null list is returned
        languageNameList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetISOLanguageInfo failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        languageCodeList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        languageNameList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetISOLanguageInfo", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.GetISOLanguageInfo
    
    /**  Returns three string lists and one int array, containing 2-letter country code, country name, dialing
      prefix and example dial string (not available for all items). This method does currently return 0 for
      South Georgia and the South Sandwich Islands.
        @param [out] countryCodeList
        @param [out] countryNameList assumes UI has set correct language (UIPROP_LANGUAGE)
        @param [out] countryPrefixList
        @param [out] countryDialExampleList
     */
    public void GetISOCountryInfo (
        out List<String> countryCodeList,
        out List<String> countryNameList,
        out List<uint> countryPrefixList,
        out List<String> countryDialExampleList)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetISOCountryInfo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 208, OID);
        countryCodeList = new List<String>(); // We always guarantee non-null list is returned
        countryNameList = new List<String>(); // We always guarantee non-null list is returned
        countryPrefixList = new List<uint>(); // We always guarantee non-null list is returned
        countryDialExampleList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetISOCountryInfo failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        countryCodeList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        countryNameList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        countryPrefixList = skypeRef.decoder.DecodeUintList();
                        break;
                    case 4:
                        countryDialExampleList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetISOCountryInfo", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.GetISOCountryInfo
    
    /**  Get list of supported UI languages
        @returns uiLanguageCodeList
     */
    public List<String> GetSupportedUILanguageList ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetSupportedUILanguageList");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 135, OID);
        List<String> uiLanguageCodeList = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.GetSupportedUILanguageList failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        uiLanguageCodeList = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.GetSupportedUILanguageList", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return uiLanguageCodeList;
    } // SktSkype.GetSupportedUILanguageList
    
    /**  Returns 2-letter country code based on PSTN number. The input argument has to be without + in from of
      it - '37212345678' will return 'ee' while '+37212345678' will return an empty string.
        @returns countryCode
        @param [in] number
     */
    public String GetISOCountryCodebyPhoneNo (String number)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.GetISOCountryCodebyPhoneNo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 211, OID);
        skypeRef.encoder.AddStringParam(1, number);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.GetISOCountryCodebyPhoneNo");
        return (String)args[0];
    }
    
    /**  App2AppCreate method constructs a local instance of an App2App application. App2App applications are
      not abstracted in the SkypeKit API as a separate class. Rather, they can be created with App2AppCreate,
      supplying their name as ID, and then connected to remote parties using App2AppConnect method. App2App
      portion of the SkypeKit API enables you to implement arbitrary data exchange protocols between Skype clients. Basically, if you are ever tempted to use conversation chat messages for something other
      than actual human-readable chat - you should consider using your own custom App2App protocol instead.
      The downside of App2App is that all the participants need to be running a client that supports the same
      App2App application. Although, it is possible to have one side using a custom SkypeKit client and another
      side using Skype desktop client - App2App is supported in both, in case of desktop client via Public
      API - you are still limited to remote side running something that can recognize your protocol and react
      to connection attempts from your side. To establish connection between each other, all participants need
      to create their local instances of the application (with the same ID, and then connect to each other. More than one App2App applications
      can be active in a local client at the same time. Also, more than two clients can be connected with the
      same application. Once connection is established, you can choose between two communication methods -
      datagrams and stream read/write methods. Overall, there are not much principal difference between the two. Datagram packet
      size is limited to 1500 bytes and stream packet size to 32 KB of payload data. Implementation-wise, datagrams
      are probably somewhat easier to deal with.
        @returns result Returns true if the app creation was successful. Returns false when an application with the same name already exists in the local system. 
        @param [in] appname - Application ID. This ID is used by the rest of the App2App commands to differentiate between applications,
      should there be more than one app2app applications running on the local system.
     */
    public Boolean App2AppCreate (String appname)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppCreate");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 215, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppCreate");
        return (Boolean)args[0];
    }
    
    /**  Disconnects and deletes the App2App application.
        @returns result Returns true if the deletion was successful (application with such ID actually existed) 
        @param [in] appname - application ID.
     */
    public Boolean App2AppDelete (String appname)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppDelete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 216, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppDelete");
        return (Boolean)args[0];
    }
    
    /**  The App2AppConnect connect result does not mean the connection was immediately established. It will return
      Ok even if the remote party was offline. The actual connection will be established when both parties
      have fired App2AppConnect with the same application name, at eachother. At that point, OnApp2AppStreamListChange
      event will fire for both local and remote party (with listType argument set to ALL_STREAMS) and you can
      start exchanging data, using either App2App datagrams or App2AppRead App2AppWrite methods.
        @returns result NB! This argument will return true even if the remote party has not yet connected (or is not even online yet) - it merely indicates that the connect command was successfuly processed in runtime. The actual connection success will be indicated when the OnApp2AppStreamListChange event fires, i.e. when App2App stream will be established between connecting parties. 
        @param [in] appname - Application ID. This needs to match with application ID connecting from the remote side.
        @param [in] skypename - Skype Name of the remote party.
     */
    public Boolean App2AppConnect (String appname, String skypename)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppConnect");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 217, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddStringParam(2, skypename);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppConnect");
        return (Boolean)args[0];
    }
    
    /**  Disconnects an App2App stream. This is different from App2AppDelete command in that it enables you to
      disconnect remote parties selectively - in case there are more than two participants in the App2App stream
      pool.
        @returns result returns true when the stream disconnect was successful. 
        @param [in] appname - application ID
        @param [in] stream - stream ID.
     */
    public Boolean App2AppDisconnect (String appname, String stream)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppDisconnect");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 218, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddStringParam(2, stream);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppDisconnect");
        return (Boolean)args[0];
    }
    
    /**  Sends a stream packet to the remote party specified in the stream argument. The max size of stream write
      packet is 32KB. After calling this method, OnApp2AppStreamListChange will fire for both parties. In local
      ssytem with listType set to SENDING_STREAMS and on remote system with listType set to RECEIVED_STREAMS.
      This event can be used to read received packets out of the stream.
        @returns result returns true if the call was successful. Note that this does indicate the packet was actually received by remote party. 
        @param [in] appname - application ID
        @param [in] stream - stream ID
        @param [in] data - packet payload
     */
    public Boolean App2AppWrite (
        String      appname,
        String      stream,
        byte[]      data)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppWrite");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 219, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddStringParam(2, stream);
        skypeRef.encoder.AddBinaryParam(3, data);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppWrite");
        return (Boolean)args[0];
    }
    
    /**  Sends a datagram to the remote party specified in the stream argument. The max size of datagram payload
      is 1500 bytes.
        @returns result returns true on method success. Note that this does mean the remote party has actually received your datagram - that sort of feedback, should you want it, is up to you to implement in your custom protocol.
        @param [in] appname - application ID - from App2AppCreate
        @param [in] stream - stream ID - either from App2AppGetStreamsList or from OnApp2AppStreamListChange
        @param [in] data - datagram payload (max 1500 bytes)
     */
    public Boolean App2AppDatagram (
        String      appname,
        String      stream,
        byte[]      data)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppDatagram");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 220, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddStringParam(2, stream);
        skypeRef.encoder.AddBinaryParam(3, data);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSkype.App2AppDatagram");
        return (Boolean)args[0];
    }
    
    /**  Reads data from the specified stream. This method should be called from the OnApp2AppStreamListChange
      event callback, when this callback gets fired with listType argument set to RECEIVED_STREAMS.
        @param [out] result returns true on method success. Note that this does mean the remote party has actually received your packet - that sort of feedback, should you want it, is up to you to implement in your custom protocol. 
        @param [out] data stream packet payload 
        @param [in] appname - application ID
        @param [in] stream - stream ID
     */
    public void App2AppRead (
        out Boolean result,
        out byte[]  data,
        String      appname,
        String      stream)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppRead");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 221, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddStringParam(2, stream);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = false;
        args[1] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktSkype.App2AppRead");
        result = (Boolean)args[0];
        data = (byte[])args[1];
    }
    
    /**  App2AppGetConnectableUsers returns a list of currently online contacts. It does not return a list of
      contacts who have an app2app application running. There is currently no way of querying whether an application
      has been launched on the remote side - other than trying to connect to the remote side and waiting for
      timeout. NB! if you use App2AppGetConnectableUsers immediately after login - then the online presence
      of your contact list has not yet updated itself - so this method will most likely return either an empty
      list or a list with echo123 in it.
        @param [out] result returns true on method success 
        @param [out] users stringlist with Skype Names of connectable users 
        @param [in] appname - application ID
     */
    public void App2AppGetConnectableUsers (
        out Boolean result,
        out List<String> users,
        String      appname)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppGetConnectableUsers");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 222, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        result = false;
        users = new List<String>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.App2AppGetConnectableUsers failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        Boolean endMarker = false;
                        result = skypeRef.decoder.DecodeBool(ref endMarker);
                        if (endMarker) marker = 'z';
                        break;
                    case 2:
                        users = skypeRef.decoder.DecodeStringList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.App2AppGetConnectableUsers", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.App2AppGetConnectableUsers
    
    /**  Takes application ID and list type filter and returns a stringlist with streamID's that pass the filter.
     
        @param [out] result results true if the method call was successful 
        @param [out] streams string list with stream IDs 
        @param [out] receivedSizes For RECEIVED_STREAMS, contains the number of bytes in each stream waiting to be read
        @param [in] appname - application ID
        @param [in] listType - list type filter
     */
    public void App2AppGetStreamsList (
        out Boolean                   result,
        out List<String>              streams,
        out List<uint>                receivedSizes,
        String                        appname,
        SktSkype.APP2APP_STREAMS      listType)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Skype.App2AppGetStreamsList");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 223, OID);
        skypeRef.encoder.AddStringParam(1, appname);
        skypeRef.encoder.AddEnumParam(2, (uint)listType);
        result = false;
        streams = new List<String>(); // We always guarantee non-null list is returned
        receivedSizes = new List<uint>(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSkype.App2AppGetStreamsList failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        Boolean endMarker = false;
                        result = skypeRef.decoder.DecodeBool(ref endMarker);
                        if (endMarker) marker = 'z';
                        break;
                    case 2:
                        streams = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        receivedSizes = skypeRef.decoder.DecodeUintList();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSkype.App2AppGetStreamsList", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSkype.App2AppGetStreamsList
    
    internal override void DispatchEvent (uint eventId)
    {
        switch (eventId)
        {
            case 1:
                skypeRef.events.ProcessOnSkypeNewCustomContactGroup(this);
                break;
            case 2:
                skypeRef.events.ProcessOnSkypeContactOnlineAppearance(this);
                break;
            case 3:
                skypeRef.events.ProcessOnSkypeContactGoneOffline(this);
                break;
            case 4:
                skypeRef.events.ProcessOnSkypeConversationListChange(this);
                break;
            case 5:
                skypeRef.events.ProcessOnSkypeMessage(this);
                break;
            case 7:
                skypeRef.events.ProcessOnSkypeAvailableVideoDeviceListChange(this);
                break;
            case 44:
                skypeRef.events.ProcessOnSkypeH264Activated(this);
                break;
            case 28:
                skypeRef.events.ProcessOnSkypeQualityTestResult(this);
                break;
            case 10:
                skypeRef.events.ProcessOnSkypeAvailableDeviceListChange(this);
                break;
            case 11:
                skypeRef.events.ProcessOnSkypeNrgLevelsChange(this);
                break;
            case 12:
                skypeRef.events.ProcessOnSkypeProxyAuthFailure(this);
                break;
            case 6:
                skypeRef.events.ProcessOnSkypeApp2AppDatagram(this);
                break;
            case 8:
                skypeRef.events.ProcessOnSkypeApp2AppStreamListChange(this);
                break;
            default:
                skypeRef.Error(String.Format("Invalid event ID {0} received for class Skype", eventId)); break;
        }
    }
}

/*! \class SktContactGroup
  \brief
  Collects and manages Contacts related by type, status, or some other arbitrary criteria. @brief SkypeKit
  recognizes two distinct ContactGroup flavors - "hardwired" and "custom". SkypeKit both defines the criteria
  for and dynamically manages all "hardwired" ContactGroups. Individual users explicitly create and manage
  all "custom" ContactGroups. "Hardwired" groups are primarily organizational tools, for example, they enable you to display a list
  of all Contacts awaiting authorization by you. "Custom" groups are also organizational tools, for example,
  they enable you to display a list of all Contacts in a particular geographical area or belonging to a
  particular professional association, social clubs, and so forth. Primarily, though, "custom" groups are
  functional tools that enable you to establish conference calls, group chats, and so forth. "Hardwired" ContactGroups are defined for and available to all users. SkypeKit determines membership
  in a particular "hardwired" group dynamically whenever a user invokes Skype.GetHardwiredContactGroup
  for that group. Subsequent changes to a Contact's status might result in its being added to (for example,
  the Contact is now authorized) or removed from (for example, the Contact is now removed or blocked) one
  or more "hardwired" groups. SkypeKit fires OnChange events for all affected ContractGroup instances. Essentially all ContactGroup
  methods related to explicitly adding and removing members and conversations from the group return false,
  and CanAdd and CanRemove additionally return a false result. "Custom" ContactGroups can be defined by a particular Skype user through the UI. Your UI should implement
  Creation, deletion and filtering contact list by custom contact groups, as well as adding and removing
  contacts in those groups. A Contact can belong to multiple non-mutually exclusive "hardwired" groups at the same time, for example,
  an authorized contact is typically in your "buddy" group, but a Contact cannot belong to CONTACTS_AUTHORIZED_BY_ME
  if they are awaiting authorization. Similarly, a Contact can belong to multiple "custom" groups and mutual
  exclusivity is typically not an issue.
 @n <h2>Events</h2>
<tt>void <b>SktEvents.OnContactGroupChangeConversation</b> (SktContactGroup sender, SktEvents.OnContactGroupChangeConversationArgs e)</tt>@n
 
  conversation added or removed from this group
  @param conversation  (SktConversation)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnContactGroupChange</b> (SktContactGroup sender, SktEvents.OnContactGroupChangeArgs e)</tt>@n
 
  A contact has been added or removed to this ContactGroup. NB! On rare occasions, the ContectRef argument to this callback can be NULL. You should always check
  whether the reference is valid, before accessing methods or properties.
  @param contact  (SktContact)
 
<hr />
 @n 
 */
public class SktContactGroup : SktObject
{
    public override String ClassName { get { return "ContactGroup"; } }
    
    public override uint ClassId { get { return 10; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktContactGroup (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(5);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktContactGroup objects.
     */
    public class List : SktObjectList
    {
        new public SktContactGroup this[int index]
        {
            get { return (SktContactGroup)base[index]; }
        }

        public void Add(SktContactGroup item)
        {
            base.Add((SktContactGroup)item);
        }
    }
    

    /* SktContactGroup property cache fields */
    private volatile SktContactGroup.TYPE cache_type;
    private volatile uint                 cache_custom_group_id;
    private volatile String               cache_given_displayname;
    private volatile uint                 cache_nrofcontacts;
    private volatile uint                 cache_nrofcontacts_online;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        skypeRef.Error("MapPropIdToClassId called for ContactGroup - the wrapper has no object properties for this class.");
        return 0;
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 155: /* ContactGroup.P_TYPE */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktContactGroup.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("ContactGroup.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactGroup.P_TYPE - update without value");
                skypeRef.events.FireOnContactGroupType(this, cache_type);
                break;
                
            case 154: /* ContactGroup.P_CUSTOM_GROUP_ID */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_custom_group_id = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("ContactGroup.P_CUSTOM_GROUP_ID = " + cache_custom_group_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactGroup.P_CUSTOM_GROUP_ID - update without value");
                skypeRef.events.FireOnContactGroupCustomGroupId(this, cache_custom_group_id);
                break;
                
            case 151: /* ContactGroup.P_GIVEN_DISPLAYNAME */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_given_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("ContactGroup.P_GIVEN_DISPLAYNAME = " + cache_given_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactGroup.P_GIVEN_DISPLAYNAME - update without value");
                skypeRef.events.FireOnContactGroupGivenDisplayname(this, cache_given_displayname);
                break;
                
            case 152: /* ContactGroup.P_NROFCONTACTS */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_nrofcontacts = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("ContactGroup.P_NROFCONTACTS = " + cache_nrofcontacts.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactGroup.P_NROFCONTACTS - update without value");
                skypeRef.events.FireOnContactGroupNrofcontacts(this, cache_nrofcontacts);
                break;
                
            case 153: /* ContactGroup.P_NROFCONTACTS_ONLINE */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_nrofcontacts_online = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("ContactGroup.P_NROFCONTACTS_ONLINE = " + cache_nrofcontacts_online.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactGroup.P_NROFCONTACTS_ONLINE - update without value");
                skypeRef.events.FireOnContactGroupNrofcontactsOnline(this, cache_nrofcontacts_online);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid ContactGroup class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktContactGroup property accessors **/
    
    /**  SktContactGroup.TYPE
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGroupType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGroupType(SktContactGroup sender, SktEvents.OnContactGroupTypeArgs e)</b></tt>
     */
    public SktContactGroup.TYPE P_TYPE
    {
        get { if (!cache[0]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(10, 155, this.OID);
        if (skypeRef.transport.PropResponseWasOk(155))
        {
            cache_type = (SktContactGroup.TYPE)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  unique 32-bit ID for custom groups
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGroupCustomGroupId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGroupCustomGroupId(SktContactGroup sender, SktEvents.OnContactGroupCustomGroupIdArgs e)</b></tt>
     */
    public uint P_CUSTOM_GROUP_ID
    {
        get { if (!cache[1]) FetchCustomGroupIdFromRuntime(); return cache_custom_group_id; }
    }
    
    internal void FetchCustomGroupIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CUSTOM_GROUP_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(10, 154, this.OID);
        if (skypeRef.transport.PropResponseWasOk(154))
        {
            cache_custom_group_id = skypeRef.decoder.DecodeUint();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  change via SktContactGroup.GiveDisplayname()
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGroupGivenDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGroupGivenDisplayname(SktContactGroup sender, SktEvents.OnContactGroupGivenDisplaynameArgs e)</b></tt>
     */
    public String P_GIVEN_DISPLAYNAME
    {
        get { if (!cache[2]) FetchGivenDisplaynameFromRuntime(); return cache_given_displayname; }
    }
    
    internal void FetchGivenDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GIVEN_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(10, 151, this.OID);
        if (skypeRef.transport.PropResponseWasOk(151))
        {
            cache_given_displayname = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Number of contacts in the group. NB! The value of this property does not get updated until 5 seconds
      after account login. During these initial 5 seconds, the value of this property remains 0. The reason
      for this 5 second delay is to reduce the flurry of property update traffic that occurs during the CBL
      synchronization phase, following successful login. Note that if you absolutely need to have this value
      immediately after login, you can still get it by retrieving the contact list with SktContactGroup.GetContacts
      method and examining its size.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGroupNrofcontacts</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGroupNrofcontacts(SktContactGroup sender, SktEvents.OnContactGroupNrofcontactsArgs e)</b></tt>
     */
    public uint P_NROFCONTACTS
    {
        get { if (!cache[3]) FetchNrofcontactsFromRuntime(); return cache_nrofcontacts; }
    }
    
    internal void FetchNrofcontactsFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_NROFCONTACTS from runtime");
        skypeRef.transport.SubmitPropertyRequest(10, 152, this.OID);
        if (skypeRef.transport.PropResponseWasOk(152))
        {
            cache_nrofcontacts = skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  number of contacts online in the group
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGroupNrofcontactsOnline</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGroupNrofcontactsOnline(SktContactGroup sender, SktEvents.OnContactGroupNrofcontactsOnlineArgs e)</b></tt>
     */
    public uint P_NROFCONTACTS_ONLINE
    {
        get { if (!cache[4]) FetchNrofcontactsOnlineFromRuntime(); return cache_nrofcontacts_online; }
    }
    
    internal void FetchNrofcontactsOnlineFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_NROFCONTACTS_ONLINE from runtime");
        skypeRef.transport.SubmitPropertyRequest(10, 153, this.OID);
        if (skypeRef.transport.PropResponseWasOk(153))
        {
            cache_nrofcontacts_online = skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktContactGroup class PropKeys */
    
    public enum PropKeys 
    {
        P_TYPE                 =  155,
        P_CUSTOM_GROUP_ID      =  154,
        P_GIVEN_DISPLAYNAME    =  151,
        P_NROFCONTACTS         =  152,
        P_NROFCONTACTS_ONLINE  =  153 
    }
    
    /* SktContactGroup class enums */
    
    /**  The list of all possible ContactGroup types. A value of this type can be passed to Skype class GetHardwiredContactGroup
      to retrieve the relevant ContactGroup object.
     */
    public enum TYPE
    {
        ALL_KNOWN_CONTACTS                  =    1, /*!< The superset of all "hardwired" contact groups.   */
        ALL_BUDDIES                         =    2, /*!< The set of all authorized contacts, that is, contacts that were last the target of Contact::SetBuddyStatus(false) plus all SkypeOut contacts.   */
        SKYPE_BUDDIES                       =    3, /*!< The set of all authorized Skype contacts (Contact:_SKYPENAME is non-null).   Note that this excludes Skype contacts that have either never been the target of Contact::SetBuddyStatus(true) or were last the target of Contactact::SetBuddyStatus(false).   */
        SKYPEOUT_BUDDIES                    =    4, /*!< The set of all SkypeOut contacts (Contact:_PSTNNUMBER is non-null). PSTN contacts can be added to the contact list by retrieving a new contact object with Skype::GetContact, passing in the phone number as string, and then either using Contact::SetBuddyStatus(true) or adding the contact to the SKYPEOUT_BUDDIES group with ContactGroup::AddContact.   */
        ONLINE_BUDDIES                      =    5, /*!< The subset of ALL_BUDDIES that are currently online, including those currently marked as DO_NOT_DISTURBED and AWAY.   */
        UNKNOWN_OR_PENDINGAUTH_BUDDIES      =    6, /*!< The set of all contacts whose Contact:_TYPE reflects UNRECOGNIZED OR have not authorized the local user yet.   */
        RECENTLY_CONTACTED_CONTACTS         =    7, /*!< This filter returns top 10 most recently contacted contacts, based on Contact::P_LASTUSED_TIMESTAMP property values. This is not configurable. Note that the P_LASTUSED_TIMESTAMP property does not propagate between different Skype instances - thus this filter only works in context of the local database. Recent contacts that were in touch with the user on some other Skype installation will not show up in this filter.   */
        CONTACTS_WAITING_MY_AUTHORIZATION   =    8, /*!< Contacts to whose authorization request the user has not responded yet. The UI should enable the user to accept, decline the authorization request and in case of decline, optionally block further incoming communication from the contact. See: Contact::SetBuddyStatus, Contact::SetBlocked and Contact::IgnoreAuthRequest for more information.   */
        CONTACTS_AUTHORIZED_BY_ME           =    9, /*!< All contacts authorized by the user.   */
        CONTACTS_BLOCKED_BY_ME              =   10, /*!< Group of contacts the user has blocked from further incoming communications. If the UI enables contact blocking, it should also provide interface for the user to unblock the blocked contacts. Note that a contact can simultaneously be in both CONTACTS_BLOCKED_BY_ME and CONTACTS_AUTHORIZED_BY_ME groups.   */
        UNGROUPED_BUDDIES                   =   11, /*!< The set of all "buddies" that are not also a member of a custom group.   */
        CUSTOM_GROUP                        =   12, /*!< A custom group defined by user.   */
        PROPOSED_SHARED_GROUP               =   13, /*!< The shared contact group functionality is no longer supported. This contact group type can be ignored.   */
        SHARED_GROUP                        =   14, /*!< The shared contact group functionality is no longer supported. This contact group type can be ignored.   */
        EXTERNAL_CONTACTS                   =   15  /*!< The set of all contacts that were originally imported from an external address book.   */
    }
    
    /* SktContactGroup class methods */
    
    /**  Setter for ContactGroup class GIVEN_DISPLAYNAME property.
        @param [in] name
     */
    public void GiveDisplayName (String name)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.GiveDisplayName");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.encoder.AddStringParam(1, name);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactGroup.GiveDisplayName");
    }
    
    /**  Removes the contact group. This is synced across instances logged in with the same account - which can
      take several minutes for the sync to happen.
        @returns result
     */
    public Boolean Delete ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.Delete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactGroup.Delete");
        return (Boolean)args[0];
    }
    
    /**  Returns list of conversations in the ContactGroup.
        @returns conversations
     */
    public SktConversation.List GetConversations ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.GetConversations");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        SktConversation.List conversations = new SktConversation.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktContactGroup.GetConversations failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        conversations = (SktConversation.List)skypeRef.decoder.DecodeObjectList(18);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktContactGroup.GetConversations", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return conversations;
    } // SktContactGroup.GetConversations
    
    /**  Checks if the current user can add given conversation to the ContactGroup. Returns false for most of
      the hardwired contact groups for example.
        @returns result Returns true if Conversation can be added to this ContactGroup. 
        @param [in] conversation - Conversation to be checked. Default value is null
     */
    public Boolean CanAddConversation (SktConversation conversation)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.CanAddConversation");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.encoder.AddObjectParam(1, conversation);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactGroup.CanAddConversation");
        return (Boolean)args[0];
    }
    
    /**  Adds given conversation to the ContactGroup.
        @param [in] conversation
     */
    public void AddConversation (SktConversation conversation)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.AddConversation");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.encoder.AddObjectParam(1, conversation);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactGroup.AddConversation");
    }
    
    /**  Checks if the current user can remove given conversation from the ContactGroup. Again, returns false
      for most hardwired contact groups.
        @returns result true if RemoveConversation(contact) works on this group
     */
    public Boolean CanRemoveConversation ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.CanRemoveConversation");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactGroup.CanRemoveConversation");
        return (Boolean)args[0];
    }
    
    /**  Removes given conversation from the ContactGroup.
        @param [in] conversation
     */
    public void RemoveConversation (SktConversation conversation)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.RemoveConversation");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddObjectParam(1, conversation);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactGroup.RemoveConversation");
    }
    
    /**  Retrieves contact list.
        @returns contacts
     */
    public SktContact.List GetContacts ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.GetContacts");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        SktContact.List contacts = new SktContact.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktContactGroup.GetContacts failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        contacts = (SktContact.List)skypeRef.decoder.DecodeObjectList(2);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktContactGroup.GetContacts", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return contacts;
    } // SktContactGroup.GetContacts
    
    /**  Checks if the current user can add given contact to the ContactGroup.
        @returns result returns true if AddContact(contact) works on this group. 
        @param [in] contact - Contact to be checked. Default value is null
     */
    public Boolean CanAddContact (SktContact contact)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.CanAddContact");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 9, OID);
        skypeRef.encoder.AddObjectParam(1, contact);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactGroup.CanAddContact");
        return (Boolean)args[0];
    }
    
    /**  Adds contact to a contact group. This only works for non-hardwired contact groups.
        @param [in] contact
     */
    public void AddContact (SktContact contact)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.AddContact");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.encoder.AddObjectParam(1, contact);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactGroup.AddContact");
    }
    
    /**  Checks if the current user can remove given contact from the ContactGroup.
        @returns result true if RemoveContact(contact) works on this group
     */
    public Boolean CanRemoveContact ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.CanRemoveContact");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 11, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactGroup.CanRemoveContact");
        return (Boolean)args[0];
    }
    
    /**  Removes contact from the ContactGroup.
        @param [in] contact
     */
    public void RemoveContact (SktContact contact)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactGroup.RemoveContact");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.encoder.AddObjectParam(1, contact);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactGroup.RemoveContact");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        switch (eventId)
        {
            case 1:
                skypeRef.events.ProcessOnContactGroupChangeConversation(this);
                break;
            case 2:
                skypeRef.events.ProcessOnContactGroupChange(this);
                break;
            default:
                skypeRef.Error(String.Format("Invalid event ID {0} received for class ContactGroup", eventId)); break;
        }
    }
}

/*! \class SktVideo
  \brief
  This class contains basic video control functionality for live conversations with video. Basically, Video
  objects represent specific Participant's video state in a live Conversation. The Video class can represent
  both local (outgoing) and remote (incoming) video streams. Note that as of SkypeKit SDK version 3.2,
  this class no longer handles video rendering in the UI. @brief Currently available SkypeKit runtimes
  do not support multi-party video. The API however is designed with future compatibility in mind, so the
  Video class is attached to Participant class rather than Conversation class. Once multi-party video will
  become available for SkypeKit, the logic should go like this: Let there be 4-way live conversation C and participants P1, P2, P3 and P4. P1 is the local user. Remote
  participants P2 and P3 are capable of sending video. Remote user P4 is not capable of sending video.
  You would then end up with 4 video objects: V1, V2, V3 and V0. 
  @li C->P1->V1-> outgoing video stream 
  @li C->P2->V2-> incoming video stream 1 
  @li C->P3->V3-> incoming
  video stream 2 
  @li C->P4-> no video object as participant P4 does not advertise supporting video 
  @li
  V0-> local webcam preview - this is not attached to any particular conversation, however the corresponding
  video object can be retrieved with SktSkype.GetPreviewVideo method. As getting from a live conversation to running video streams involves three classes, it can be somewhat
  less than obvious. The basic state transition logic goes like this: You start out with a Conversation, that suddenly becomes live SktCONVERSATION.LOCAL_LIVESTATUS = IM_LIVE At this point you have access to participant list of that conversation. The next step will be to catch
  Partcipant property changes for SktPARTICIPANT.VIDEO_STATUS to see if any of the people in conversation
  have Video available. Note that you should not make assumptions on when this availability happens. Remote
  users may switch their video on-off as they please. SktPARTICIPANT.VIDEO_STATUS = VIDEO_AVAILABLE If you get to VIDEO_AVAILABLE (not necessarily for all Participants), you can retrieve Video object,
  with SktParticipant.GetVideo method. Now you will need to handle SktVideo.STATUS property changes. In case of successful video call, the sequence
  of SktVideo.STATUS and SktParticipant.VIDEO_STATUS changes for each Participant and Video object should
  look like this: 
  @li SktVideo.STATUS = AVAILABLE 
  @li SktVideo.STATUS = STARTING 
  @li SktVideo.STATUS = CHECKING_SUBSCRIPTION
  
  @li SktVideo.STATUS = STARTING SktParticipant.VIDEO_STATUS = VIDEO_CONNECTING 
  @li SktVideo.STATUS = RUNNING 
  @li SktParticipant.VIDEO_STATUS
  = STREAMING Both SktVideo.STATUS == RUNNING and SktParticipant.VIDEO_STATUS == STREAMING are indicative that the
  video for that particular participant is up and running, and your UI should update itself accordingly.
  NB! Note that it is not enough to check for SktVideo.STATUS property updates. By the time you obtain
  the Video object in your client, it may already it may already have progressed to a further status. You
  should always check the status property immediately after obtaining the Video object.
 */
public class SktVideo : SktObject
{
    public override String ClassName { get { return "Video"; } }
    
    public override uint ClassId { get { return 11; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktVideo (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(7);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktVideo objects.
     */
    public class List : SktObjectList
    {
        new public SktVideo this[int index]
        {
            get { return (SktVideo)base[index]; }
        }

        public void Add(SktVideo item)
        {
            base.Add((SktVideo)item);
        }
    }
    

    /* SktVideo property cache fields */
    private volatile SktVideo.STATUS    cache_status;
    private volatile String             cache_error;
    private volatile String             cache_debuginfo;
    private volatile String             cache_dimensions;
    private volatile SktVideo.MEDIATYPE cache_media_type;
    private volatile SktConversation    cache_convo_id;
    private volatile String             cache_device_path;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 1104: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 130: /* Video.P_STATUS */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_status = (SktVideo.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_STATUS = " + cache_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_STATUS - update without value");
                skypeRef.events.FireOnVideoStatus(this, cache_status);
                break;
                
            case 131: /* Video.P_ERROR */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_error = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_ERROR = " + cache_error.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_ERROR - update without value");
                skypeRef.events.FireOnVideoError(this, cache_error);
                break;
                
            case 132: /* Video.P_DEBUGINFO */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_debuginfo = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_DEBUGINFO = " + cache_debuginfo.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_DEBUGINFO - update without value");
                skypeRef.events.FireOnVideoDebuginfo(this, cache_debuginfo);
                break;
                
            case 133: /* Video.P_DIMENSIONS */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_dimensions = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_DIMENSIONS = " + cache_dimensions.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_DIMENSIONS - update without value");
                skypeRef.events.FireOnVideoDimensions(this, cache_dimensions);
                break;
                
            case 134: /* Video.P_MEDIA_TYPE */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_media_type = (SktVideo.MEDIATYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_MEDIA_TYPE = " + cache_media_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_MEDIA_TYPE - update without value");
                skypeRef.events.FireOnVideoMediaType(this, cache_media_type);
                break;
                
            case 1104: /* Video.P_CONVO_ID */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_id = null;
                    if (skypeRef.logging) skypeRef.Log("A bugged convo_id update. ignoring it.");
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_CONVO_ID - update without value");
                skypeRef.events.FireOnVideoConvoId(this, cache_convo_id);
                break;
                
            case 1105: /* Video.P_DEVICE_PATH */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_device_path = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Video.P_DEVICE_PATH = " + cache_device_path.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Video.P_DEVICE_PATH - update without value");
                skypeRef.events.FireOnVideoDevicePath(this, cache_device_path);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Video class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktVideo property accessors **/
    
    /**  SktVideo.STATUS
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoStatus(SktVideo sender, SktEvents.OnVideoStatusArgs e)</b></tt>
     */
    public SktVideo.STATUS P_STATUS
    {
        get { if (!cache[0]) FetchStatusFromRuntime(); return cache_status; }
    }
    
    internal void FetchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 130, this.OID);
        if (skypeRef.transport.PropResponseWasOk(130))
        {
            cache_status = (SktVideo.STATUS)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  'errorcode errortext'
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoError</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoError(SktVideo sender, SktEvents.OnVideoErrorArgs e)</b></tt>
     */
    public String P_ERROR
    {
        get { if (!cache[1]) FetchErrorFromRuntime(); return cache_error; }
    }
    
    internal void FetchErrorFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ERROR from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 131, this.OID);
        if (skypeRef.transport.PropResponseWasOk(131))
        {
            cache_error = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  space-separated string of tokens
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoDebuginfo</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoDebuginfo(SktVideo sender, SktEvents.OnVideoDebuginfoArgs e)</b></tt>
     */
    public String P_DEBUGINFO
    {
        get { if (!cache[2]) FetchDebuginfoFromRuntime(); return cache_debuginfo; }
    }
    
    internal void FetchDebuginfoFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DEBUGINFO from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 132, this.OID);
        if (skypeRef.transport.PropResponseWasOk(132))
        {
            cache_debuginfo = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This property does not currently work, always containing an empty string. For desktop video, you can
      get the frame dimensions from the video frame buffers API instead - the buffer struct retrieved with
      ipc.getFrame() or ipc.getNewFrame() has width and height fields, which you can then use in your UI. With
      RTP video solutions, you already have the frame sizes in your videohost code. Communicating these to
      the UI process is currently up to you.
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoDimensions</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoDimensions(SktVideo sender, SktEvents.OnVideoDimensionsArgs e)</b></tt>
     */
    public String P_DIMENSIONS
    {
        get { if (!cache[3]) FetchDimensionsFromRuntime(); return cache_dimensions; }
    }
    
    internal void FetchDimensionsFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DIMENSIONS from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 133, this.OID);
        if (skypeRef.transport.PropResponseWasOk(133))
        {
            cache_dimensions = skypeRef.decoder.DecodeString();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Indicates whether the video object is streaming webcam video or screensharing session, values: MEDIA_SCREENSHARING,
      MEDIA_VIDEO
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoMediaType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoMediaType(SktVideo sender, SktEvents.OnVideoMediaTypeArgs e)</b></tt>
     */
    public SktVideo.MEDIATYPE P_MEDIA_TYPE
    {
        get { if (!cache[4]) FetchMediaTypeFromRuntime(); return cache_media_type; }
    }
    
    internal void FetchMediaTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MEDIA_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 134, this.OID);
        if (skypeRef.transport.PropResponseWasOk(134))
        {
            cache_media_type = (SktVideo.MEDIATYPE)skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  conference id to be able to identify remote/local video in the same call
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoConvoId(SktVideo sender, SktEvents.OnVideoConvoIdArgs e)</b></tt>
     */
    public SktConversation P_CONVO_ID
    {
        get { if (!cache[5]) FetchConvoIdFromRuntime(); return cache_convo_id; }
    }
    
    internal void FetchConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 1104, this.OID);
        if (skypeRef.transport.PropResponseWasOk(1104))
        {
            cache_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  device path used by video object
     @n Assign your own event handler method to the <tt><b>skype.events.OnVideoDevicePath</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVideoDevicePath(SktVideo sender, SktEvents.OnVideoDevicePathArgs e)</b></tt>
     */
    public String P_DEVICE_PATH
    {
        get { if (!cache[6]) FetchDevicePathFromRuntime(); return cache_device_path; }
    }
    
    internal void FetchDevicePathFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DEVICE_PATH from runtime");
        skypeRef.transport.SubmitPropertyRequest(11, 1105, this.OID);
        if (skypeRef.transport.PropResponseWasOk(1105))
        {
            cache_device_path = skypeRef.decoder.DecodeString();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktVideo class PropKeys */
    
    public enum PropKeys 
    {
        P_STATUS       =  130,
        P_ERROR        =  131,
        P_DEBUGINFO    =  132,
        P_DIMENSIONS   =  133,
        P_MEDIA_TYPE   =  134,
        P_CONVO_ID     = 1104,
        P_DEVICE_PATH  = 1105 
    }
    
    /* SktVideo class enums */
    
    /**  STATUS
     */
    public enum STATUS
    {
        NOT_AVAILABLE                =    0, /*!<   */
        AVAILABLE                    =    1, /*!<   */
        STARTING                     =    2, /*!<   */
        REJECTED                     =    3, /*!<   */
        RUNNING                      =    4, /*!<   */
        STOPPING                     =    5, /*!<   */
        PAUSED                       =    6, /*!<   */
        NOT_STARTED                  =    7, /*!<   */
        HINT_IS_VIDEOCALL_RECEIVED   =    8, /*!<   */
        UNKNOWN                      =    9, /*!<   */
        RENDERING                    =   10, /*!<   */
        CHECKING_SUBSCRIPTION        =   11, /*!<   */
        SWITCHING_DEVICE             =   12  /*!<   */
    }
    
    /**  MEDIATYPE
     */
    public enum MEDIATYPE
    {
        MEDIA_SCREENSHARING   =    1, /*!<   */
        MEDIA_VIDEO           =    0  /*!<   */
    }
    
    /**  VIDEO_DEVICE_CAPABILITY
     */
    public enum VIDEO_DEVICE_CAPABILITY
    {
        VIDEOCAP_HQ_CAPABLE         =    0, /*!<   */
        VIDEOCAP_HQ_CERTIFIED       =    1, /*!<   */
        VIDEOCAP_REQ_DRIVERUPDATE   =    2, /*!<   */
        VIDEOCAP_USB_HIGHSPEED      =    3  /*!<   */
    }
    
    /* SktVideo class methods */
    
    /**  This method starts either video send or video receive, depending on whether the video object is sender
      or receiver. In case of desktop video, the receiver side needs to instantiate a renderer object and associate
      it with the receiveing video Skt(Video.SetRemoteRendererId).
     */
    public void Start ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.Start");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVideo.Start");
    }
    
    /**  This method stops either video send or video receive, depending on whether the video object is sender
      or receiver. In case of desktop video, the receiver side needs to dis-associate the video object from
      the renderer, by calling SktVideo.SetRemoteRendererId(0).
     */
    public void Stop ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.Stop");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVideo.Stop");
    }
    
    /**  This method has no known effect in current version.
        @param [in] x0
        @param [in] y0
        @param [in] width
        @param [in] height
        @param [in] monitorNumber Default value is 0
        @param [in] windowHandle Default value is 0
     */
    public void SetScreenCaptureRectangle (
        int   x0,
        int   y0,
        uint  width,
        uint  height,
        int   monitorNumber,
        uint  windowHandle)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.SetScreenCaptureRectangle");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.encoder.AddIntParam(1, x0);
        skypeRef.encoder.AddIntParam(2, y0);
        skypeRef.encoder.AddUintParam(3, width);
        skypeRef.encoder.AddUintParam(4, height);
        skypeRef.encoder.AddIntParam(5, monitorNumber);
        skypeRef.encoder.AddUintParam(6, windowHandle);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVideo.SetScreenCaptureRectangle");
    }
    
    /**  This method is specific to working with desktop video runtimes. In case of desktop video, this method
      associates a Video object with a rendering object. Once this association is in place, the Video object
      will start sending decoded video frames to the renderer object, over shared memory IPC transport. The
      renderer then periodically reads the shared memory buffer and draws bitmaps on the screen. The "remote
      renderer ID" value you are expected to pass in this method comes from the renderer. The renderer class is normally implemented by you (for a specific GUI framework). However, the shared memory transport
      mechanism, for receiving decoded frames, is independant of GUI framework and are provided with the SDK
      for all three supporeted operating systems. Your renderer class can include instance of the IPC transport
      as VideoTransportClient <WinShm> ipc or VideoTransportClient <PosixShm> ipc; The ipc object then exposes ipc.key() function that returns the
      IPC channel ID. This ID can then be passed to the SktVideo.SetRemoteRendererId method. A reference implementation
      of desktop video is included in the SDK (examples/cpp/qt_videocalls). When the incoming video stream
      stops (or rendering is stopped by the user), your client should explicitly stop the frame transport by calling SktVideo.SetRemoteRendererId(0).
        @param [in] id - IPC channel ID retrieved from the shared memory transport class (see ipc/cpp/VideoBuffers in the SDK).
     
     */
    public void SetRemoteRendererId (uint id)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.SetRemoteRendererId");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 14, OID);
        skypeRef.encoder.AddUintParam(1, id);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVideo.SetRemoteRendererId");
    }
    
    /**  Switches between local webcams. This only works for video objects representing the local user. It is
      possible to switch to a different webcam on the fly, during a live session, i.e. you don't need to call
      SktVideo.Stop and SktVideo.Start while doing it. The easiest way to retrieve the local user is to call
      current live session's GetParticipants with PARTICIPANTFILTER.MYSELF. To get values for the deviceName
      and devicePath arguments, use SktSkype.GetAvailableVideoDevices method. Note that the SktSkype.GetAvailableVideoDevices
      should not be used immedately after account login. It will take several seconds to populate the video
      device list. You should handle the SktSkype.OnSkypeAvailableVideoDeviceListChange event to detect when
      the video device list is ready. Note that the device switching will only work with webcams that are not
      already in use by some other application. For example, if you have a Skype desktop client with video running in parallel, while testing,
      the desktop client will "claim" its default webcam. That webcam will still show up in the video device
      list in SkypeKit-based app, but switching to it will not work.
        @param [in] mediaType - Screensharing or webcam.
        @param [in] webcamName - Displayname of the webcam. Default value is ""
        @param [in] devicePath - Device ID (from the 2nd list you get back from the SktSkype.GetAvailableVideoDevices method) Default value is ""
        @param [in] updateSetup - Set true if you want to change the default value. Default value is false
     */
    public void SelectVideoSource (
        SktVideo.MEDIATYPE mediaType,
        String             webcamName,
        String             devicePath,
        Boolean            updateSetup)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.SelectVideoSource");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)mediaType);
        skypeRef.encoder.AddStringParam(2, webcamName);
        skypeRef.encoder.AddStringParam(3, devicePath);
        skypeRef.encoder.AddBoolParam(4, updateSetup);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVideo.SelectVideoSource");
    }
    
    /** 
        @param [out] mediatype
        @param [out] deviceName
        @param [out] devicePath
     */
    public void GetCurrentVideoDevice (
        out SktVideo.MEDIATYPE mediatype,
        out String deviceName,
        out String devicePath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Video.GetCurrentVideoDevice");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2}, {3, 3} };
        object[] args = new object[3];
        args[0] = 0;
        args[1] = "";
        args[2] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(3, ref args, new uint[3]{0,0,0}, ref tagMap, "SktVideo.GetCurrentVideoDevice");
        mediatype = (SktVideo.MEDIATYPE)args[0];
        deviceName = (String)args[1];
        devicePath = (String)args[2];
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Video - the wrapper has no events for this class.");
    }
}

/*! \class SktMessage
  \brief
  Events in a conversation context are expressed as Messages. It is therefore useful to think of Message
  objects as events, rather than specifically text chat messages. @brief Message member functions all return a Boolean indicating the success (true) or failure (false) of processing
  the request itself (transport, runtime availability, and so forth) - not the success or failure of its
  associated functionality. For example, SktMessage.Edit returns true if it was able to make a determination,
  and its result parameter reflects whether this Message can be edited. Similarly, SktMessage.Edit returns
  false if it was unable to make a determination, and the value of its result parameter is undefined. Message member functions that are specific to a Message TYPE return false if this Message is not of that
  type. For example, SktMessage.GetVoiceMessage will return false if this Message's type is not POSTED_VOICE_MESSAGE.
  The actual meaning of a Message can be determined by its P_TYPE property. The meanings of most other
  Message properties depend on the value of P_TYPE. For example, let's take P_BODY_XML property. Following messages have a text entered by the user as a body. It may contain emoticons, URLs, etc. 
  @li
  POSTED_TEXT 
  @li POSTED_EMOTE 
  @li SET_METADATA 
  @li REQUESTED_AUTH Following messages have a custom XML format for the body (see the specific section on these message types
  for details): 
  @li POSTED_CONTACTS 
  @li POSTED_VOICE_MESSAGE 
  @li POSTED_FILES 
  @li POSTED_SMS 
  @li STARTED_LIVESESSION
  and ENDED_LIVESESSION (same format) Following messages do not use the body property: 
  @li SPAWNED_CONFERENCE 
  @li ADDED_CONSUMERS 
  @li ADDED_APPLICANTS
  
  @li RETIRED_OTHERS 
  @li RETIRED 
  @li SET_RANK 
  @li HAS_BIRTHDAY 
  @li GRANTED_AUTH 
  @li BLOCKED Messages such as POSTED_TEXT use a small subset of a HTML-like markup to control the visual representation
  of the text. This markup is used by POSTED_TEXT and POSTED_EMOTE, but also for the conversation topic
  (CONVERSATION_META_TOPIC property and the body of the SET_METADATA message) and for authorization requests.
  Having chat messages in XML format means that all formatting is indicated by XML tags. This includes
  emoticons and URls. The big advantage is that it makes the parsing of the message by the UI much easier.
  The UI does not need to do emoticons or URL detection, this is already done and it only needs to look
  for the XML tags. For text messages, it is possible for the UI to simply ignore (meaning strip) the XML and the message
  will be understandable fine, it will only have lost some formatting. But it is obviously nicer to display at least the most commonly used tags. To strip the XML: 
  @li if they have the alt="sometext" attribute set, return sometext as the output of
  that tag and ignore the rest of tag and all nested sub tags 
  @li if no alt="" attribute set, use tag content
  as output - <sometag>hereissomething</sometag> is output as hereissomething
  @li if no alt="" and no tag
  content, ignore the tag altogether (return nothing) Skype for Windows supports displaying many XML tags, but only a sub-set is regularly used and should
  be supported by the UI for a good experience. These are the ones described here. Animated emoticons Emoticons are encoded with the "ss" tag. The element content is the plain text representation. It has
  a "type" attribute indicating the emoticons canonical name. Example: @code Hi <ss type="smile">:-)</ss> @endcode Flag emoticons Flag emoticons are little flags. They are encoded with the "flag" tag. The element contents is the plain
  text representation and it has a "country" attribute which is a 2-letter ISO-3166 country code. The user
  can enter a flag using "(flag:XX)", where XX is a valid ISO country code. Example: @code I am in <flag country="cc">CC</flag> @endcode Links If the library detects a URL, it will encode it using the html "a" tag, with the "href" attribute indicating
  the URL. The plain text representation is what the user originally typed. Example: @code I am in <a href="http://wwww.skype.com">www.skype.com</a> @endcode Alert matches When a conversation is configured to display only alerts if specific words are present in the message
  (see "/alertson [text to match]" command), if a message matches the alert, it will be marked with the
  <alertmatch> tag. This allows the UI to highlight the word matching. Example: @code Maybe <alertmatch>Vincent</alertmatch> knows the answer @endcode Bold, italic, etc Skype for Windows also supports displaying bold and italic text, using the "b" and "i" tags. Encoding messages When sending a chat message via PostText(), there is the possibility to indicate if the library should
  do the XML encoding, or if the message has already been encoded. Usually, the UI can let library do the
  encoding. This is the case when the message does not contain any specific formatting. It may contain
  emoticons or URls, which will be detected by the library encoder and converted into XML tags. If the message has some more complex encoding, such as a quote or some bold text, it is up to the UI
  to encode the message.
 */
public class SktMessage : SktObject
{
    public override String ClassName { get { return "Message"; } }
    
    public override uint ClassId { get { return 9; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktMessage (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(19);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktMessage objects.
     */
    public class List : SktObjectList
    {
        new public SktMessage this[int index]
        {
            get { return (SktMessage)base[index]; }
        }

        public void Add(SktMessage item)
        {
            base.Add((SktMessage)item);
        }
    }
    

    /* SktMessage property cache fields */
    private volatile SktConversation               cache_convo_id;
    private volatile String                        cache_convo_guid;
    private volatile String                        cache_author;
    private volatile String                        cache_author_displayname;
    private volatile byte[]                        cache_guid;
    private volatile String                        cache_originally_meant_for;
    private volatile uint                          cache_timestamp;
    private volatile SktMessage.TYPE               cache_type;
    private volatile SktMessage.SENDING_STATUS     cache_sending_status;
    private volatile SktMessage.CONSUMPTION_STATUS cache_consumption_status;
    private volatile String                        cache_edited_by;
    private volatile uint                          cache_edit_timestamp;
    private volatile uint                          cache_param_key;
    private volatile uint                          cache_param_value;
    private volatile String                        cache_body_xml;
    private volatile String                        cache_identities;
    private volatile String                        cache_reason;
    private volatile SktSkype.LEAVE_REASON         cache_leavereason;
    private volatile uint                          cache_participant_count;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 960: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 960: /* Message.P_CONVO_ID */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_id = (SktConversation)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_CONVO_ID = " + cache_convo_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_CONVO_ID - update without value");
                skypeRef.events.FireOnMessageConvoId(this, cache_convo_id);
                break;
                
            case 120: /* Message.P_CONVO_GUID */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_guid = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_CONVO_GUID = " + cache_convo_guid.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_CONVO_GUID - update without value");
                skypeRef.events.FireOnMessageConvoGuid(this, cache_convo_guid);
                break;
                
            case 122: /* Message.P_AUTHOR */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_author = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_AUTHOR = " + cache_author.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_AUTHOR - update without value");
                skypeRef.events.FireOnMessageAuthor(this, cache_author);
                break;
                
            case 123: /* Message.P_AUTHOR_DISPLAYNAME */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_author_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_AUTHOR_DISPLAYNAME = " + cache_author_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_AUTHOR_DISPLAYNAME - update without value");
                skypeRef.events.FireOnMessageAuthorDisplayname(this, cache_author_displayname);
                break;
                
            case 792: /* Message.P_GUID */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_guid = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_GUID = binary size " + cache_guid.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_GUID - update without value");
                skypeRef.events.FireOnMessageGuid(this, cache_guid);
                break;
                
            case 790: /* Message.P_ORIGINALLY_MEANT_FOR */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_originally_meant_for = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_ORIGINALLY_MEANT_FOR = " + cache_originally_meant_for.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_ORIGINALLY_MEANT_FOR - update without value");
                skypeRef.events.FireOnMessageOriginallyMeantFor(this, cache_originally_meant_for);
                break;
                
            case 121: /* Message.P_TIMESTAMP */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_TIMESTAMP = " + cache_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_TIMESTAMP - update without value");
                skypeRef.events.FireOnMessageTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_timestamp));
                break;
                
            case 961: /* Message.P_TYPE */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktMessage.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_TYPE - update without value");
                skypeRef.events.FireOnMessageType(this, cache_type);
                break;
                
            case 962: /* Message.P_SENDING_STATUS */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_sending_status = (SktMessage.SENDING_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_SENDING_STATUS = " + cache_sending_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_SENDING_STATUS - update without value");
                skypeRef.events.FireOnMessageSendingStatus(this, cache_sending_status);
                break;
                
            case 968: /* Message.P_CONSUMPTION_STATUS */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_consumption_status = (SktMessage.CONSUMPTION_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_CONSUMPTION_STATUS = " + cache_consumption_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_CONSUMPTION_STATUS - update without value");
                skypeRef.events.FireOnMessageConsumptionStatus(this, cache_consumption_status);
                break;
                
            case 222: /* Message.P_EDITED_BY */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_edited_by = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_EDITED_BY = " + cache_edited_by.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_EDITED_BY - update without value");
                skypeRef.events.FireOnMessageEditedBy(this, cache_edited_by);
                break;
                
            case 223: /* Message.P_EDIT_TIMESTAMP */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_edit_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_EDIT_TIMESTAMP = " + cache_edit_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_EDIT_TIMESTAMP - update without value");
                skypeRef.events.FireOnMessageEditTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_edit_timestamp));
                break;
                
            case 963: /* Message.P_PARAM_KEY */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_param_key = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_PARAM_KEY = " + cache_param_key.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_PARAM_KEY - update without value");
                skypeRef.events.FireOnMessageParamKey(this, cache_param_key);
                break;
                
            case 964: /* Message.P_PARAM_VALUE */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_param_value = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_PARAM_VALUE = " + cache_param_value.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_PARAM_VALUE - update without value");
                skypeRef.events.FireOnMessageParamValue(this, cache_param_value);
                break;
                
            case 127: /* Message.P_BODY_XML */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_body_xml = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_BODY_XML = " + cache_body_xml.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_BODY_XML - update without value");
                skypeRef.events.FireOnMessageBodyXml(this, cache_body_xml);
                break;
                
            case 125: /* Message.P_IDENTITIES */
                cache[15] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_identities = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_IDENTITIES = " + cache_identities.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_IDENTITIES - update without value");
                skypeRef.events.FireOnMessageIdentities(this, cache_identities);
                break;
                
            case 966: /* Message.P_REASON */
                cache[16] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_reason = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_REASON = " + cache_reason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_REASON - update without value");
                skypeRef.events.FireOnMessageReason(this, cache_reason);
                break;
                
            case 126: /* Message.P_LEAVEREASON */
                cache[17] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_leavereason = (SktSkype.LEAVE_REASON)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_LEAVEREASON = " + cache_leavereason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_LEAVEREASON - update without value");
                skypeRef.events.FireOnMessageLeavereason(this, cache_leavereason);
                break;
                
            case 982: /* Message.P_PARTICIPANT_COUNT */
                cache[18] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_participant_count = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Message.P_PARTICIPANT_COUNT = " + cache_participant_count.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Message.P_PARTICIPANT_COUNT - update without value");
                skypeRef.events.FireOnMessageParticipantCount(this, cache_participant_count);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Message class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktMessage property accessors **/
    
    /**  DB ID of corresponding conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageConvoId(SktMessage sender, SktEvents.OnMessageConvoIdArgs e)</b></tt>
     */
    public SktConversation P_CONVO_ID
    {
        get { if (!cache[0]) FetchConvoIdFromRuntime(); return cache_convo_id; }
    }
    
    internal void FetchConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 960, this.OID);
        if (skypeRef.transport.PropResponseWasOk(960))
        {
            cache_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  GUID of the Conversation. The GUID is a "global ID" - these values are shared accross Skype client instances
      and accross all the participants of the conversation.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageConvoGuid</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageConvoGuid(SktMessage sender, SktEvents.OnMessageConvoGuidArgs e)</b></tt>
     */
    public String P_CONVO_GUID
    {
        get { if (!cache[1]) FetchConvoGuidFromRuntime(); return cache_convo_guid; }
    }
    
    internal void FetchConvoGuidFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_GUID from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 120, this.OID);
        if (skypeRef.transport.PropResponseWasOk(120))
        {
            cache_convo_guid = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Identity of the sender. While this is almost always the same as SKYPENAME property of the Contact, in
      some rare cases it can also be a phone number - for example, incoming voicemail notification Messages
      (message type = POSTED_VOICE_MESSAGE).
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageAuthor</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageAuthor(SktMessage sender, SktEvents.OnMessageAuthorArgs e)</b></tt>
     */
    public String P_AUTHOR
    {
        get { if (!cache[2]) FetchAuthorFromRuntime(); return cache_author; }
    }
    
    internal void FetchAuthorFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AUTHOR from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 122, this.OID);
        if (skypeRef.transport.PropResponseWasOk(122))
        {
            cache_author = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  displayname of the sender at the time of posting
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageAuthorDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageAuthorDisplayname(SktMessage sender, SktEvents.OnMessageAuthorDisplaynameArgs e)</b></tt>
     */
    public String P_AUTHOR_DISPLAYNAME
    {
        get { if (!cache[3]) FetchAuthorDisplaynameFromRuntime(); return cache_author_displayname; }
    }
    
    internal void FetchAuthorDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AUTHOR_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 123, this.OID);
        if (skypeRef.transport.PropResponseWasOk(123))
        {
            cache_author_displayname = skypeRef.decoder.DecodeString();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Unlike the message id, the GUID is the same on all instances and for all participants.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageGuid</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageGuid(SktMessage sender, SktEvents.OnMessageGuidArgs e)</b></tt>
     */
    public byte[] P_GUID
    {
        get { if (!cache[4]) FetchGuidFromRuntime(); return cache_guid; }
    }
    
    internal void FetchGuidFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GUID from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 792, this.OID);
        if (skypeRef.transport.PropResponseWasOk(792))
        {
            cache_guid = skypeRef.decoder.DecodeBinary();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This property gets set when a conference is spawned from dialog Conversation. In that case recent message
      history from the original dialog is copied to the target conversation. For all the copied messages, the
      ORIGINALLY_MEANT_FOR property will be set to identity of the remote participant of the original dialog.
     
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageOriginallyMeantFor</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageOriginallyMeantFor(SktMessage sender, SktEvents.OnMessageOriginallyMeantForArgs e)</b></tt>
     */
    public String P_ORIGINALLY_MEANT_FOR
    {
        get { if (!cache[5]) FetchOriginallyMeantForFromRuntime(); return cache_originally_meant_for; }
    }
    
    internal void FetchOriginallyMeantForFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ORIGINALLY_MEANT_FOR from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 790, this.OID);
        if (skypeRef.transport.PropResponseWasOk(790))
        {
            cache_originally_meant_for = skypeRef.decoder.DecodeString();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp (sent time, adjusted for local clock)
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageTimestamp(SktMessage sender, SktEvents.OnMessageTimestampArgs e)</b></tt>
     */
    public DateTime P_TIMESTAMP
    {
        get { if (!cache[6]) FetchTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_timestamp); }
    }
    
    internal void FetchTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 121, this.OID);
        if (skypeRef.transport.PropResponseWasOk(121))
        {
            cache_timestamp = skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktMessage.TYPE for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageType(SktMessage sender, SktEvents.OnMessageTypeArgs e)</b></tt>
     */
    public SktMessage.TYPE P_TYPE
    {
        get { if (!cache[7]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 961, this.OID);
        if (skypeRef.transport.PropResponseWasOk(961))
        {
            cache_type = (SktMessage.TYPE)skypeRef.decoder.DecodeUint();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktMessage.SENDING_STATUS for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageSendingStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageSendingStatus(SktMessage sender, SktEvents.OnMessageSendingStatusArgs e)</b></tt>
     */
    public SktMessage.SENDING_STATUS P_SENDING_STATUS
    {
        get { if (!cache[8]) FetchSendingStatusFromRuntime(); return cache_sending_status; }
    }
    
    internal void FetchSendingStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SENDING_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 962, this.OID);
        if (skypeRef.transport.PropResponseWasOk(962))
        {
            cache_sending_status = (SktMessage.SENDING_STATUS)skypeRef.decoder.DecodeUint();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktMessage.CONSUMPTION_STATUS for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageConsumptionStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageConsumptionStatus(SktMessage sender, SktEvents.OnMessageConsumptionStatusArgs e)</b></tt>
     */
    public SktMessage.CONSUMPTION_STATUS P_CONSUMPTION_STATUS
    {
        get { if (!cache[9]) FetchConsumptionStatusFromRuntime(); return cache_consumption_status; }
    }
    
    internal void FetchConsumptionStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONSUMPTION_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 968, this.OID);
        if (skypeRef.transport.PropResponseWasOk(968))
        {
            cache_consumption_status = (SktMessage.CONSUMPTION_STATUS)skypeRef.decoder.DecodeUint();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Identity of the author that last edited this message. NULL if message has not been edited
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageEditedBy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageEditedBy(SktMessage sender, SktEvents.OnMessageEditedByArgs e)</b></tt>
     */
    public String P_EDITED_BY
    {
        get { if (!cache[10]) FetchEditedByFromRuntime(); return cache_edited_by; }
    }
    
    internal void FetchEditedByFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_EDITED_BY from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 222, this.OID);
        if (skypeRef.transport.PropResponseWasOk(222))
        {
            cache_edited_by = skypeRef.decoder.DecodeString();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of last edit
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageEditTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageEditTimestamp(SktMessage sender, SktEvents.OnMessageEditTimestampArgs e)</b></tt>
     */
    public DateTime P_EDIT_TIMESTAMP
    {
        get { if (!cache[11]) FetchEditTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_edit_timestamp); }
    }
    
    internal void FetchEditTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_EDIT_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 223, this.OID);
        if (skypeRef.transport.PropResponseWasOk(223))
        {
            cache_edit_timestamp = skypeRef.decoder.DecodeUint();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Message type-specific parameter. See SktMessage.SET_METADATA_KEY for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageParamKey</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageParamKey(SktMessage sender, SktEvents.OnMessageParamKeyArgs e)</b></tt>
     */
    public uint P_PARAM_KEY
    {
        get { if (!cache[12]) FetchParamKeyFromRuntime(); return cache_param_key; }
    }
    
    internal void FetchParamKeyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARAM_KEY from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 963, this.OID);
        if (skypeRef.transport.PropResponseWasOk(963))
        {
            cache_param_key = skypeRef.decoder.DecodeUint();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Message type-specific parameter
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageParamValue</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageParamValue(SktMessage sender, SktEvents.OnMessageParamValueArgs e)</b></tt>
     */
    public uint P_PARAM_VALUE
    {
        get { if (!cache[13]) FetchParamValueFromRuntime(); return cache_param_value; }
    }
    
    internal void FetchParamValueFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARAM_VALUE from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 964, this.OID);
        if (skypeRef.transport.PropResponseWasOk(964))
        {
            cache_param_value = skypeRef.decoder.DecodeUint();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Message type-specific parameter
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageBodyXml</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageBodyXml(SktMessage sender, SktEvents.OnMessageBodyXmlArgs e)</b></tt>
     */
    public String P_BODY_XML
    {
        get { if (!cache[14]) FetchBodyXmlFromRuntime(); return cache_body_xml; }
    }
    
    internal void FetchBodyXmlFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BODY_XML from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 127, this.OID);
        if (skypeRef.transport.PropResponseWasOk(127))
        {
            cache_body_xml = skypeRef.decoder.DecodeXML();
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Message type-specific parameter. Depending of Message type, this property contains: @li STARTED_LIVESESSION
      - list of participants in the cal; @li ENDED_LIVESESSION - list of participants in the call; @li POSTED_SMS
      - list of recipients of the message; @li SPAWNED_CONFERENCE - the list of identities that were added;
      @li ADDED_CONSUMERS - the list of identities that were added; @li RETIRED_OTHERS - the skypename of the
      participant who was kicked; @li SET_RANK - the skypename of the participant whose rank was changed; @li
      REQUESTED_AUTH - SktMessage.P_AUTHOR and SktMessage.P_IDENTITIES are set to the users receiving and requesting
      the authorization, depending if the message was received or sent; @li GRANTED_AUTH - the skypename of
      the user we granted authorization; @li BLOCKED - the skypename of the user who was blocked; @li HAS_BIRTHDAY
      - skypename of current logged in user.
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageIdentities</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageIdentities(SktMessage sender, SktEvents.OnMessageIdentitiesArgs e)</b></tt>
     */
    public String P_IDENTITIES
    {
        get { if (!cache[15]) FetchIdentitiesFromRuntime(); return cache_identities; }
    }
    
    internal void FetchIdentitiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IDENTITIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 125, this.OID);
        if (skypeRef.transport.PropResponseWasOk(125))
        {
            cache_identities = skypeRef.decoder.DecodeString();
            cache[15] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Message type-specific parameter. Possible values for STARTED/ENDED_LIVESESSION (only set for dialogs):
      @li no_answer @li manual @li busy @li connection_dropped @li no_skypeout_subscription; @li insufficient_funds
      @li internet_connection_lost @li skypeout_account_blocked @li pstn_could_not_connect_to_skype_proxy @li
      pstn_invalid_number @li pstn_number_forbidden @li pstn_call_timed_out @li pstn_busy @li pstn_call_terminated
      @li pstn_network_error @li number_unavailable @li pstn_call_rejected @li pstn_misc_error @li internal_error
      @li unable_to_connect @li connection_dropped @li recording_failed @li playback_error @li legacy_error
      @li blocked_by_privacy_settings @li error @li transfer_failed @li transfer_insufficient_funds @li blocked_by_us
      @li emergency_call_denied This information is now available as an enum in LEAVEREASON
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageReason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageReason(SktMessage sender, SktEvents.OnMessageReasonArgs e)</b></tt>
     */
    public String P_REASON
    {
        get { if (!cache[16]) FetchReasonFromRuntime(); return cache_reason; }
    }
    
    internal void FetchReasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_REASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 966, this.OID);
        if (skypeRef.transport.PropResponseWasOk(966))
        {
            cache_reason = skypeRef.decoder.DecodeString();
            cache[16] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Leave reason for message of the RETIRED type, and STARTED/ENDED_LIVESESSION. Use for STARTED/ENDED_LIVESESSION
      is to provide simpler, enum based handling and deprecates the reason property (only set for dialogs)
     
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageLeavereason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageLeavereason(SktMessage sender, SktEvents.OnMessageLeavereasonArgs e)</b></tt>
     */
    public SktSkype.LEAVE_REASON P_LEAVEREASON
    {
        get { if (!cache[17]) FetchLeavereasonFromRuntime(); return cache_leavereason; }
    }
    
    internal void FetchLeavereasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LEAVEREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 126, this.OID);
        if (skypeRef.transport.PropResponseWasOk(126))
        {
            cache_leavereason = (SktSkype.LEAVE_REASON)skypeRef.decoder.DecodeUint();
            cache[17] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Number of people who received this message (including local user)
     @n Assign your own event handler method to the <tt><b>skype.events.OnMessageParticipantCount</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnMessageParticipantCount(SktMessage sender, SktEvents.OnMessageParticipantCountArgs e)</b></tt>
     */
    public uint P_PARTICIPANT_COUNT
    {
        get { if (!cache[18]) FetchParticipantCountFromRuntime(); return cache_participant_count; }
    }
    
    internal void FetchParticipantCountFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTICIPANT_COUNT from runtime");
        skypeRef.transport.SubmitPropertyRequest(9, 982, this.OID);
        if (skypeRef.transport.PropResponseWasOk(982))
        {
            cache_participant_count = skypeRef.decoder.DecodeUint();
            cache[18] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktMessage class PropKeys */
    
    public enum PropKeys 
    {
        P_CONVO_ID              =  960,
        P_CONVO_GUID            =  120,
        P_AUTHOR                =  122,
        P_AUTHOR_DISPLAYNAME    =  123,
        P_GUID                  =  792,
        P_ORIGINALLY_MEANT_FOR  =  790,
        P_TIMESTAMP             =  121,
        P_TYPE                  =  961,
        P_SENDING_STATUS        =  962,
        P_CONSUMPTION_STATUS    =  968,
        P_EDITED_BY             =  222,
        P_EDIT_TIMESTAMP        =  223,
        P_PARAM_KEY             =  963,
        P_PARAM_VALUE           =  964,
        P_BODY_XML              =  127,
        P_IDENTITIES            =  125,
        P_REASON                =  966,
        P_LEAVEREASON           =  126,
        P_PARTICIPANT_COUNT     =  982 
    }
    
    /* SktMessage class enums */
    
    /**  The P_TYPE property determines the actual meaning of the Message object. Only Messages of POSTED_TEXT
      type contain actual text messages. The meaning and content of the rest of the message properties are
      largely dependant of the value of the SktMessage.P_TYPE.
     */
    public enum TYPE
    {
        SET_METADATA           =    2, /*!< Conference metadata were changed */
        SPAWNED_CONFERENCE     =    4, /*!< A conference was spawned from this dialog */
        ADDED_CONSUMERS        =   10, /*!< Some users were added to the conference */
        ADDED_APPLICANTS       =   11, /*!< Some users are applying to be added to the conference */
        RETIRED_OTHERS         =   12, /*!< User was kicked from the conference */
        RETIRED                =   13, /*!< User left the conference */
        SET_RANK               =   21, /*!< Changed the rank of a user in the Conversation (multichat administration)   */
        STARTED_LIVESESSION    =   30, /*!< A live session started */
        ENDED_LIVESESSION      =   39, /*!< A live session ended */
        REQUESTED_AUTH         =   50, /*!< User requested authorization */
        GRANTED_AUTH           =   51, /*!< User was granted authorization. Notification message that user is now an authorized contact (of the local user).   */
        BLOCKED                =   53, /*!< User was blocked */
        POSTED_TEXT            =   61, /*!< A text message */
        POSTED_EMOTE           =   60, /*!< An emote ('John Doe is laughing', cf /me chat command) */
        POSTED_CONTACTS        =   63, /*!< The message represents (a set of) contact card(s) posted in the conversation. One message can contain more than one contact cards. The contacts can be retrieved from the message by parsing them out from the P_BODY_XML property. For more information, see Conversation::PostContacts   */
        POSTED_SMS             =   64, /*!< The message represents an SMS object that was posted in the Conversation. See Conversation::PostSMS for more details. The Sms object itself can be retrieved from the Message with Message::GetSms The message BODY_XML contains a set of SMS properties, such as status, failurereason, targets, price and timestamp.   */
        POSTED_ALERT           =   65, /*!< Deprecated, never sent */
        POSTED_VOICE_MESSAGE   =   67, /*!< A voicemail */
        POSTED_FILES           =   68, /*!< The message represents a (list of) file transfers that were posted in the Conversation with Conversation::PostFiles. Transfer objects can be retrieved from the Message with Message::GetTransfers   */
        POSTED_INVOICE         =   69, /*!< Currently unused.   */
        HAS_BIRTHDAY           =  110  /*!< The message represents a Contact birthday notification.   */
    }
    
    /**  SENDING_STATUS
     */
    public enum SENDING_STATUS
    {
        SENDING          =    1, /*!< Message has not been delivered to at least one of the participants   */
        SENT             =    2, /*!< Message has been delivered to at least one other participant   */
        FAILED_TO_SEND   =    3  /*!< Message could not be delivered (for SMS this reflects the actual SMS, not the chat message)   */
    }
    
    /**  Indicates if a message has been consumed (meaning read) or not
     */
    public enum CONSUMPTION_STATUS
    {
        CONSUMED                =    0, /*!< Message has been read. Note that this is a read-only property. Consumption status of individual messages can not be set selectively. Message consumption status is determined at the conversation level, based conversation consumption horizon and individual message timestamps. Conversation consumption horizon can be updated with Conversation::SetConsumedHorizon method.    */
        UNCONSUMED_SUPPRESSED   =    1, /*!< Do not notify the user that they have this unread message   */
        UNCONSUMED_NORMAL       =    2, /*!< Notify the user that they have this unread message   */
        UNCONSUMED_ELEVATED     =    3  /*!< This message consumption state is marked as DEPRECATED   */
    }
    
    /**  For messages of type SET_METADATA that alert participants to changes to the associated Conversation's
      metadata, indicates which metadata property changed and its P_BODY_XML property contains the changed
      data. Your UI is expected to detect messages with PARAM_KEY set and to update its visual representation
      of Conversation accordingly. You can use the associated Conversation's properties and methods to obtain the updated metadata rather
      than parse the message body XML, for example, SktConversation.P_META_PICTURE and SktConversation.Conversation.GetPropMetaPicture.
     
     */
    public enum SET_METADATA_KEY
    {
        SET_META_NAME         = 3640, /*!< Notification message that conversation name has changed.   */
        SET_META_TOPIC        = 3644, /*!< Notification message that conversation topic has changed.   */
        SET_META_GUIDELINES   = 3652, /*!< Notification message that conversation guidelines have changed.   */
        SET_META_PICTURE      = 3658  /*!< Notification message that conversation picture has changed.   */
    }
    
    /**  Indicates the reason a user could not join or left a Conversation. SkypeKit automatically sets "could
      not join"-related values. "Left voluntarily"-related values are set as a result of explicit user actions.
     
     */
    public enum LEAVEREASON
    {
        USER_INCAPABLE             =    2, /*!< User cannot chat (user is currently logged in with a client that has chat disabled - see Contact::CAPABILITY.CAPABILITY_TEXT)   */
        ADDER_MUST_BE_FRIEND       =    3, /*!< Attempt to add local user to a conversation by an unknown contact   */
        ADDER_MUST_BE_AUTHORIZED   =    4, /*!< Attempt to add local user to a conversation by an unauthorized contact   */
        DECLINE_ADD                =    5, /*!< Local user declined an "invitation" to join a chat   */
        UNSUBSCRIBE                =    6  /*!< User decided to end participation in an on-going multi-chat   */
    }
    
    /**  bitfield used to express what can be done with a message
     */
    public enum PERMISSIONS
    {
        PERM_NONE        =    0, /*!<   */
        PERM_EDITABLE    =    1, /*!< message can be edited with new content */
        PERM_DELETABLE   =    2  /*!< message can be deleted whole (edited to blank) */
    }
    
    /* SktMessage class methods */
    
    /**  For Message types having a body, determines whether that body is editable by the user.
        @returns result
     */
    public Boolean CanEdit ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.CanEdit");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktMessage.CanEdit");
        return (Boolean)args[0];
    }
    
    /**  get all permissions allowed on this message
        @returns result
     */
    public SktMessage.PERMISSIONS GetPermissions ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.GetPermissions");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 58, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktMessage.GetPermissions");
        return (SktMessage.PERMISSIONS)args[0];
    }
    
    /**  For Message types that include a body and are editable: @li alters BODY_XML of the message object @li
      sets EDITED_BY and EDIT_TIMESTAMP properties @li propagates the changes to remote users.
        @param [in] newText - New value of the message BODY_XML property.
        @param [in] isXML - Specify isXML as true if the message body is formatted as XML; omit it or specify it as false if the
      message body is plain text. Default value is false
        @param [in] undo - Reverts the message body to the original version. newText argument is ignored when this is set. Default value is false
        @param [in] legacyPrefix - If the edit is received by a client not supporting displaying edits, it will be shown as a new message,
      prefixed by this parameter. Default value is a prefix in English. Default value is ""
     */
    public void Edit (
        String  newText,
        Boolean isXML,
        Boolean undo,
        String  legacyPrefix)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.Edit");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.encoder.AddStringParam(1, newText);
        skypeRef.encoder.AddBoolParam(2, isXML);
        skypeRef.encoder.AddBoolParam(3, undo);
        skypeRef.encoder.AddStringParam(4, legacyPrefix);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktMessage.Edit");
    }
    
    /**  For messages of type POSTED_CONTACTS, parses the body XML and formats the data as a list of Contact instances.
     
        @returns contacts
     */
    public SktContact.List GetContacts ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.GetContacts");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        SktContact.List contacts = new SktContact.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktMessage.GetContacts failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        contacts = (SktContact.List)skypeRef.decoder.DecodeObjectList(2);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktMessage.GetContacts", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return contacts;
    } // SktMessage.GetContacts
    
    /**  For messages of type POSTED_FILES, parses the body XML and creates a list of Transfer instances.
        @returns transfers
     */
    public SktTransfer.List GetTransfers ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.GetTransfers");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        SktTransfer.List transfers = new SktTransfer.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktMessage.GetTransfers failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        transfers = (SktTransfer.List)skypeRef.decoder.DecodeObjectList(6);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktMessage.GetTransfers", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return transfers;
    } // SktMessage.GetTransfers
    
    /**  For messages of type POSTED_VOICE_MESSAGE, parses the body XML and creates a Voicemail instance.
        @returns voicemail
     */
    public SktVoicemail GetVoiceMessage ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.GetVoiceMessage");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{7}, ref tagMap, "SktMessage.GetVoiceMessage");
        return (SktVoicemail)args[0];
    }
    
    /**  For messages of type POSTED_SMS, parses the body XML and creates an SMS instances
        @returns sms
     */
    public SktSms GetSMS ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.GetSMS");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{12}, ref tagMap, "SktMessage.GetSMS");
        return (SktSms)args[0];
    }
    
    /**  Deletes this message from the local database. These deletions do not propagate to the other Skype instances
      that the user may have on other computers. Nor do they affect other participants that have the same message.
      This method is specifically from removing Message objects from the database - not for removing Messages
      from conversations. To remove a Message from a conversation, use SktMessage.Edit method to replace the
      existing body text with an empty string.
     */
    public void DeleteLocally ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Message.DeleteLocally");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktMessage.DeleteLocally");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Message - the wrapper has no events for this class.");
    }
}

/*! \class SktVoicemail
  \brief
  Wrapper class that includes voicemail-specific methods and properties. @brief In the Skype Conversation
  API, Voicemail is actually something of a misnomer for what would be more accurately called Voice Message.
  The traditional Voicemail use case involves recording a voice message when an incoming call does not
  get answered in a pre-determined amount of time. In the Skype Conversation API, voicemail does not depend
  on a call going unanswered - you can post a voice message asynchronously into any dialog conversation
  at any time. In fact, a high-level action flow directing unanswered incoming live sessions to voicemail is not something
  provided by the Conversation API - implementation of this use case is largely up to your UI. The fact that your UI must retrieve incoming Voicemails by monitoring changes to a Conversation instance's
  Messages illustrates this conceptual difference between traditional voicemail and voice messages. The
  message type SktMessage.POSTED_VOICE_MESSAGE indicates that a Message instance should be handled as a
  voice message instead of by displaying its body text in the Conversation UI. SktMessage.GetVoiceMessage
  enables you to retrieve the associated Voicemail instance; SktVoicemail.StartPlayback enables you to
  listen to the message audio. To put it another way, the object chain goes like this: @code Contact->Conversation->Message->Voicemail @endcode There are three basic types of Voicemail objects: 
  @li INCOMING - received voice messages that can be
  retrieved from Message objects; 
  @li OUTGOING - outbound voice messages that can be created with SktConversation.StartVoiceMessage;
  
  @li GREETING - voice messages that represent auto-answer greetings, either recorded by the user (CUSTOM_GREETING)
  or included as part of SkypeKit (DEFAULT_GREETING). This is the audio that gets played back to sender
  of the voice message before he can start recording his voice message. Before trying to send out a voicemail, you should ensure that target Contact has the capability to receive
  them. Use SktContact.GetCapabilityStatus to check for SktContact.CAPABILITY_CAN_BE_SENT_VM. Recording and Sending a Voice Message The first step is to obtain a dialog Conversation with the target Contact. In that conversation, you
  can initiate the outgoing voice message with SktConversation.StartVoiceMessage Note that this call does not return an actual Voicemail object. To catch when an object gets created,
  you will need to check SktConversation.P_ACTIVE_VM_ID property updates. After invoking SktConversation.StartVoiceMessage, SkypeKit instantiates a Voicemail instance for the
  target Contact's greeting (with type CUSTOM_GREETING or DEFAULT_GREETING). At this point, the SktConversation.P_ACTIVE_VM_ID
  property update fires, newVM contains a reference to the greeting, and playback of the greeting for the
  sender starts automatically. Once the greeting playback finishes, SkypeKit instantiates a second Voicemail instance for the outgoing
  voice message. At this point, the SktConversation.P_ACTIVE_VM_ID property update fires again, newVM now
  contains a reference to the outgoing message, and recording starts automatically. If you want to include
  notification and/or error handling for whether this message was sent successfully, you should make a
  copy of newVM now. Once the user finishes (or abandons) recording of their message, they want to either send the message
  or to cancel it. To send the message, use SktConversation.PostVoiceMessage; to cancel the message, use
  SktConversation.LeaveLiveSession. Both of these actions results in the SktConversation.P_ACTIVE_VM_ID property update firing for a third
  time, setting the value to NULL. However, the Voicemail object will actually continue its existence past
  this point. Saving a reference to the message's Voicemail object when you start recording it enables
  you to keep receiving Voicemail property updates. This in turn enables your UI to check whether voice
  message send succeeded or failed. The relevant terminal state SktVoicemail.P_STATUS property values are: 
  @li SktVoicemail.CANCELLED - recording
  and/or sending of this message was cancelled 
  @li SktVoicemail.UPLOADED - message sent 
  @li SktVoicemail.FAILED
  - message could not be sent Receiving and Playing Back a Voice Message On the remote side, the Voicemail appears as a Message object of type SktMessage.POSTED_VOICE_MESSAGE.
  The message's author property contains the Skype Name of the Voicemail originator, and its BodyXml property
  contains the message length and title text in following format: @code <voicemail alt="Sent voicemail to people in this conversation."><message length="5" ></message></voicemail>
  @endcode Receiver side UI can then retrieve the Voicemail object from the message with SktMessage.GetVoiceMessage
  and start local playback with SktMessage.StartPlayback.
 */
public class SktVoicemail : SktObject
{
    public override String ClassName { get { return "Voicemail"; } }
    
    public override uint ClassId { get { return 7; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktVoicemail (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(12);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktVoicemail objects.
     */
    public class List : SktObjectList
    {
        new public SktVoicemail this[int index]
        {
            get { return (SktVoicemail)base[index]; }
        }

        public void Add(SktVoicemail item)
        {
            base.Add((SktVoicemail)item);
        }
    }
    

    /* SktVoicemail property cache fields */
    private volatile SktVoicemail.TYPE          cache_type;
    private volatile String                     cache_partner_handle;
    private volatile String                     cache_partner_dispname;
    private volatile SktVoicemail.STATUS        cache_status;
    private volatile SktVoicemail.FAILUREREASON cache_failurereason;
    private volatile String                     cache_subject;
    private volatile uint                       cache_timestamp;
    private volatile uint                       cache_duration;
    private volatile uint                       cache_allowed_duration;
    private volatile uint                       cache_playback_progress;
    private volatile SktConversation            cache_convo_id;
    private volatile byte[]                     cache_chatmsg_guid;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 830: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 100: /* Voicemail.P_TYPE */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktVoicemail.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_TYPE - update without value");
                skypeRef.events.FireOnVoicemailType(this, cache_type);
                break;
                
            case 101: /* Voicemail.P_PARTNER_HANDLE */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_partner_handle = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_PARTNER_HANDLE = " + cache_partner_handle.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_PARTNER_HANDLE - update without value");
                skypeRef.events.FireOnVoicemailPartnerHandle(this, cache_partner_handle);
                break;
                
            case 102: /* Voicemail.P_PARTNER_DISPNAME */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_partner_dispname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_PARTNER_DISPNAME = " + cache_partner_dispname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_PARTNER_DISPNAME - update without value");
                skypeRef.events.FireOnVoicemailPartnerDispname(this, cache_partner_dispname);
                break;
                
            case 103: /* Voicemail.P_STATUS */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_status = (SktVoicemail.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_STATUS = " + cache_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_STATUS - update without value");
                skypeRef.events.FireOnVoicemailStatus(this, cache_status);
                break;
                
            case 104: /* Voicemail.P_FAILUREREASON */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_failurereason = (SktVoicemail.FAILUREREASON)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_FAILUREREASON = " + cache_failurereason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_FAILUREREASON - update without value");
                skypeRef.events.FireOnVoicemailFailurereason(this, cache_failurereason);
                break;
                
            case 105: /* Voicemail.P_SUBJECT */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_subject = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_SUBJECT = " + cache_subject.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_SUBJECT - update without value");
                skypeRef.events.FireOnVoicemailSubject(this, cache_subject);
                break;
                
            case 106: /* Voicemail.P_TIMESTAMP */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_TIMESTAMP = " + cache_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_TIMESTAMP - update without value");
                skypeRef.events.FireOnVoicemailTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_timestamp));
                break;
                
            case 107: /* Voicemail.P_DURATION */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_duration = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_DURATION = " + cache_duration.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_DURATION - update without value");
                skypeRef.events.FireOnVoicemailDuration(this, cache_duration);
                break;
                
            case 108: /* Voicemail.P_ALLOWED_DURATION */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_allowed_duration = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_ALLOWED_DURATION = " + cache_allowed_duration.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_ALLOWED_DURATION - update without value");
                skypeRef.events.FireOnVoicemailAllowedDuration(this, cache_allowed_duration);
                break;
                
            case 109: /* Voicemail.P_PLAYBACK_PROGRESS */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_playback_progress = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_PLAYBACK_PROGRESS = " + cache_playback_progress.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_PLAYBACK_PROGRESS - update without value");
                skypeRef.events.FireOnVoicemailPlaybackProgress(this, cache_playback_progress);
                break;
                
            case 830: /* Voicemail.P_CONVO_ID */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_id = (SktConversation)value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_CONVO_ID = " + cache_convo_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_CONVO_ID - update without value");
                skypeRef.events.FireOnVoicemailConvoId(this, cache_convo_id);
                break;
                
            case 831: /* Voicemail.P_CHATMSG_GUID */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_chatmsg_guid = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Voicemail.P_CHATMSG_GUID = binary size " + cache_chatmsg_guid.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Voicemail.P_CHATMSG_GUID - update without value");
                skypeRef.events.FireOnVoicemailChatmsgGuid(this, cache_chatmsg_guid);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Voicemail class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktVoicemail property accessors **/
    
    /**  See SktTYPE for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailType(SktVoicemail sender, SktEvents.OnVoicemailTypeArgs e)</b></tt>
     */
    public SktVoicemail.TYPE P_TYPE
    {
        get { if (!cache[0]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 100, this.OID);
        if (skypeRef.transport.PropResponseWasOk(100))
        {
            cache_type = (SktVoicemail.TYPE)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  registered username of the other party
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailPartnerHandle</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailPartnerHandle(SktVoicemail sender, SktEvents.OnVoicemailPartnerHandleArgs e)</b></tt>
     */
    public String P_PARTNER_HANDLE
    {
        get { if (!cache[1]) FetchPartnerHandleFromRuntime(); return cache_partner_handle; }
    }
    
    internal void FetchPartnerHandleFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTNER_HANDLE from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 101, this.OID);
        if (skypeRef.transport.PropResponseWasOk(101))
        {
            cache_partner_handle = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  user's display name of the other party
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailPartnerDispname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailPartnerDispname(SktVoicemail sender, SktEvents.OnVoicemailPartnerDispnameArgs e)</b></tt>
     */
    public String P_PARTNER_DISPNAME
    {
        get { if (!cache[2]) FetchPartnerDispnameFromRuntime(); return cache_partner_dispname; }
    }
    
    internal void FetchPartnerDispnameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTNER_DISPNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 102, this.OID);
        if (skypeRef.transport.PropResponseWasOk(102))
        {
            cache_partner_dispname = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktSTATUS for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailStatus(SktVoicemail sender, SktEvents.OnVoicemailStatusArgs e)</b></tt>
     */
    public SktVoicemail.STATUS P_STATUS
    {
        get { if (!cache[3]) FetchStatusFromRuntime(); return cache_status; }
    }
    
    internal void FetchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 103, this.OID);
        if (skypeRef.transport.PropResponseWasOk(103))
        {
            cache_status = (SktVoicemail.STATUS)skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktFAILUREREASON for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailFailurereason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailFailurereason(SktVoicemail sender, SktEvents.OnVoicemailFailurereasonArgs e)</b></tt>
     */
    public SktVoicemail.FAILUREREASON P_FAILUREREASON
    {
        get { if (!cache[4]) FetchFailurereasonFromRuntime(); return cache_failurereason; }
    }
    
    internal void FetchFailurereasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FAILUREREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 104, this.OID);
        if (skypeRef.transport.PropResponseWasOk(104))
        {
            cache_failurereason = (SktVoicemail.FAILUREREASON)skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  DEPRECATED: subject line
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailSubject</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailSubject(SktVoicemail sender, SktEvents.OnVoicemailSubjectArgs e)</b></tt>
     */
    public String P_SUBJECT
    {
        get { if (!cache[5]) FetchSubjectFromRuntime(); return cache_subject; }
    }
    
    internal void FetchSubjectFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SUBJECT from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 105, this.OID);
        if (skypeRef.transport.PropResponseWasOk(105))
        {
            cache_subject = skypeRef.decoder.DecodeString();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  timestamp of creation
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailTimestamp(SktVoicemail sender, SktEvents.OnVoicemailTimestampArgs e)</b></tt>
     */
    public DateTime P_TIMESTAMP
    {
        get { if (!cache[6]) FetchTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_timestamp); }
    }
    
    internal void FetchTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 106, this.OID);
        if (skypeRef.transport.PropResponseWasOk(106))
        {
            cache_timestamp = skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  duration in seconds
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailDuration</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailDuration(SktVoicemail sender, SktEvents.OnVoicemailDurationArgs e)</b></tt>
     */
    public uint P_DURATION
    {
        get { if (!cache[7]) FetchDurationFromRuntime(); return cache_duration; }
    }
    
    internal void FetchDurationFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DURATION from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 107, this.OID);
        if (skypeRef.transport.PropResponseWasOk(107))
        {
            cache_duration = skypeRef.decoder.DecodeUint();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  max allowed duration in seconds
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailAllowedDuration</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailAllowedDuration(SktVoicemail sender, SktEvents.OnVoicemailAllowedDurationArgs e)</b></tt>
     */
    public uint P_ALLOWED_DURATION
    {
        get { if (!cache[8]) FetchAllowedDurationFromRuntime(); return cache_allowed_duration; }
    }
    
    internal void FetchAllowedDurationFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ALLOWED_DURATION from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 108, this.OID);
        if (skypeRef.transport.PropResponseWasOk(108))
        {
            cache_allowed_duration = skypeRef.decoder.DecodeUint();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  VM playback progress in seconds
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailPlaybackProgress</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailPlaybackProgress(SktVoicemail sender, SktEvents.OnVoicemailPlaybackProgressArgs e)</b></tt>
     */
    public uint P_PLAYBACK_PROGRESS
    {
        get { if (!cache[9]) FetchPlaybackProgressFromRuntime(); return cache_playback_progress; }
    }
    
    internal void FetchPlaybackProgressFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PLAYBACK_PROGRESS from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 109, this.OID);
        if (skypeRef.transport.PropResponseWasOk(109))
        {
            cache_playback_progress = skypeRef.decoder.DecodeUint();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  CONVERSATION_ID of corresponding conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailConvoId(SktVoicemail sender, SktEvents.OnVoicemailConvoIdArgs e)</b></tt>
     */
    public SktConversation P_CONVO_ID
    {
        get { if (!cache[10]) FetchConvoIdFromRuntime(); return cache_convo_id; }
    }
    
    internal void FetchConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 830, this.OID);
        if (skypeRef.transport.PropResponseWasOk(830))
        {
            cache_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  GUID of the message that the VM is tied to
     @n Assign your own event handler method to the <tt><b>skype.events.OnVoicemailChatmsgGuid</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnVoicemailChatmsgGuid(SktVoicemail sender, SktEvents.OnVoicemailChatmsgGuidArgs e)</b></tt>
     */
    public byte[] P_CHATMSG_GUID
    {
        get { if (!cache[11]) FetchChatmsgGuidFromRuntime(); return cache_chatmsg_guid; }
    }
    
    internal void FetchChatmsgGuidFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CHATMSG_GUID from runtime");
        skypeRef.transport.SubmitPropertyRequest(7, 831, this.OID);
        if (skypeRef.transport.PropResponseWasOk(831))
        {
            cache_chatmsg_guid = skypeRef.decoder.DecodeBinary();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktVoicemail class PropKeys */
    
    public enum PropKeys 
    {
        P_TYPE               =  100,
        P_PARTNER_HANDLE     =  101,
        P_PARTNER_DISPNAME   =  102,
        P_STATUS             =  103,
        P_FAILUREREASON      =  104,
        P_SUBJECT            =  105,
        P_TIMESTAMP          =  106,
        P_DURATION           =  107,
        P_ALLOWED_DURATION   =  108,
        P_PLAYBACK_PROGRESS  =  109,
        P_CONVO_ID           =  830,
        P_CHATMSG_GUID       =  831 
    }
    
    /* SktVoicemail class enums */
    
    /**  TYPE
     */
    public enum TYPE
    {
        INCOMING           =    1, /*!<   */
        DEFAULT_GREETING   =    4, /*!<   */
        CUSTOM_GREETING    =    2, /*!<   */
        OUTGOING           =    3  /*!<   */
    }
    
    /**  STATUS
     */
    public enum STATUS
    {
        NOTDOWNLOADED     =    1, /*!<   */
        DOWNLOADING       =    2, /*!<   */
        UNPLAYED          =    3, /*!<   */
        BUFFERING         =    4, /*!<   */
        PLAYING           =    5, /*!<   */
        PLAYED            =    6, /*!<   */
        BLANK             =    7, /*!<   */
        RECORDING         =    8, /*!<   */
        RECORDED          =    9, /*!<   */
        UPLOADING         =   10, /*!<   */
        UPLOADED          =   11, /*!<   */
        DELETING          =   12, /*!<   */
        FAILED            =   13, /*!<   */
        DELETING_FAILED   =   14, /*!<   */
        CHECKING          =   15, /*!<   */
        CANCELLED         =   16  /*!<   */
    }
    
    /**  FAILUREREASON
     */
    public enum FAILUREREASON
    {
        MISC_ERROR                    =    1, /*!<   */
        CONNECT_ERROR                 =    2, /*!<   */
        NO_VOICEMAIL_CAPABILITY       =    3, /*!<   */
        NO_SUCH_VOICEMAIL             =    4, /*!<   */
        FILE_READ_ERROR               =    5, /*!<   */
        FILE_WRITE_ERROR              =    6, /*!<   */
        RECORDING_ERROR               =    7, /*!<   */
        PLAYBACK_ERROR                =    8, /*!<   */
        NO_PERMISSION                 =    9, /*!<   */
        RECEIVER_DISABLED_VOICEMAIL   =   10, /*!< receiver turned off voicemail */
        SENDER_NOT_AUTHORIZED         =   11, /*!< receiver has not authorized you and privacy is not set to anyone */
        SENDER_BLOCKED                =   12  /*!< receiver blocked sender */
    }
    
    /* SktVoicemail class methods */
    
    /**  Start recording your own auto-answer greeting message (leave message after the beep...) only. Recording
      of outgoing Voicemail messages start automatically (using SktConversation.StartVoiceMessage) after playback
      of the remote side greeting message has finished.
     */
    public void StartRecording ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.StartRecording");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.StartRecording");
    }
    
    /**  Stop recording of your own auto-answer greeting message only. To stop recording of and send an outgoing
      Voicemail, use SktConversation.PostVoiceMessage.
     */
    public void StopRecording ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.StopRecording");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.StopRecording");
    }
    
    /**  Initiates playback of a voice message
     */
    public void StartPlayback ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.StartPlayback");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.StartPlayback");
    }
    
    /**  Terminates playback of a voice message
     */
    public void StopPlayback ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.StopPlayback");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.StopPlayback");
    }
    
    /**  first from server, and then the local copy
     */
    public void Delete ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.Delete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.Delete");
    }
    
    /**  Canceling recording of your own auto-answer greeting message. To stop recording of and cancel an outgoing
      Voicemail, use SktConversation.LeaveLiveSession.
     */
    public void Cancel ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.Cancel");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktVoicemail.Cancel");
    }
    
    /**  check if we can send voicemail (unauth,blocked,no priv etc cases). only OUTGOING
        @returns result
     */
    public Boolean CheckPermission ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Voicemail.CheckPermission");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktVoicemail.CheckPermission");
        return (Boolean)args[0];
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Voicemail - the wrapper has no events for this class.");
    }
}

/*! \class SktTransfer
  \brief
  Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts, not transferring
  a call to another Skype or PSTN Contact. This class includes file transfer-specific properties and methods,
  such as FILESIZE, BYTESPERSECOND, Pause and Resume. Recipients of these file transfers must explicitly
  accept (or decline) any incoming transfer. @brief Transfer instances represent files being sent and received
  within a Conversation context. Each Transfer instance represents a single file transfer - if a conversation
  has multiple remote participants, a separate Transfer instance must be instantiated for each remote participant
  (a Transfer instance is not instantiated for the sender). Transfer instances cannot be instantiated directly. Instead, you initiate a file transfer by invoking
  SktConversation.PostFiles. This instantiates a Message instance of type POSTED_FILES, which is added
  to the Conversation for all the participants (including the sender). The Transfer instance is associated
  with this Message instance, and the SktMessage.P_BODY_XML looks like this: @code Some text<files alt=""><file size="2336020" index="0">test.zip</file></files> @endcode To put it another way, the object chain goes like this: @code Conversation->Message->Transfer @endcode The first part of the message (before the files section) comes from the SktConversation.PostFiles body
  argument. For each file in the message, a file section is provided with three fields: 
  @li file size in
  bytes 
  @li index - more or less arbitrary order in which the transfers should be displayed in the UI 
  @li
  file name. For practical purposes, the SktMessage.P_BODY_XML property is not all that useful in this context. The
  Transfer instances, however, contain the state and progress feedback for your UI. You retrieve these
  Transfer instances using SktMessage.GetTransfers method. Since the sender can post multiple files to
  a Conversation using the same Message, Message:GetTransfers retrieves a list of Transfer instances -
  one per file per recipient. You can determine the direction of particular Transfer instance by querying SktTransfer.P_TYPE (INCOMING/OUTGOING).
  You can implement a progress indicator by monitoring SktTransfer.P_BYTESTRANSFERRED. Note that when testing
  this on your local network, you will most likely catch these property change events at the beginning
  and the end of the transfer only - which does not look like too useful. However, for non-local network
  transfers where the transfer speeds are in the neighborhood of 200-300 KB per second, you should consider
  implementing progress feedback as being mandatory and expect to catch multiple property change events
  for all but the smallest files. Another property of interest is SktTransfer.P_STATUS. The normal transfer status sequence during successful
  outgoing transfer is this: 
  @li TRANSFER STATUS -> NEW 
  @li TRANSFER STATUS -> WAITING_FOR_ACCEPT 
  @li TRANSFER
  STATUS -> CONNECTING 
  @li TRANSFER STATUS -> TRANSFERRING 
  @li TRANSFER STATUS -> CONNECTING 
  @li TRANSFER
  STATUS -> COMPLETED The list of all terminal Transfer statuses is: 
  @li COMPLETED 
  @li FAILED 
  @li CANCELLED 
  @li CANCELLED_BY_REMOTE
  In-progress transfers can be canceled with SktTransfer.Cancel and paused/resumed with SktTransfer.Pause
  and SktTransfer.Resume. For transfers that complete with a status of FAILED, your UI should provide feedback
  based on the value of SktTransfer.P_FAILUREREASON. Incoming transfers, once accepted, overwrite existing files with the same name. Before accepting an incoming
  file transfer, your UI should prompt the recipient to: 
  @li accept or decline the file 
  @li if accepted, specify the directory
  of here to save the file (with a pre-filled default) 
  @li if accepted and a file having the same name
  already exists at the specified destination, your UI should prompt for confirmation to overwrite and
  provide a way to alter the file name before accepting it Similarly, your UI should verify the existence of outgoing files prior to invoking SktConversation.PostFiles.
  Note that you should provide both SktConversation.PostFiles and SktTransfer.Accept methods fully-qualified
  paths. Otherwise, the paths will be assumed to be relative to the path of SkypeKit runtime, since the
  methods are actually executed in the runtime context.
 */
public class SktTransfer : SktObject
{
    public override String ClassName { get { return "Transfer"; } }
    
    public override uint ClassId { get { return 6; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktTransfer (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(15);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktTransfer objects.
     */
    public class List : SktObjectList
    {
        new public SktTransfer this[int index]
        {
            get { return (SktTransfer)base[index]; }
        }

        public void Add(SktTransfer item)
        {
            base.Add((SktTransfer)item);
        }
    }
    

    /* SktTransfer property cache fields */
    private volatile SktTransfer.TYPE          cache_type;
    private volatile String                    cache_partner_handle;
    private volatile String                    cache_partner_dispname;
    private volatile SktTransfer.STATUS        cache_status;
    private volatile SktTransfer.FAILUREREASON cache_failurereason;
    private volatile uint                      cache_starttime;
    private volatile uint                      cache_finishtime;
    private volatile String                    cache_filepath;
    private volatile String                    cache_filename;
    private volatile String                    cache_filesize;
    private volatile String                    cache_bytestransferred;
    private volatile uint                      cache_bytespersecond;
    private volatile byte[]                    cache_chatmsg_guid;
    private volatile uint                      cache_chatmsg_index;
    private volatile SktConversation           cache_convo_id;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 98: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 80: /* Transfer.P_TYPE */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktTransfer.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_TYPE - update without value");
                skypeRef.events.FireOnTransferType(this, cache_type);
                break;
                
            case 81: /* Transfer.P_PARTNER_HANDLE */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_partner_handle = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_PARTNER_HANDLE = " + cache_partner_handle.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_PARTNER_HANDLE - update without value");
                skypeRef.events.FireOnTransferPartnerHandle(this, cache_partner_handle);
                break;
                
            case 82: /* Transfer.P_PARTNER_DISPNAME */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_partner_dispname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_PARTNER_DISPNAME = " + cache_partner_dispname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_PARTNER_DISPNAME - update without value");
                skypeRef.events.FireOnTransferPartnerDispname(this, cache_partner_dispname);
                break;
                
            case 83: /* Transfer.P_STATUS */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_status = (SktTransfer.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_STATUS = " + cache_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_STATUS - update without value");
                skypeRef.events.FireOnTransferStatus(this, cache_status);
                break;
                
            case 84: /* Transfer.P_FAILUREREASON */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_failurereason = (SktTransfer.FAILUREREASON)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_FAILUREREASON = " + cache_failurereason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_FAILUREREASON - update without value");
                skypeRef.events.FireOnTransferFailurereason(this, cache_failurereason);
                break;
                
            case 85: /* Transfer.P_STARTTIME */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_starttime = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_STARTTIME = " + cache_starttime.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_STARTTIME - update without value");
                skypeRef.events.FireOnTransferStarttime(this, skypeRef.UnixTimestampToDateTime(cache_starttime));
                break;
                
            case 86: /* Transfer.P_FINISHTIME */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_finishtime = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_FINISHTIME = " + cache_finishtime.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_FINISHTIME - update without value");
                skypeRef.events.FireOnTransferFinishtime(this, skypeRef.UnixTimestampToDateTime(cache_finishtime));
                break;
                
            case 87: /* Transfer.P_FILEPATH */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_filepath = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_FILEPATH = " + cache_filepath.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_FILEPATH - update without value");
                skypeRef.events.FireOnTransferFilepath(this, cache_filepath);
                break;
                
            case 88: /* Transfer.P_FILENAME */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_filename = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_FILENAME = " + cache_filename.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_FILENAME - update without value");
                skypeRef.events.FireOnTransferFilename(this, cache_filename);
                break;
                
            case 89: /* Transfer.P_FILESIZE */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_filesize = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_FILESIZE = " + cache_filesize.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_FILESIZE - update without value");
                skypeRef.events.FireOnTransferFilesize(this, cache_filesize);
                break;
                
            case 90: /* Transfer.P_BYTESTRANSFERRED */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_bytestransferred = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_BYTESTRANSFERRED = " + cache_bytestransferred.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_BYTESTRANSFERRED - update without value");
                skypeRef.events.FireOnTransferBytestransferred(this, cache_bytestransferred);
                break;
                
            case 91: /* Transfer.P_BYTESPERSECOND */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_bytespersecond = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_BYTESPERSECOND = " + cache_bytespersecond.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_BYTESPERSECOND - update without value");
                skypeRef.events.FireOnTransferBytespersecond(this, cache_bytespersecond);
                break;
                
            case 92: /* Transfer.P_CHATMSG_GUID */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_chatmsg_guid = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_CHATMSG_GUID = binary size " + cache_chatmsg_guid.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_CHATMSG_GUID - update without value");
                skypeRef.events.FireOnTransferChatmsgGuid(this, cache_chatmsg_guid);
                break;
                
            case 93: /* Transfer.P_CHATMSG_INDEX */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_chatmsg_index = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_CHATMSG_INDEX = " + cache_chatmsg_index.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_CHATMSG_INDEX - update without value");
                skypeRef.events.FireOnTransferChatmsgIndex(this, cache_chatmsg_index);
                break;
                
            case 98: /* Transfer.P_CONVO_ID */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_convo_id = (SktConversation)value;
                    if (skypeRef.logging) skypeRef.Log("Transfer.P_CONVO_ID = " + cache_convo_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Transfer.P_CONVO_ID - update without value");
                skypeRef.events.FireOnTransferConvoId(this, cache_convo_id);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Transfer class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktTransfer property accessors **/
    
    /**  INCOMING / OUTGOING
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferType(SktTransfer sender, SktEvents.OnTransferTypeArgs e)</b></tt>
     */
    public SktTransfer.TYPE P_TYPE
    {
        get { if (!cache[0]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 80, this.OID);
        if (skypeRef.transport.PropResponseWasOk(80))
        {
            cache_type = (SktTransfer.TYPE)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Skype Name of the remote party of the file transfer. If a file is posted in a conversation with more
      than one participant, Transfer objects are created for each of them - so a transfer is always to one
      single remote target.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferPartnerHandle</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferPartnerHandle(SktTransfer sender, SktEvents.OnTransferPartnerHandleArgs e)</b></tt>
     */
    public String P_PARTNER_HANDLE
    {
        get { if (!cache[1]) FetchPartnerHandleFromRuntime(); return cache_partner_handle; }
    }
    
    internal void FetchPartnerHandleFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTNER_HANDLE from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 81, this.OID);
        if (skypeRef.transport.PropResponseWasOk(81))
        {
            cache_partner_handle = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Display name of the remote participant.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferPartnerDispname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferPartnerDispname(SktTransfer sender, SktEvents.OnTransferPartnerDispnameArgs e)</b></tt>
     */
    public String P_PARTNER_DISPNAME
    {
        get { if (!cache[2]) FetchPartnerDispnameFromRuntime(); return cache_partner_dispname; }
    }
    
    internal void FetchPartnerDispnameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTNER_DISPNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 82, this.OID);
        if (skypeRef.transport.PropResponseWasOk(82))
        {
            cache_partner_dispname = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Current state of the transfer
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferStatus(SktTransfer sender, SktEvents.OnTransferStatusArgs e)</b></tt>
     */
    public SktTransfer.STATUS P_STATUS
    {
        get { if (!cache[3]) FetchStatusFromRuntime(); return cache_status; }
    }
    
    internal void FetchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 83, this.OID);
        if (skypeRef.transport.PropResponseWasOk(83))
        {
            cache_status = (SktTransfer.STATUS)skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Set whenever P_STATUS transitions to FAILED.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferFailurereason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferFailurereason(SktTransfer sender, SktEvents.OnTransferFailurereasonArgs e)</b></tt>
     */
    public SktTransfer.FAILUREREASON P_FAILUREREASON
    {
        get { if (!cache[4]) FetchFailurereasonFromRuntime(); return cache_failurereason; }
    }
    
    internal void FetchFailurereasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FAILUREREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 84, this.OID);
        if (skypeRef.transport.PropResponseWasOk(84))
        {
            cache_failurereason = (SktTransfer.FAILUREREASON)skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of when this Transfer instance was instantiated, not when the transfer process actually
      started (was accepted from receiver side). Do not use this property when calculate the data transfer
      speed! Instead, monitor changes to P_BYTESPERSECOND.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferStarttime</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferStarttime(SktTransfer sender, SktEvents.OnTransferStarttimeArgs e)</b></tt>
     */
    public DateTime P_STARTTIME
    {
        get { if (!cache[5]) FetchStarttimeFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_starttime); }
    }
    
    internal void FetchStarttimeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STARTTIME from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 85, this.OID);
        if (skypeRef.transport.PropResponseWasOk(85))
        {
            cache_starttime = skypeRef.decoder.DecodeUint();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of when this Transfer COMPLETED or FAILED. This property is never set if the receiving
      side (local or remote) canceled the transfer.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferFinishtime</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferFinishtime(SktTransfer sender, SktEvents.OnTransferFinishtimeArgs e)</b></tt>
     */
    public DateTime P_FINISHTIME
    {
        get { if (!cache[6]) FetchFinishtimeFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_finishtime); }
    }
    
    internal void FetchFinishtimeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FINISHTIME from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 86, this.OID);
        if (skypeRef.transport.PropResponseWasOk(86))
        {
            cache_finishtime = skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The path -and- filename of the file being transfered (typically fully qualified). For the receiver, SkypeKit
      sets this property upon acceptance of the incoming transfer. If not fully qualified, the path is assumed
      to be relative to the path of the SkypeKit runtime.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferFilepath</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferFilepath(SktTransfer sender, SktEvents.OnTransferFilepathArgs e)</b></tt>
     */
    public String P_FILEPATH
    {
        get { if (!cache[7]) FetchFilepathFromRuntime(); return cache_filepath; }
    }
    
    internal void FetchFilepathFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FILEPATH from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 87, this.OID);
        if (skypeRef.transport.PropResponseWasOk(87))
        {
            cache_filepath = skypeRef.decoder.DecodeString();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The filename -only- of the file being transfered. The receiver side can use this property to pre-populate
      relevant UI components while prompting the user to accept the incoming transfer.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferFilename</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferFilename(SktTransfer sender, SktEvents.OnTransferFilenameArgs e)</b></tt>
     */
    public String P_FILENAME
    {
        get { if (!cache[8]) FetchFilenameFromRuntime(); return cache_filename; }
    }
    
    internal void FetchFilenameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FILENAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 88, this.OID);
        if (skypeRef.transport.PropResponseWasOk(88))
        {
            cache_filename = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The size of the file being transferred in bytes. Depending on the magnitude of this value, your UI might
      want to display the size in terms of kilobytes or even megabytes.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferFilesize</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferFilesize(SktTransfer sender, SktEvents.OnTransferFilesizeArgs e)</b></tt>
     */
    public String P_FILESIZE
    {
        get { if (!cache[9]) FetchFilesizeFromRuntime(); return cache_filesize; }
    }
    
    internal void FetchFilesizeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FILESIZE from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 89, this.OID);
        if (skypeRef.transport.PropResponseWasOk(89))
        {
            cache_filesize = skypeRef.decoder.DecodeString();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The number of bytes already transferred. Calculate the percentage of the file transferred so far as:
      @code P_BYTESTRANSFERRED / (P_FILESIZE / 100); @endcode Use float variables to avoid problems with files smaller than 100 bytes!
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferBytestransferred</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferBytestransferred(SktTransfer sender, SktEvents.OnTransferBytestransferredArgs e)</b></tt>
     */
    public String P_BYTESTRANSFERRED
    {
        get { if (!cache[10]) FetchBytestransferredFromRuntime(); return cache_bytestransferred; }
    }
    
    internal void FetchBytestransferredFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BYTESTRANSFERRED from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 90, this.OID);
        if (skypeRef.transport.PropResponseWasOk(90))
        {
            cache_bytestransferred = skypeRef.decoder.DecodeString();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Current data transfer speed in bytes per second. Typically, your UI will want to display this value as
      kilobytes per second (KBps).
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferBytespersecond</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferBytespersecond(SktTransfer sender, SktEvents.OnTransferBytespersecondArgs e)</b></tt>
     */
    public uint P_BYTESPERSECOND
    {
        get { if (!cache[11]) FetchBytespersecondFromRuntime(); return cache_bytespersecond; }
    }
    
    internal void FetchBytespersecondFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BYTESPERSECOND from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 91, this.OID);
        if (skypeRef.transport.PropResponseWasOk(91))
        {
            cache_bytespersecond = skypeRef.decoder.DecodeUint();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The "global ID" of this Transfer's associated Message instance. GUIDs are shared across Skype client
      instances and across all users that can see this Message.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferChatmsgGuid</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferChatmsgGuid(SktTransfer sender, SktEvents.OnTransferChatmsgGuidArgs e)</b></tt>
     */
    public byte[] P_CHATMSG_GUID
    {
        get { if (!cache[12]) FetchChatmsgGuidFromRuntime(); return cache_chatmsg_guid; }
    }
    
    internal void FetchChatmsgGuidFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CHATMSG_GUID from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 92, this.OID);
        if (skypeRef.transport.PropResponseWasOk(92))
        {
            cache_chatmsg_guid = skypeRef.decoder.DecodeBinary();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  A more or less arbitrary index for ordering multiple file transfers within the UI.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferChatmsgIndex</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferChatmsgIndex(SktTransfer sender, SktEvents.OnTransferChatmsgIndexArgs e)</b></tt>
     */
    public uint P_CHATMSG_INDEX
    {
        get { if (!cache[13]) FetchChatmsgIndexFromRuntime(); return cache_chatmsg_index; }
    }
    
    internal void FetchChatmsgIndexFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CHATMSG_INDEX from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 93, this.OID);
        if (skypeRef.transport.PropResponseWasOk(93))
        {
            cache_chatmsg_index = skypeRef.decoder.DecodeUint();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The "global ID" of this Transfer's associated Conversation (as chained through its associated Message).
      GUIDs are shared across Skype client instances and across all users that can see this Conversation. Note that currently SkypeKit sets this property for INCOMING file transfers only and returns 0 (zero)
      for all sending side transfers. This is a known bug.
     @n Assign your own event handler method to the <tt><b>skype.events.OnTransferConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnTransferConvoId(SktTransfer sender, SktEvents.OnTransferConvoIdArgs e)</b></tt>
     */
    public SktConversation P_CONVO_ID
    {
        get { if (!cache[14]) FetchConvoIdFromRuntime(); return cache_convo_id; }
    }
    
    internal void FetchConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(6, 98, this.OID);
        if (skypeRef.transport.PropResponseWasOk(98))
        {
            cache_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktTransfer class PropKeys */
    
    public enum PropKeys 
    {
        P_TYPE              =   80,
        P_PARTNER_HANDLE    =   81,
        P_PARTNER_DISPNAME  =   82,
        P_STATUS            =   83,
        P_FAILUREREASON     =   84,
        P_STARTTIME         =   85,
        P_FINISHTIME        =   86,
        P_FILEPATH          =   87,
        P_FILENAME          =   88,
        P_FILESIZE          =   89,
        P_BYTESTRANSFERRED  =   90,
        P_BYTESPERSECOND    =   91,
        P_CHATMSG_GUID      =   92,
        P_CHATMSG_INDEX     =   93,
        P_CONVO_ID          =   98 
    }
    
    /* SktTransfer class enums */
    
    /**  TYPE
     */
    public enum TYPE
    {
        INCOMING   =    1, /*!<   */
        OUTGOING   =    2  /*!<   */
    }
    
    /**  Recognized values for the P_STATUS property. Reflects current state of this Transfer.
     */
    public enum STATUS
    {
        NEW                         =    0, /*!< The file has either not been posted (sent) (OUTGOING), or not accepted (received) (INCOMING).   */
        CONNECTING                  =    1, /*!< A temporary state that transitions either into TRANSFERRING (relayed or direct) or to FAILED. For unknown reasons, outgoing transfers tend go into this state twice - immediately before the actual data transfer starts and immediately after it ends.   */
        WAITING_FOR_ACCEPT          =    2, /*!< The files have been posted but the recipient has not yet accepted (or has declined) the transfer.   */
        TRANSFERRING                =    3, /*!< The transfer has been accepted and file data is being sent/received. Periodic updates of P_BYTESTRANSFERRED property should occur.   */
        TRANSFERRING_OVER_RELAY     =    4, /*!< The transfer has been accepted and file data is being sent/received but is going over at least one relay. Since relayed transfers tend to be significantly slower than direct transfers, you might want to differentiate the two in your UI and notify the user that relayed transfer typically take significantly longer to finish.   */
        PAUSED                      =    5, /*!< The local user (either the sender or a receiver) has paused the transfer.   */
        REMOTELY_PAUSED             =    6, /*!< A remote user has paused the transfer. For senders, a receiver has paused the transfer; for receivers, the sender has paused the transfer.   */
        CANCELLED                   =    7, /*!< Local side (either sender or receiver) has canceled the transfer. This is a final state of the STATE property.   */
        COMPLETED                   =    8, /*!< File transfer has completed. This is a terminal state.   */
        FAILED                      =    9, /*!< File transfer has failed. This is a terminal state. UI should provide feedback, based on value of P_FAILUREREASON.   */
        PLACEHOLDER                 =   10, /*!< Transfer whose existence has been hinted by corresponding chat message, but which is yet to arrive.   */
        OFFER_FROM_OTHER_INSTANCE   =   11, /*!< Outgoing transfer object from another instance of the same account as current local login, running on another system. Hinted through chat message - only implies an offer was made; not necessarily accepted, failed, or completed.    */
        CANCELLED_BY_REMOTE         =   12  /*!< Remote side (either sender or receiver) has canceled the transfer. This is a final state of the STATE property.   */
    }
    
    /**  FAILUREREASON
     */
    public enum FAILUREREASON
    {
        SENDER_NOT_AUTHORISED         =    1, /*!<   */
        REMOTELY_CANCELLED            =    2, /*!<   */
        FAILED_READ                   =    3, /*!<   */
        FAILED_REMOTE_READ            =    4, /*!<   */
        FAILED_WRITE                  =    5, /*!<   */
        FAILED_REMOTE_WRITE           =    6, /*!<   */
        REMOTE_DOES_NOT_SUPPORT_FT    =    7, /*!<   */
        REMOTE_OFFLINE_FOR_TOO_LONG   =    8, /*!<   */
        TOO_MANY_PARALLEL             =    9, /*!<   */
        PLACEHOLDER_TIMEOUT           =   10  /*!<   */
    }
    
    /* SktTransfer class methods */
    
    /**  Accepts an incoming file transfer and saves it to specified file on the local file system. If the specified
      file exists, SkypeKit will silently overwrite it. Your UI should prompting the user for confirmation
      in this case and provide a means for canceling the file transfer or specifying a different target file.
     
        @returns success Set to true if the specified target file was successfully created on the local file system -and- the initial write(s) succeeded. However, the transfer itself can subsequently fail before completion due to its being canceled (either locally or remotely), network failure, local file system space/write issues, and so forth. 
        @param [in] filenameWithPath - Where on the local file system to save the file being transferred. Note that you should specify the
      path as being fully-qualified. Otherwise, SkypeKit will be assume it to be relative to the SkypeKit runtime
      path, since the method is actually executed in the runtime context.
     */
    public Boolean Accept (String filenameWithPath)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Transfer.Accept");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.encoder.AddFileNameParam(1, filenameWithPath);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktTransfer.Accept");
        return (Boolean)args[0];
    }
    
    /**  Temporarily pauses an in-progress incoming or outgoing file transfer. For incoming transfers, only this
      affects the sender and the invoking recipient only. For outgoing transfers, this affects the sender and
      all recipients.
     */
    public void Pause ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Transfer.Pause");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktTransfer.Pause");
    }
    
    /**  Resumes a previously paused file transfer.
     */
    public void Resume ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Transfer.Resume");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktTransfer.Resume");
    }
    
    /**  Cancels an in-progress file transfer. SktTransfer.STATUS will transition to CANCELLED for incoming file
      transfers and to CANCELLED_BY_REMOTE for outgoing transfers.
     */
    public void Cancel ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Transfer.Cancel");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktTransfer.Cancel");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Transfer - the wrapper has no events for this class.");
    }
}

/*! \class SktContact
  \brief
  Address book entry. Encapsulates methods like GetIdentity, GetAvatar, SendAuthRequest, OpenConversation
  etc. Single contact can have additional phone numbers attached to it (ASSIGNED_PHONE1 .. ASSIGNED_PHONE3).
  Note that in the context of a conversation, Contacts are represented by Participant objects. @brief Contact
  member functions all return a Boolean indicating the success (true) or failure (false) of processing
  the request itself (transport, runtime availability, and so forth)?not the success or failure of its
  associated functionality. For example, SktContact.IsMemberOf returns true if it was able to make a determination,
  and its result parameter reflects whether this Contact is a member of the target group. Similarly, SktContact.IsMemberOf
  returns false if it was unable to make a determination, and the value of its result parameter is undefined.
 
 */
public class SktContact : SktObject
{
    public override String ClassName { get { return "Contact"; } }
    
    public override uint ClassId { get { return 2; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktContact (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(44);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktContact objects.
     */
    public class List : SktObjectList
    {
        new public SktContact this[int index]
        {
            get { return (SktContact)base[index]; }
        }

        public void Add(SktContact item)
        {
            base.Add((SktContact)item);
        }
    }
    

    /* SktContact property cache fields */
    private volatile SktContact.TYPE         cache_type;
    private volatile String                  cache_skypename;
    private volatile String                  cache_pstnnumber;
    private volatile String                  cache_fullname;
    private volatile uint                    cache_birthday;
    private volatile uint                    cache_gender;
    private volatile String                  cache_languages;
    private volatile String                  cache_country;
    private volatile String                  cache_province;
    private volatile String                  cache_city;
    private volatile String                  cache_phone_home;
    private volatile String                  cache_phone_office;
    private volatile String                  cache_phone_mobile;
    private volatile String                  cache_emails;
    private volatile String                  cache_homepage;
    private volatile String                  cache_about;
    private volatile byte[]                  cache_avatar_image;
    private volatile String                  cache_mood_text;
    private volatile String                  cache_rich_mood_text;
    private volatile uint                    cache_timezone;
    private volatile byte[]                  cache_capabilities;
    private volatile uint                    cache_profile_timestamp;
    private volatile uint                    cache_nrof_authed_buddies;
    private volatile String                  cache_ipcountry;
    private volatile uint                    cache_avatar_timestamp;
    private volatile uint                    cache_mood_timestamp;
    private volatile String                  cache_received_authrequest;
    private volatile uint                    cache_authreq_timestamp;
    private volatile uint                    cache_lastonline_timestamp;
    private volatile SktContact.AVAILABILITY cache_availability;
    private volatile String                  cache_displayname;
    private volatile Boolean                 cache_refreshing;
    private volatile SktContact.AUTHLEVEL    cache_given_authlevel;
    private volatile String                  cache_given_displayname;
    private volatile String                  cache_assigned_comment;
    private volatile uint                    cache_lastused_timestamp;
    private volatile uint                    cache_authrequest_count;
    private volatile String                  cache_assigned_phone1;
    private volatile String                  cache_assigned_phone1_label;
    private volatile String                  cache_assigned_phone2;
    private volatile String                  cache_assigned_phone2_label;
    private volatile String                  cache_assigned_phone3;
    private volatile String                  cache_assigned_phone3_label;
    private volatile uint                    cache_popularity_ord;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        skypeRef.Error("MapPropIdToClassId called for Contact - the wrapper has no object properties for this class.");
        return 0;
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 202: /* Contact.P_TYPE */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktContact.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_TYPE - update without value");
                skypeRef.events.FireOnContactType(this, cache_type);
                break;
                
            case 4: /* Contact.P_SKYPENAME */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypename = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_SKYPENAME = " + cache_skypename.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_SKYPENAME - update without value");
                skypeRef.events.FireOnContactSkypename(this, cache_skypename);
                break;
                
            case 6: /* Contact.P_PSTNNUMBER */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_pstnnumber = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PSTNNUMBER = " + cache_pstnnumber.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PSTNNUMBER - update without value");
                skypeRef.events.FireOnContactPstnnumber(this, cache_pstnnumber);
                break;
                
            case 5: /* Contact.P_FULLNAME */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_fullname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_FULLNAME = " + cache_fullname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_FULLNAME - update without value");
                skypeRef.events.FireOnContactFullname(this, cache_fullname);
                break;
                
            case 7: /* Contact.P_BIRTHDAY */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_birthday = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_BIRTHDAY = " + cache_birthday.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_BIRTHDAY - update without value");
                skypeRef.events.FireOnContactBirthday(this, cache_birthday);
                break;
                
            case 8: /* Contact.P_GENDER */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_gender = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_GENDER = " + cache_gender.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_GENDER - update without value");
                skypeRef.events.FireOnContactGender(this, cache_gender);
                break;
                
            case 9: /* Contact.P_LANGUAGES */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_languages = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_LANGUAGES = " + cache_languages.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_LANGUAGES - update without value");
                skypeRef.events.FireOnContactLanguages(this, cache_languages);
                break;
                
            case 10: /* Contact.P_COUNTRY */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_country = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_COUNTRY = " + cache_country.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_COUNTRY - update without value");
                skypeRef.events.FireOnContactCountry(this, cache_country);
                break;
                
            case 11: /* Contact.P_PROVINCE */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_province = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PROVINCE = " + cache_province.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PROVINCE - update without value");
                skypeRef.events.FireOnContactProvince(this, cache_province);
                break;
                
            case 12: /* Contact.P_CITY */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_city = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_CITY = " + cache_city.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_CITY - update without value");
                skypeRef.events.FireOnContactCity(this, cache_city);
                break;
                
            case 13: /* Contact.P_PHONE_HOME */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_home = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_HOME = " + cache_phone_home.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_HOME - update without value");
                skypeRef.events.FireOnContactPhoneHome(this, cache_phone_home);
                break;
                
            case 14: /* Contact.P_PHONE_OFFICE */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_office = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_OFFICE = " + cache_phone_office.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_OFFICE - update without value");
                skypeRef.events.FireOnContactPhoneOffice(this, cache_phone_office);
                break;
                
            case 15: /* Contact.P_PHONE_MOBILE */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_mobile = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_MOBILE = " + cache_phone_mobile.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PHONE_MOBILE - update without value");
                skypeRef.events.FireOnContactPhoneMobile(this, cache_phone_mobile);
                break;
                
            case 16: /* Contact.P_EMAILS */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_emails = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_EMAILS = " + cache_emails.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_EMAILS - update without value");
                skypeRef.events.FireOnContactEmails(this, cache_emails);
                break;
                
            case 17: /* Contact.P_HOMEPAGE */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_homepage = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_HOMEPAGE = " + cache_homepage.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_HOMEPAGE - update without value");
                skypeRef.events.FireOnContactHomepage(this, cache_homepage);
                break;
                
            case 18: /* Contact.P_ABOUT */
                cache[15] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_about = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ABOUT = " + cache_about.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ABOUT - update without value");
                skypeRef.events.FireOnContactAbout(this, cache_about);
                break;
                
            case 37: /* Contact.P_AVATAR_IMAGE */
                cache[16] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_avatar_image = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_AVATAR_IMAGE = binary size " + cache_avatar_image.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_AVATAR_IMAGE - update without value");
                skypeRef.events.FireOnContactAvatarImage(this, cache_avatar_image);
                break;
                
            case 26: /* Contact.P_MOOD_TEXT */
                cache[17] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_mood_text = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_MOOD_TEXT = " + cache_mood_text.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_MOOD_TEXT - update without value");
                skypeRef.events.FireOnContactMoodText(this, cache_mood_text);
                break;
                
            case 205: /* Contact.P_RICH_MOOD_TEXT */
                cache[18] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_rich_mood_text = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_RICH_MOOD_TEXT = " + cache_rich_mood_text.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_RICH_MOOD_TEXT - update without value");
                skypeRef.events.FireOnContactRichMoodText(this, cache_rich_mood_text);
                break;
                
            case 27: /* Contact.P_TIMEZONE */
                cache[19] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timezone = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_TIMEZONE = " + cache_timezone.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_TIMEZONE - update without value");
                skypeRef.events.FireOnContactTimezone(this, cache_timezone);
                break;
                
            case 36: /* Contact.P_CAPABILITIES */
                cache[20] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_capabilities = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_CAPABILITIES = binary size " + cache_capabilities.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_CAPABILITIES - update without value");
                skypeRef.events.FireOnContactCapabilities(this, cache_capabilities);
                break;
                
            case 19: /* Contact.P_PROFILE_TIMESTAMP */
                cache[21] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_profile_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_PROFILE_TIMESTAMP = " + cache_profile_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_PROFILE_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactProfileTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_profile_timestamp));
                break;
                
            case 28: /* Contact.P_NROF_AUTHED_BUDDIES */
                cache[22] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_nrof_authed_buddies = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_NROF_AUTHED_BUDDIES = " + cache_nrof_authed_buddies.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_NROF_AUTHED_BUDDIES - update without value");
                skypeRef.events.FireOnContactNrofAuthedBuddies(this, cache_nrof_authed_buddies);
                break;
                
            case 29: /* Contact.P_IPCOUNTRY */
                cache[23] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_ipcountry = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_IPCOUNTRY = " + cache_ipcountry.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_IPCOUNTRY - update without value");
                skypeRef.events.FireOnContactIpcountry(this, cache_ipcountry);
                break;
                
            case 182: /* Contact.P_AVATAR_TIMESTAMP */
                cache[24] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_avatar_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_AVATAR_TIMESTAMP = " + cache_avatar_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_AVATAR_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactAvatarTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_avatar_timestamp));
                break;
                
            case 183: /* Contact.P_MOOD_TIMESTAMP */
                cache[25] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_mood_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_MOOD_TIMESTAMP = " + cache_mood_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_MOOD_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactMoodTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_mood_timestamp));
                break;
                
            case 20: /* Contact.P_RECEIVED_AUTHREQUEST */
                cache[26] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_received_authrequest = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_RECEIVED_AUTHREQUEST = " + cache_received_authrequest.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_RECEIVED_AUTHREQUEST - update without value");
                skypeRef.events.FireOnContactReceivedAuthrequest(this, cache_received_authrequest);
                break;
                
            case 25: /* Contact.P_AUTHREQ_TIMESTAMP */
                cache[27] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_authreq_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_AUTHREQ_TIMESTAMP = " + cache_authreq_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_AUTHREQ_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactAuthreqTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_authreq_timestamp));
                break;
                
            case 35: /* Contact.P_LASTONLINE_TIMESTAMP */
                cache[28] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_lastonline_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_LASTONLINE_TIMESTAMP = " + cache_lastonline_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_LASTONLINE_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactLastonlineTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_lastonline_timestamp));
                break;
                
            case 34: /* Contact.P_AVAILABILITY */
                cache[29] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_availability = (SktContact.AVAILABILITY)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_AVAILABILITY = " + cache_availability.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_AVAILABILITY - update without value");
                skypeRef.events.FireOnContactAvailability(this, cache_availability);
                break;
                
            case 21: /* Contact.P_DISPLAYNAME */
                cache[30] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_DISPLAYNAME = " + cache_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_DISPLAYNAME - update without value");
                skypeRef.events.FireOnContactDisplayname(this, cache_displayname);
                break;
                
            case 22: /* Contact.P_REFRESHING */
                cache[31] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_refreshing = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_REFRESHING = " + cache_refreshing.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_REFRESHING - update without value");
                skypeRef.events.FireOnContactRefreshing(this, cache_refreshing);
                break;
                
            case 23: /* Contact.P_GIVEN_AUTHLEVEL */
                cache[32] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_given_authlevel = (SktContact.AUTHLEVEL)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_GIVEN_AUTHLEVEL = " + cache_given_authlevel.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_GIVEN_AUTHLEVEL - update without value");
                skypeRef.events.FireOnContactGivenAuthlevel(this, cache_given_authlevel);
                break;
                
            case 33: /* Contact.P_GIVEN_DISPLAYNAME */
                cache[33] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_given_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_GIVEN_DISPLAYNAME = " + cache_given_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_GIVEN_DISPLAYNAME - update without value");
                skypeRef.events.FireOnContactGivenDisplayname(this, cache_given_displayname);
                break;
                
            case 180: /* Contact.P_ASSIGNED_COMMENT */
                cache[34] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_comment = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_COMMENT = " + cache_assigned_comment.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_COMMENT - update without value");
                skypeRef.events.FireOnContactAssignedComment(this, cache_assigned_comment);
                break;
                
            case 39: /* Contact.P_LASTUSED_TIMESTAMP */
                cache[35] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_lastused_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_LASTUSED_TIMESTAMP = " + cache_lastused_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_LASTUSED_TIMESTAMP - update without value");
                skypeRef.events.FireOnContactLastusedTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_lastused_timestamp));
                break;
                
            case 41: /* Contact.P_AUTHREQUEST_COUNT */
                cache[36] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_authrequest_count = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_AUTHREQUEST_COUNT = " + cache_authrequest_count.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_AUTHREQUEST_COUNT - update without value");
                skypeRef.events.FireOnContactAuthrequestCount(this, cache_authrequest_count);
                break;
                
            case 184: /* Contact.P_ASSIGNED_PHONE1 */
                cache[37] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone1 = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE1 = " + cache_assigned_phone1.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE1 - update without value");
                skypeRef.events.FireOnContactAssignedPhone1(this, cache_assigned_phone1);
                break;
                
            case 185: /* Contact.P_ASSIGNED_PHONE1_LABEL */
                cache[38] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone1_label = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE1_LABEL = " + cache_assigned_phone1_label.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE1_LABEL - update without value");
                skypeRef.events.FireOnContactAssignedPhone1Label(this, cache_assigned_phone1_label);
                break;
                
            case 186: /* Contact.P_ASSIGNED_PHONE2 */
                cache[39] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone2 = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE2 = " + cache_assigned_phone2.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE2 - update without value");
                skypeRef.events.FireOnContactAssignedPhone2(this, cache_assigned_phone2);
                break;
                
            case 187: /* Contact.P_ASSIGNED_PHONE2_LABEL */
                cache[40] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone2_label = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE2_LABEL = " + cache_assigned_phone2_label.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE2_LABEL - update without value");
                skypeRef.events.FireOnContactAssignedPhone2Label(this, cache_assigned_phone2_label);
                break;
                
            case 188: /* Contact.P_ASSIGNED_PHONE3 */
                cache[41] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone3 = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE3 = " + cache_assigned_phone3.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE3 - update without value");
                skypeRef.events.FireOnContactAssignedPhone3(this, cache_assigned_phone3);
                break;
                
            case 189: /* Contact.P_ASSIGNED_PHONE3_LABEL */
                cache[42] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_assigned_phone3_label = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE3_LABEL = " + cache_assigned_phone3_label.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_ASSIGNED_PHONE3_LABEL - update without value");
                skypeRef.events.FireOnContactAssignedPhone3Label(this, cache_assigned_phone3_label);
                break;
                
            case 42: /* Contact.P_POPULARITY_ORD */
                cache[43] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_popularity_ord = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Contact.P_POPULARITY_ORD = " + cache_popularity_ord.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Contact.P_POPULARITY_ORD - update without value");
                skypeRef.events.FireOnContactPopularityOrd(this, cache_popularity_ord);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Contact class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktContact property accessors **/
    
    /**  See SktContact.TYPE for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactType(SktContact sender, SktEvents.OnContactTypeArgs e)</b></tt>
     */
    public SktContact.TYPE P_TYPE
    {
        get { if (!cache[0]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 202, this.OID);
        if (skypeRef.transport.PropResponseWasOk(202))
        {
            cache_type = (SktContact.TYPE)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  defined if it is a SKYPE contact
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactSkypename</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactSkypename(SktContact sender, SktEvents.OnContactSkypenameArgs e)</b></tt>
     */
    public String P_SKYPENAME
    {
        get { if (!cache[1]) FetchSkypenameFromRuntime(); return cache_skypename; }
    }
    
    internal void FetchSkypenameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPENAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 4, this.OID);
        if (skypeRef.transport.PropResponseWasOk(4))
        {
            cache_skypename = skypeRef.decoder.DecodeString();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactPstnnumber</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactPstnnumber(SktContact sender, SktEvents.OnContactPstnnumberArgs e)</b></tt>
     */
    public String P_PSTNNUMBER
    {
        get { if (!cache[2]) FetchPstnnumberFromRuntime(); return cache_pstnnumber; }
    }
    
    internal void FetchPstnnumberFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PSTNNUMBER from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 6, this.OID);
        if (skypeRef.transport.PropResponseWasOk(6))
        {
            cache_pstnnumber = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactFullname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactFullname(SktContact sender, SktEvents.OnContactFullnameArgs e)</b></tt>
     */
    public String P_FULLNAME
    {
        get { if (!cache[3]) FetchFullnameFromRuntime(); return cache_fullname; }
    }
    
    internal void FetchFullnameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FULLNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 5, this.OID);
        if (skypeRef.transport.PropResponseWasOk(5))
        {
            cache_fullname = skypeRef.decoder.DecodeString();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  integer of YYYYMMDD format
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactBirthday</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactBirthday(SktContact sender, SktEvents.OnContactBirthdayArgs e)</b></tt>
     */
    public uint P_BIRTHDAY
    {
        get { if (!cache[4]) FetchBirthdayFromRuntime(); return cache_birthday; }
    }
    
    internal void FetchBirthdayFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BIRTHDAY from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 7, this.OID);
        if (skypeRef.transport.PropResponseWasOk(7))
        {
            cache_birthday = skypeRef.decoder.DecodeUint();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  1-male, 2-female
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGender</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGender(SktContact sender, SktEvents.OnContactGenderArgs e)</b></tt>
     */
    public uint P_GENDER
    {
        get { if (!cache[5]) FetchGenderFromRuntime(); return cache_gender; }
    }
    
    internal void FetchGenderFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GENDER from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 8, this.OID);
        if (skypeRef.transport.PropResponseWasOk(8))
        {
            cache_gender = skypeRef.decoder.DecodeUint();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ISO language code list, space separated
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactLanguages</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactLanguages(SktContact sender, SktEvents.OnContactLanguagesArgs e)</b></tt>
     */
    public String P_LANGUAGES
    {
        get { if (!cache[6]) FetchLanguagesFromRuntime(); return cache_languages; }
    }
    
    internal void FetchLanguagesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LANGUAGES from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 9, this.OID);
        if (skypeRef.transport.PropResponseWasOk(9))
        {
            cache_languages = skypeRef.decoder.DecodeString();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ISO country code
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactCountry</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactCountry(SktContact sender, SktEvents.OnContactCountryArgs e)</b></tt>
     */
    public String P_COUNTRY
    {
        get { if (!cache[7]) FetchCountryFromRuntime(); return cache_country; }
    }
    
    internal void FetchCountryFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_COUNTRY from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 10, this.OID);
        if (skypeRef.transport.PropResponseWasOk(10))
        {
            cache_country = skypeRef.decoder.DecodeString();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactProvince</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactProvince(SktContact sender, SktEvents.OnContactProvinceArgs e)</b></tt>
     */
    public String P_PROVINCE
    {
        get { if (!cache[8]) FetchProvinceFromRuntime(); return cache_province; }
    }
    
    internal void FetchProvinceFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PROVINCE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 11, this.OID);
        if (skypeRef.transport.PropResponseWasOk(11))
        {
            cache_province = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactCity</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactCity(SktContact sender, SktEvents.OnContactCityArgs e)</b></tt>
     */
    public String P_CITY
    {
        get { if (!cache[9]) FetchCityFromRuntime(); return cache_city; }
    }
    
    internal void FetchCityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 12, this.OID);
        if (skypeRef.transport.PropResponseWasOk(12))
        {
            cache_city = skypeRef.decoder.DecodeString();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This corresponds to the SktAccount.P_PHONE_HOME property. The value is set by the remote user in Account
      profile. As Contact property, this is read-only.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactPhoneHome</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactPhoneHome(SktContact sender, SktEvents.OnContactPhoneHomeArgs e)</b></tt>
     */
    public String P_PHONE_HOME
    {
        get { if (!cache[10]) FetchPhoneHomeFromRuntime(); return cache_phone_home; }
    }
    
    internal void FetchPhoneHomeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_HOME from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 13, this.OID);
        if (skypeRef.transport.PropResponseWasOk(13))
        {
            cache_phone_home = skypeRef.decoder.DecodeString();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This corresponds to the SktAccount.P_PHONE_OFFICE property. The value is set by the remote user in Account
      profile. As Contact property, this is read-only. If the Contact has not populated his Account profile
      with sufficient phone numbers, the UI should implement locally adding additional phone numbers to Contact
      P_ASSIGNED_PHONE1 .. P_ASSIGNED_PHONE3 properties (and corresponding labels). See SktContact.SetPhoneNumber
      method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactPhoneOffice</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactPhoneOffice(SktContact sender, SktEvents.OnContactPhoneOfficeArgs e)</b></tt>
     */
    public String P_PHONE_OFFICE
    {
        get { if (!cache[11]) FetchPhoneOfficeFromRuntime(); return cache_phone_office; }
    }
    
    internal void FetchPhoneOfficeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_OFFICE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 14, this.OID);
        if (skypeRef.transport.PropResponseWasOk(14))
        {
            cache_phone_office = skypeRef.decoder.DecodeString();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This corresponds to the SktAccount.P_PHONE_MOBILE property. The value is set by the remote user in Account
      profile. As Contact property, this is read-only.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactPhoneMobile</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactPhoneMobile(SktContact sender, SktEvents.OnContactPhoneMobileArgs e)</b></tt>
     */
    public String P_PHONE_MOBILE
    {
        get { if (!cache[12]) FetchPhoneMobileFromRuntime(); return cache_phone_mobile; }
    }
    
    internal void FetchPhoneMobileFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_MOBILE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 15, this.OID);
        if (skypeRef.transport.PropResponseWasOk(15))
        {
            cache_phone_mobile = skypeRef.decoder.DecodeString();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  will be hashed before advertising/querying, space separated
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactEmails</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactEmails(SktContact sender, SktEvents.OnContactEmailsArgs e)</b></tt>
     */
    public String P_EMAILS
    {
        get { if (!cache[13]) FetchEmailsFromRuntime(); return cache_emails; }
    }
    
    internal void FetchEmailsFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_EMAILS from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 16, this.OID);
        if (skypeRef.transport.PropResponseWasOk(16))
        {
            cache_emails = skypeRef.decoder.DecodeString();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactHomepage</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactHomepage(SktContact sender, SktEvents.OnContactHomepageArgs e)</b></tt>
     */
    public String P_HOMEPAGE
    {
        get { if (!cache[14]) FetchHomepageFromRuntime(); return cache_homepage; }
    }
    
    internal void FetchHomepageFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_HOMEPAGE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 17, this.OID);
        if (skypeRef.transport.PropResponseWasOk(17))
        {
            cache_homepage = skypeRef.decoder.DecodeString();
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  arbitrary introductory text
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAbout</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAbout(SktContact sender, SktEvents.OnContactAboutArgs e)</b></tt>
     */
    public String P_ABOUT
    {
        get { if (!cache[15]) FetchAboutFromRuntime(); return cache_about; }
    }
    
    internal void FetchAboutFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ABOUT from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 18, this.OID);
        if (skypeRef.transport.PropResponseWasOk(18))
        {
            cache_about = skypeRef.decoder.DecodeString();
            cache[15] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Contact avatar pictures are in JPG format. The original size of avatar pictures are in no more than 96
      x 96 pixels in size. However, as they can be smaller, scaling the pictures up too much to fit your UI
      can lead to distorted images.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAvatarImage</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAvatarImage(SktContact sender, SktEvents.OnContactAvatarImageArgs e)</b></tt>
     */
    public byte[] P_AVATAR_IMAGE
    {
        get { if (!cache[16]) FetchAvatarImageFromRuntime(); return cache_avatar_image; }
    }
    
    internal void FetchAvatarImageFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVATAR_IMAGE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 37, this.OID);
        if (skypeRef.transport.PropResponseWasOk(37))
        {
            cache_avatar_image = skypeRef.decoder.DecodeBinary();
            cache[16] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Personal mood message (visible to authorized users only).
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactMoodText</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactMoodText(SktContact sender, SktEvents.OnContactMoodTextArgs e)</b></tt>
     */
    public String P_MOOD_TEXT
    {
        get { if (!cache[17]) FetchMoodTextFromRuntime(); return cache_mood_text; }
    }
    
    internal void FetchMoodTextFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MOOD_TEXT from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 26, this.OID);
        if (skypeRef.transport.PropResponseWasOk(26))
        {
            cache_mood_text = skypeRef.decoder.DecodeString();
            cache[17] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  XML version of personal mood text
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactRichMoodText</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactRichMoodText(SktContact sender, SktEvents.OnContactRichMoodTextArgs e)</b></tt>
     */
    public String P_RICH_MOOD_TEXT
    {
        get { if (!cache[18]) FetchRichMoodTextFromRuntime(); return cache_rich_mood_text; }
    }
    
    internal void FetchRichMoodTextFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_RICH_MOOD_TEXT from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 205, this.OID);
        if (skypeRef.transport.PropResponseWasOk(205))
        {
            cache_rich_mood_text = skypeRef.decoder.DecodeXML();
            cache[18] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  24*3600+diff_to_UTC_in_seconds. NB! changes with DST
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactTimezone</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactTimezone(SktContact sender, SktEvents.OnContactTimezoneArgs e)</b></tt>
     */
    public uint P_TIMEZONE
    {
        get { if (!cache[19]) FetchTimezoneFromRuntime(); return cache_timezone; }
    }
    
    internal void FetchTimezoneFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMEZONE from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 27, this.OID);
        if (skypeRef.transport.PropResponseWasOk(27))
        {
            cache_timezone = skypeRef.decoder.DecodeUint();
            cache[19] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  binary tag that can be queried via SktContact.HasCapability()
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactCapabilities</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactCapabilities(SktContact sender, SktEvents.OnContactCapabilitiesArgs e)</b></tt>
     */
    public byte[] P_CAPABILITIES
    {
        get { if (!cache[20]) FetchCapabilitiesFromRuntime(); return cache_capabilities; }
    }
    
    internal void FetchCapabilitiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CAPABILITIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 36, this.OID);
        if (skypeRef.transport.PropResponseWasOk(36))
        {
            cache_capabilities = skypeRef.decoder.DecodeBinary();
            cache[20] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of last profile change
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactProfileTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactProfileTimestamp(SktContact sender, SktEvents.OnContactProfileTimestampArgs e)</b></tt>
     */
    public DateTime P_PROFILE_TIMESTAMP
    {
        get { if (!cache[21]) FetchProfileTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_profile_timestamp); }
    }
    
    internal void FetchProfileTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PROFILE_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 19, this.OID);
        if (skypeRef.transport.PropResponseWasOk(19))
        {
            cache_profile_timestamp = skypeRef.decoder.DecodeUint();
            cache[21] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  count of this user's authorized contacts
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactNrofAuthedBuddies</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactNrofAuthedBuddies(SktContact sender, SktEvents.OnContactNrofAuthedBuddiesArgs e)</b></tt>
     */
    public uint P_NROF_AUTHED_BUDDIES
    {
        get { if (!cache[22]) FetchNrofAuthedBuddiesFromRuntime(); return cache_nrof_authed_buddies; }
    }
    
    internal void FetchNrofAuthedBuddiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_NROF_AUTHED_BUDDIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 28, this.OID);
        if (skypeRef.transport.PropResponseWasOk(28))
        {
            cache_nrof_authed_buddies = skypeRef.decoder.DecodeUint();
            cache[22] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ISO country code assigned by the IP
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactIpcountry</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactIpcountry(SktContact sender, SktEvents.OnContactIpcountryArgs e)</b></tt>
     */
    public String P_IPCOUNTRY
    {
        get { if (!cache[23]) FetchIpcountryFromRuntime(); return cache_ipcountry; }
    }
    
    internal void FetchIpcountryFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IPCOUNTRY from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 29, this.OID);
        if (skypeRef.transport.PropResponseWasOk(29))
        {
            cache_ipcountry = skypeRef.decoder.DecodeString();
            cache[23] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of when current avatar was set
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAvatarTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAvatarTimestamp(SktContact sender, SktEvents.OnContactAvatarTimestampArgs e)</b></tt>
     */
    public DateTime P_AVATAR_TIMESTAMP
    {
        get { if (!cache[24]) FetchAvatarTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_avatar_timestamp); }
    }
    
    internal void FetchAvatarTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVATAR_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 182, this.OID);
        if (skypeRef.transport.PropResponseWasOk(182))
        {
            cache_avatar_timestamp = skypeRef.decoder.DecodeUint();
            cache[24] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  NOT SET FOR CONTACTS. For Account object, UNIX timestamp of when current mood was set
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactMoodTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactMoodTimestamp(SktContact sender, SktEvents.OnContactMoodTimestampArgs e)</b></tt>
     */
    public DateTime P_MOOD_TIMESTAMP
    {
        get { if (!cache[25]) FetchMoodTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_mood_timestamp); }
    }
    
    internal void FetchMoodTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MOOD_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 183, this.OID);
        if (skypeRef.transport.PropResponseWasOk(183))
        {
            cache_mood_timestamp = skypeRef.decoder.DecodeUint();
            cache[25] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  set if the contact is waiting to be authorized. The value contains auth. request text
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactReceivedAuthrequest</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactReceivedAuthrequest(SktContact sender, SktEvents.OnContactReceivedAuthrequestArgs e)</b></tt>
     */
    public String P_RECEIVED_AUTHREQUEST
    {
        get { if (!cache[26]) FetchReceivedAuthrequestFromRuntime(); return cache_received_authrequest; }
    }
    
    internal void FetchReceivedAuthrequestFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_RECEIVED_AUTHREQUEST from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 20, this.OID);
        if (skypeRef.transport.PropResponseWasOk(20))
        {
            cache_received_authrequest = skypeRef.decoder.DecodeString();
            cache[26] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  timestamp of last received auth-request
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAuthreqTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAuthreqTimestamp(SktContact sender, SktEvents.OnContactAuthreqTimestampArgs e)</b></tt>
     */
    public DateTime P_AUTHREQ_TIMESTAMP
    {
        get { if (!cache[27]) FetchAuthreqTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_authreq_timestamp); }
    }
    
    internal void FetchAuthreqTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AUTHREQ_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 25, this.OID);
        if (skypeRef.transport.PropResponseWasOk(25))
        {
            cache_authreq_timestamp = skypeRef.decoder.DecodeUint();
            cache[27] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  X timestamp of last successful ping to that user
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactLastonlineTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactLastonlineTimestamp(SktContact sender, SktEvents.OnContactLastonlineTimestampArgs e)</b></tt>
     */
    public DateTime P_LASTONLINE_TIMESTAMP
    {
        get { if (!cache[28]) FetchLastonlineTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_lastonline_timestamp); }
    }
    
    internal void FetchLastonlineTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LASTONLINE_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 35, this.OID);
        if (skypeRef.transport.PropResponseWasOk(35))
        {
            cache_lastonline_timestamp = skypeRef.decoder.DecodeUint();
            cache[28] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktContact.AVAILABILITY
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAvailability</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAvailability(SktContact sender, SktEvents.OnContactAvailabilityArgs e)</b></tt>
     */
    public SktContact.AVAILABILITY P_AVAILABILITY
    {
        get { if (!cache[29]) FetchAvailabilityFromRuntime(); return cache_availability; }
    }
    
    internal void FetchAvailabilityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVAILABILITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 34, this.OID);
        if (skypeRef.transport.PropResponseWasOk(34))
        {
            cache_availability = (SktContact.AVAILABILITY)skypeRef.decoder.DecodeUint();
            cache[29] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  always set (assigned by lib by looking at various fields)
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactDisplayname(SktContact sender, SktEvents.OnContactDisplaynameArgs e)</b></tt>
     */
    public String P_DISPLAYNAME
    {
        get { if (!cache[30]) FetchDisplaynameFromRuntime(); return cache_displayname; }
    }
    
    internal void FetchDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 21, this.OID);
        if (skypeRef.transport.PropResponseWasOk(21))
        {
            cache_displayname = skypeRef.decoder.DecodeString();
            cache[30] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  true if querying additional information from p2p or server
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactRefreshing</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactRefreshing(SktContact sender, SktEvents.OnContactRefreshingArgs e)</b></tt>
     */
    public Boolean P_REFRESHING
    {
        get { if (!cache[31]) FetchRefreshingFromRuntime(); return cache_refreshing; }
    }
    
    internal void FetchRefreshingFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_REFRESHING from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 22, this.OID);
        if (skypeRef.transport.PropResponseWasOk(22))
        {
            cache_refreshing = skypeRef.decoder.DecodeBool();
            cache[31] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktContact.AUTHLEVEL, change via SktContact.GiveAuthlevel()
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGivenAuthlevel</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGivenAuthlevel(SktContact sender, SktEvents.OnContactGivenAuthlevelArgs e)</b></tt>
     */
    public SktContact.AUTHLEVEL P_GIVEN_AUTHLEVEL
    {
        get { if (!cache[32]) FetchGivenAuthlevelFromRuntime(); return cache_given_authlevel; }
    }
    
    internal void FetchGivenAuthlevelFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GIVEN_AUTHLEVEL from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 23, this.OID);
        if (skypeRef.transport.PropResponseWasOk(23))
        {
            cache_given_authlevel = (SktContact.AUTHLEVEL)skypeRef.decoder.DecodeUint();
            cache[32] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  change via SktContact.GiveDisplayname()
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactGivenDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactGivenDisplayname(SktContact sender, SktEvents.OnContactGivenDisplaynameArgs e)</b></tt>
     */
    public String P_GIVEN_DISPLAYNAME
    {
        get { if (!cache[33]) FetchGivenDisplaynameFromRuntime(); return cache_given_displayname; }
    }
    
    internal void FetchGivenDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GIVEN_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 33, this.OID);
        if (skypeRef.transport.PropResponseWasOk(33))
        {
            cache_given_displayname = skypeRef.decoder.DecodeString();
            cache[33] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  change via SktContact.AssignComment()
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedComment</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedComment(SktContact sender, SktEvents.OnContactAssignedCommentArgs e)</b></tt>
     */
    public String P_ASSIGNED_COMMENT
    {
        get { if (!cache[34]) FetchAssignedCommentFromRuntime(); return cache_assigned_comment; }
    }
    
    internal void FetchAssignedCommentFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_COMMENT from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 180, this.OID);
        if (skypeRef.transport.PropResponseWasOk(180))
        {
            cache_assigned_comment = skypeRef.decoder.DecodeString();
            cache[34] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of last outbound session (call, chat, FT, etc)
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactLastusedTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactLastusedTimestamp(SktContact sender, SktEvents.OnContactLastusedTimestampArgs e)</b></tt>
     */
    public DateTime P_LASTUSED_TIMESTAMP
    {
        get { if (!cache[35]) FetchLastusedTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_lastused_timestamp); }
    }
    
    internal void FetchLastusedTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LASTUSED_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 39, this.OID);
        if (skypeRef.transport.PropResponseWasOk(39))
        {
            cache_lastused_timestamp = skypeRef.decoder.DecodeUint();
            cache[35] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  for contacts that have CONTACT_RECEIVED_AUTHREQUEST, how many times in a row they have requested it without
      positive answer
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAuthrequestCount</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAuthrequestCount(SktContact sender, SktEvents.OnContactAuthrequestCountArgs e)</b></tt>
     */
    public uint P_AUTHREQUEST_COUNT
    {
        get { if (!cache[36]) FetchAuthrequestCountFromRuntime(); return cache_authrequest_count; }
    }
    
    internal void FetchAuthrequestCountFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AUTHREQUEST_COUNT from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 41, this.OID);
        if (skypeRef.transport.PropResponseWasOk(41))
        {
            cache_authrequest_count = skypeRef.decoder.DecodeUint();
            cache[36] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone1</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone1(SktContact sender, SktEvents.OnContactAssignedPhone1Args e)</b></tt>
     */
    public String P_ASSIGNED_PHONE1
    {
        get { if (!cache[37]) FetchAssignedPhone1FromRuntime(); return cache_assigned_phone1; }
    }
    
    internal void FetchAssignedPhone1FromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE1 from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 184, this.OID);
        if (skypeRef.transport.PropResponseWasOk(184))
        {
            cache_assigned_phone1 = skypeRef.decoder.DecodeString();
            cache[37] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone1Label</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone1Label(SktContact sender, SktEvents.OnContactAssignedPhone1LabelArgs e)</b></tt>
     */
    public String P_ASSIGNED_PHONE1_LABEL
    {
        get { if (!cache[38]) FetchAssignedPhone1LabelFromRuntime(); return cache_assigned_phone1_label; }
    }
    
    internal void FetchAssignedPhone1LabelFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE1_LABEL from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 185, this.OID);
        if (skypeRef.transport.PropResponseWasOk(185))
        {
            cache_assigned_phone1_label = skypeRef.decoder.DecodeString();
            cache[38] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone2</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone2(SktContact sender, SktEvents.OnContactAssignedPhone2Args e)</b></tt>
     */
    public String P_ASSIGNED_PHONE2
    {
        get { if (!cache[39]) FetchAssignedPhone2FromRuntime(); return cache_assigned_phone2; }
    }
    
    internal void FetchAssignedPhone2FromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE2 from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 186, this.OID);
        if (skypeRef.transport.PropResponseWasOk(186))
        {
            cache_assigned_phone2 = skypeRef.decoder.DecodeString();
            cache[39] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone2Label</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone2Label(SktContact sender, SktEvents.OnContactAssignedPhone2LabelArgs e)</b></tt>
     */
    public String P_ASSIGNED_PHONE2_LABEL
    {
        get { if (!cache[40]) FetchAssignedPhone2LabelFromRuntime(); return cache_assigned_phone2_label; }
    }
    
    internal void FetchAssignedPhone2LabelFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE2_LABEL from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 187, this.OID);
        if (skypeRef.transport.PropResponseWasOk(187))
        {
            cache_assigned_phone2_label = skypeRef.decoder.DecodeString();
            cache[40] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone3</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone3(SktContact sender, SktEvents.OnContactAssignedPhone3Args e)</b></tt>
     */
    public String P_ASSIGNED_PHONE3
    {
        get { if (!cache[41]) FetchAssignedPhone3FromRuntime(); return cache_assigned_phone3; }
    }
    
    internal void FetchAssignedPhone3FromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE3 from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 188, this.OID);
        if (skypeRef.transport.PropResponseWasOk(188))
        {
            cache_assigned_phone3 = skypeRef.decoder.DecodeString();
            cache[41] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktContact.SetPhoneNumber method for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactAssignedPhone3Label</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactAssignedPhone3Label(SktContact sender, SktEvents.OnContactAssignedPhone3LabelArgs e)</b></tt>
     */
    public String P_ASSIGNED_PHONE3_LABEL
    {
        get { if (!cache[42]) FetchAssignedPhone3LabelFromRuntime(); return cache_assigned_phone3_label; }
    }
    
    internal void FetchAssignedPhone3LabelFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ASSIGNED_PHONE3_LABEL from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 189, this.OID);
        if (skypeRef.transport.PropResponseWasOk(189))
        {
            cache_assigned_phone3_label = skypeRef.decoder.DecodeString();
            cache[42] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Contact's order by presence popularity.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactPopularityOrd</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactPopularityOrd(SktContact sender, SktEvents.OnContactPopularityOrdArgs e)</b></tt>
     */
    public uint P_POPULARITY_ORD
    {
        get { if (!cache[43]) FetchPopularityOrdFromRuntime(); return cache_popularity_ord; }
    }
    
    internal void FetchPopularityOrdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_POPULARITY_ORD from runtime");
        skypeRef.transport.SubmitPropertyRequest(2, 42, this.OID);
        if (skypeRef.transport.PropResponseWasOk(42))
        {
            cache_popularity_ord = skypeRef.decoder.DecodeUint();
            cache[43] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktContact class PropKeys */
    
    public enum PropKeys 
    {
        P_TYPE                   =  202,
        P_SKYPENAME              =    4,
        P_PSTNNUMBER             =    6,
        P_FULLNAME               =    5,
        P_BIRTHDAY               =    7,
        P_GENDER                 =    8,
        P_LANGUAGES              =    9,
        P_COUNTRY                =   10,
        P_PROVINCE               =   11,
        P_CITY                   =   12,
        P_PHONE_HOME             =   13,
        P_PHONE_OFFICE           =   14,
        P_PHONE_MOBILE           =   15,
        P_EMAILS                 =   16,
        P_HOMEPAGE               =   17,
        P_ABOUT                  =   18,
        P_AVATAR_IMAGE           =   37,
        P_MOOD_TEXT              =   26,
        P_RICH_MOOD_TEXT         =  205,
        P_TIMEZONE               =   27,
        P_CAPABILITIES           =   36,
        P_PROFILE_TIMESTAMP      =   19,
        P_NROF_AUTHED_BUDDIES    =   28,
        P_IPCOUNTRY              =   29,
        P_AVATAR_TIMESTAMP       =  182,
        P_MOOD_TIMESTAMP         =  183,
        P_RECEIVED_AUTHREQUEST   =   20,
        P_AUTHREQ_TIMESTAMP      =   25,
        P_LASTONLINE_TIMESTAMP   =   35,
        P_AVAILABILITY           =   34,
        P_DISPLAYNAME            =   21,
        P_REFRESHING             =   22,
        P_GIVEN_AUTHLEVEL        =   23,
        P_GIVEN_DISPLAYNAME      =   33,
        P_ASSIGNED_COMMENT       =  180,
        P_LASTUSED_TIMESTAMP     =   39,
        P_AUTHREQUEST_COUNT      =   41,
        P_ASSIGNED_PHONE1        =  184,
        P_ASSIGNED_PHONE1_LABEL  =  185,
        P_ASSIGNED_PHONE2        =  186,
        P_ASSIGNED_PHONE2_LABEL  =  187,
        P_ASSIGNED_PHONE3        =  188,
        P_ASSIGNED_PHONE3_LABEL  =  189,
        P_POPULARITY_ORD         =   42 
    }
    
    /* SktContact class enums */
    
    /**  Same as with CAPABILITY, enumerator is used by both Contact and Account objects.
     */
    public enum TYPE
    {
        UNRECOGNIZED       =    0, /*!< Contact/account has no pre-identified type. This type is reported by default for SkypeKit clients.   */
        SKYPE              =    1, /*!< Normal Skype contact.   */
        PSTN               =    2, /*!< Normal PSTN contact.   */
        EMERGENCY_PSTN     =    3, /*!< Emergency number (i.e. 911).   */
        FREE_PSTN          =    4, /*!<   */
        UNDISCLOSED_PSTN   =    5, /*!< Undisclosed PSTN number.   */
        EXTERNAL           =    6  /*!< This type is currently used by Windows desktop clients for contacts imported from Outlook.   */
    }
    
    /**  Describes the recognized relational states between a local account and a remote contact.
     */
    public enum AUTHLEVEL
    {
        NONE               =    0, /*!< Authorization request is either ignored or pending. In this state several functionalities may be blocked, depending on settings. For example, accounts may only allow seeing online presence to be viewable or only receive calls from authorized contacts.   */
        AUTHORIZED_BY_ME   =    1, /*!< Contact has been authorized by the local account.   */
        BLOCKED_BY_ME      =    2  /*!< Contact has been blocked by the local account. This prevents incoming calls, chat messages, additional authorization requests etc.   */
    }
    
    /**  Describes the superset list of possible Account and Contact online statuses. In case of Account they
      apply to local user, in case of Contact they apply to remote contacts.
     */
    public enum AVAILABILITY
    {
        UNKNOWN                      =    0, /*!< Contact online status cannot be determined. This availability state should not normally reach the SkypeKit UI level.   */
        PENDINGAUTH                  =    8, /*!< Seeing Contact online status is blocked because authorization between contact and local account has not taken place.   */
        BLOCKED                      =    9, /*!< Remote contact has been blocked by local account. This applies to online accounts.   */
        BLOCKED_SKYPEOUT             =   11, /*!< Remote SkypeOut contact has been blocked by local account.   */
        SKYPEOUT                     =   10, /*!< Contact does not have an online status because he is a PSTN contact.   */
        OFFLINE                      =    1, /*!< Contact appears to be offline.   */
        OFFLINE_BUT_VM_ABLE          =   12, /*!< Contact appears to be offline but has voicemail enabled.   */
        OFFLINE_BUT_CF_ABLE          =   13, /*!< Contact appears to be offline but has enabled call forwarding, so calls may actually get through to him.   */
        ONLINE                       =    2, /*!< Contact / Account is online   */
        AWAY                         =    3, /*!< Contact / Account is online but away from keyboard. This can be either turned on manually or by automatic timer. In Windows desktop client, the timer can be configured with minute precision.   */
        NOT_AVAILABLE                =    4, /*!< This online status is marked as deprecated. If a remote contact indicates its status as NOT_AVAILABLE, the UI should handle this as equivalent of AWAY status.   */
        DO_NOT_DISTURB               =    5, /*!< Contact / Account is online but does not wish to be disturbed. This status supersedes AWAY status when the account is DO_NOT_DISTURB the AWAY timer should not modify the status.   */
        SKYPE_ME                     =    7, /*!< This online status is marked as deprecated. If a remote contact indicates its status as SKYPE_ME, the UI should handle this as equivalent of ONLINE status.   */
        INVISIBLE                    =    6, /*!< Account status is set to INVISIBLE. This status in not applicable to remote Contacts. When the remote contact has set his availability to INVISIBLE, he will appear as OFFLINE to others.   */
        CONNECTING                   =   14, /*!< only possible for local user/account */
        ONLINE_FROM_MOBILE           =   15, /*!<   */
        AWAY_FROM_MOBILE             =   16, /*!< *_FROM_MOBILE only possible for remote user */
        NOT_AVAILABLE_FROM_MOBILE    =   17, /*!<   */
        DO_NOT_DISTURB_FROM_MOBILE   =   18, /*!<   */
        SKYPE_ME_FROM_MOBILE         =   20  /*!<   */
    }
    
    /**  EXTRA_AUTHREQ_FIELDS
     */
    public enum EXTRA_AUTHREQ_FIELDS
    {
        SEND_VERIFIED_EMAIL     =    1, /*!< send verified e-mail blob with this auth request */
        SEND_VERIFIED_COMPANY   =    2  /*!< send verified company blob with this auth request */
    }
    
    /**  This enumerator is used by both Contact and Account objects. Thus the items here can have slightly different
      meaning, depending on which context you will examine their values. In case of Contact, the values apply
      to a user - across all the instances that user has logged in with Skype. In case of Account, the capability
      is that of a local, currently logged in instance of Skype client. The values that CAPABILITY items can have are also dependant on class context. In context of Contact,
      a capability can be CAPABILITY_MIXED. Which in case of CAPABILITY_VIDEO, for example, would mean that
      the remote use has logged in with different clients, some of which support video calls and some of which
      don't. In context of Account - there are no mixed result. Currently logged in Skype instance either supports
      video or it doesn't.
     */
    public enum CAPABILITY
    {
        CAPABILITY_VOICEMAIL            =    0, /*!< For Account object, this is the same as CAPABILITY_CAN_BE_SENT_VM - it indicates that the currently logged in Skype instance supports voicemails. For Contact objects, it means that their remote system supports sending voicemails - there is no technical method for Skype to detect whether they are capable of receiving voicemails, so the assumption is that they can.   */
        CAPABILITY_SKYPEOUT             =    1, /*!< Indicates that the contact/account has SkypeOut and is thus capable of making PSTN calls.   */
        CAPABILITY_SKYPEIN              =    2, /*!< Indicates that the contact/account has SkypeIn and is thus capable of answering PSTN calls.   */
        CAPABILITY_CAN_BE_SENT_VM       =    3, /*!< For contacts, this is a combination of CAPABILITY_VOICEMAIL for local account (local Skype client supports sending voicemails) and CAPABILITY_VOICEMAIL of the Contact - if the contact supports sending voicemails then hopefully they can also receive them.   */
        CAPABILITY_CALL_FORWARD         =    4, /*!< Indicates that Account/Contact supports call forwarding.   */
        CAPABILITY_VIDEO                =    5, /*!< Indicates that Account/Contact supports call video calls.   */
        CAPABILITY_TEXT                 =    6, /*!< In context of Contact, this indicates that the user is noticed running at least one Skype implementation that supports text messaging. Basically, it applies to a user. When applied to Account, the meaning is slightly different. In that case it indicates that currently running Skype implementation supports chat messaging. So, for Account objects, this is a node (rather than user) capability.   */
        CAPABILITY_SERVICE_PROVIDER     =    7, /*!< Indicates that the contact/account is flagged as SkypePrime service provider. This is linked to Account class SERVICE_PROVIDER_INFO property.   */
        CAPABILITY_LARGE_CONFERENCE     =    8, /*!< This is a legacy item, from the old times when conference calls with more than 5 people were limited to SkypePro accounts. In other words, this item is no longer relevant and will likely be removed at some point in future.   */
        CAPABILITY_COMMERCIAL_CONTACT   =    9, /*!<   */
        CAPABILITY_PSTN_TRANSFER        =   10, /*!< Indicates that Account/Contact supports call transfers to PSTN numbers.   */
        CAPABILITY_TEXT_EVER            =   11, /*!< Indicates that the user has had his chat capability removed by Skype. Basically, this means that the user is reported as spammer too many times. This applies for both Contact and Account objects - which means your client can check locally, if the currently logged in user has been marked as a spammer.   */
        CAPABILITY_VOICE_EVER           =   12, /*!< Indicates that the user (Account or Contact) has had his voice call capability removed by Skype.   */
        CAPABILITY_MOBILE_DEVICE        =   13, /*!< Indicates that the instance of Skype client Account/Contact is or in Contact's case has at least occasionally been flagged as a mobile device.   */
        CAPABILITY_PUBLIC_CONTACT       =   14  /*!<   */
    }
    
    /**  List of possible states of each of the Contact class CAPABILITY items.
     */
    public enum CAPABILITYSTATUS
    {
        NO_CAPABILITY       =    0, /*!< Contact does not have the capability   */
        CAPABILITY_MIXED    =    1, /*!< Contact has occasionally logged in with Skype client that supports the capability. For example, a contact may have Skype client on several machines, only some of which have webcam - in which case CAPABILITY_VIDEO would have its value set as CAPABILITY_MIXED.   */
        CAPABILITY_EXISTS   =    2  /*!< Contact has the capability   */
    }
    
    /* SktContact class methods */
    
    /** 
        @returns identity returns CONTACT_SKYPENAME or CONTACT_PSTNNUMBER value
     */
    public String GetIdentity ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GetIdentity");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.GetIdentity");
        return (String)args[0];
    }
    
    /**  Returns Conrtact's avatar image (JPG).
        @param [out] present @li true: the Contact has a custom avatar image @li false: the Contact does not have a custom avatar image 
        @param [out] avatar The avatar image data (JPG). If present is false, this will be the Skype-assigned default avatar 
     */
    public void GetAvatar (out Boolean present, out byte[] avatar)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GetAvatar");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = false;
        args[1] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktContact.GetAvatar");
        present = (Boolean)args[0];
        avatar = (byte[])args[1];
    }
    
    /**  returns verified-by-Skype e-mail for this contact if exists and verifiable
        @returns email
     */
    public String GetVerifiedEmail ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GetVerifiedEmail");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.GetVerifiedEmail");
        return (String)args[0];
    }
    
    /**  returns verified-by-Skype company for this contact if exists and verifiable
        @returns company
     */
    public String GetVerifiedCompany ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GetVerifiedCompany");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.GetVerifiedCompany");
        return (String)args[0];
    }
    
    /**  Checks whether the contact is member of a contact group given in group reference argument.
        @returns result @li true: the Contact is a member of the target contact group @li false: the Contact is not a member of the target contact group 
        @param [in] group - The target contact group
     */
    public Boolean IsMemberOf (SktContactGroup group)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.IsMemberOf");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddObjectParam(1, group);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.IsMemberOf");
        return (Boolean)args[0];
    }
    
    /**  Checks whether the contact is member of a pre-defined contact group given in the TYPE argument (type
      for this property comes from the ContactGroup class).
        @returns result @li true: the Contact is a member of the target contact group @li false: the Contact is not a member of the target contact group 
        @param [in] groupType - The type designator of the target pre-defined contact group. For example, specify this parameter as
      SktContactGroup.TYPE.RECENTLY_CONTACTED_CONTACTS to determine if you've had a recent conversation with
      this Contact.
     */
    public Boolean IsMemberOfHardwiredGroup (SktContactGroup.TYPE groupType)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.IsMemberOfHardwiredGroup");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)groupType);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.IsMemberOfHardwiredGroup");
        return (Boolean)args[0];
    }
    
    /**  Blocks or unblocks any further incoming communication attempts from this contact.
        @param [in] blocked - @li true: block this contact @li false: unblock this contact
        @param [in] abuse - Optional parameter to report abuse by this Skype user when blocking this Contact. Note that you can
      specifiy this parameter as true only when blocking a Contact. Defaults to false if omitted. Default value is false
     */
    public void SetBlocked (Boolean blocked, Boolean abuse)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.SetBlocked");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 22, OID);
        skypeRef.encoder.AddBoolParam(1, blocked);
        skypeRef.encoder.AddBoolParam(2, abuse);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.SetBlocked");
    }
    
    /**  Rejects and removes a pending authorization request from this Contact.
     */
    public void IgnoreAuthRequest ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.IgnoreAuthRequest");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 21, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.IgnoreAuthRequest");
    }
    
    /**  sets CONTACT_GIVEN_DISPLAYNAME. clears if size(name)==0
        @param [in] name
     */
    public void GiveDisplayName (String name)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GiveDisplayName");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.encoder.AddStringParam(1, name);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.GiveDisplayName");
    }
    
    /**  Adds or removes this Contact from the ALL_BUDDIES hardwired group.
        @param [in] isMyBuddy - @li true: add this contact to the ALL_BUDDIES group @li false: delete contact from the ALL_BUDDIES
      group
        @param [in] syncAuth - This argument is deprecated and should not be used. Default value is true
     */
    public void SetBuddyStatus (Boolean isMyBuddy, Boolean syncAuth)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.SetBuddyStatus");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.encoder.AddBoolParam(1, isMyBuddy);
        skypeRef.encoder.AddBoolParam(2, syncAuth);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.SetBuddyStatus");
    }
    
    /**  Sends a contact authorization request to this user.
        @param [in] message - Text that typically introduces the requesting user and details the reason for the authorization request.
      This text will be set as SktMessage.P_BODY_XML property of the notification Message the remote user will
      receive upon getting the authortization request. While this can be the empty string, it cannot be null.
     
        @param [in] extras_bitmask - Indicates additional information to include with this authorization request: @li 0 (zero): do not include
      any additional information @li SEND_VERIFIED_EMAIL: include the requestor's verified e-mail address @li
      SEND_VERIFIED_COMPANY: include verified information regarding the requestor's company @li SEND_VERIFIED_EMAIL
      + SEND_VERIFIED_COMPANY: include both e-mail and company information Default value is 0
     */
    public void SendAuthRequest (String message, uint extras_bitmask)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.SendAuthRequest");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.encoder.AddStringParam(1, message);
        skypeRef.encoder.AddUintParam(2, extras_bitmask);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.SendAuthRequest");
    }
    
    /**  the contact has accepted my auth request
        @returns result
     */
    public Boolean HasAuthorizedMe ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.HasAuthorizedMe");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 14, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.HasAuthorizedMe");
        return (Boolean)args[0];
    }
    
    /**  Sets the three P_ASSIGNED_PHONEx and P_ASSIGNED_PHONEx_LABEL properties, where x reflects the value of
      num. Basically, this enables you to add up to 3 additional phone numbers to a contact, that can then
      be used for calling them, should they be offline. The P_ASSIGNED.. properties are Contact properties,
      not Account properties. These you can set for other people in local user's contact list. The values for these properties will synchronize over different
      instances the local user has logged in. This synchronization is not instantaneous. To force synchronization,
      re-login on both instances seems to work quite nicely. The Skype Windows desktop client uses the following
      conventions when interpreting and assigning values to these properties. While your solution can assign arbitrary values to these properties, we strongly
      recommend using these conventions to ensure interoperability with the Skype Windows desktop client. Keep
      in mind that the "number" of these property pairs has no relationship to how the Skype Windows client
      interprets their label property value strings. For example, the Skype Windows client will interpret P_ASSIGNED_PHONE3_LABEL
      as "Home" if its value is the string "0". Label strings: Populate the label properties with string representations
      of the numbers "0" through "3", rather than descriptive strings like "Home", "Mobile", and so forth. The Skype desktop clients interpret the numeric
      string values as: @li "0" (zero) - "Home" @li "1" (one) - "Office" @li "2" - "Mobile" @li "3" - "Other"
      Keep in mind that the "number" of a property pair has no relationship to its label string. For example,
      the Skype Windows client will interpret P_ASSIGNED_PHONE3_LABEL as "Home" if its value is the string
      "0". Phone number strings: The Skype Windows desktop client has distinct conventions for Skype Contacts
      and PSTN (SkypeOut) Contacts: any or all of the property pairs can be used for Skype Contacts; P_ASSIGNED_PHONE1 cannot be used for
      PSTN Contacts and P_ASSIGNED_PHONE1_LABEL has special meaning for PSTN Contacts. Specifically, the Skype
      desktop clients use P_ASSIGNED_PHONE1_LABEL as the label for a PSTN Contact's primary number (regardless of whether it's home, mobile, or office), and use P_PSTNNUMBER to hold the
      actual number.
        @param [in] num - The property pair being set, which must be in the range 1..3 Note that there are only three target
      slots here, for four ("0".."3") label values.
        @param [in] label - The label text for the property being set
        @param [in] number - The phone number for the property being set
     */
    public void SetPhoneNumber (
        uint   num,
        String label,
        String number)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.SetPhoneNumber");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 15, OID);
        skypeRef.encoder.AddUintParam(1, num);
        skypeRef.encoder.AddStringParam(2, label);
        skypeRef.encoder.AddStringParam(3, number);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.SetPhoneNumber");
    }
    
    /**  Retrieves a dialog conversation with the Contact.
        @returns conversation Retrieved dialog. 
     */
    public SktConversation OpenConversation ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.OpenConversation");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 17, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktContact.OpenConversation");
        return (SktConversation)args[0];
    }
    
    /**  Retrieves a SktContact.Capability value. Sets P_REFRESHING to true while querying from server. This method
      is functionally the same as SktContact.GetCapabilityStatus except that it returns a bool value rather
      than SktContact.CAPABILITYSTATUS
        @returns result @li true: the Contact has the target capability through at least one of the Skype clients they have logged into. Corresponds to CAPABILITY_MIXED and CAPABILITY_EXISTS @li false: the Contact does not have the target capability. Corresponds to NO_CAPABILITY 
        @param [in] capability - The target capability
        @param [in] queryServer - @li true: obtains the data from the p2p network/server, and sets P_REFRESHING to true for the duration
      @li false: obtains the data from the local client Default value is false
     */
    public Boolean HasCapability (SktContact.CAPABILITY capability, Boolean queryServer)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.HasCapability");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 18, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)capability);
        skypeRef.encoder.AddBoolParam(2, queryServer);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.HasCapability");
        return (Boolean)args[0];
    }
    
    /**  Retrieves a SktContact.Capability value. Sets P_REFRESHING to true while querying from server.
        @returns status Status of the target capability. 
        @param [in] capability - The target capability, see SktContact.Capability enumerator.
        @param [in] queryServer - @li true: obtains the data from the p2p network/server, and sets P_REFRESHING to true for the duration
      @li false: obtains the data from the local client Default value is false
     */
    public SktContact.CAPABILITYSTATUS GetCapabilityStatus (SktContact.CAPABILITY capability, Boolean queryServer)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.GetCapabilityStatus");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 19, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)capability);
        skypeRef.encoder.AddBoolParam(2, queryServer);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContact.GetCapabilityStatus");
        return (SktContact.CAPABILITYSTATUS)args[0];
    }
    
    /**  Refreshes all properties, capabilities, and statuses associated with this Contact from p2p/CBL, and sets
      P_REFRESHING to true for the duration.
     */
    public void RefreshProfile ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Contact.RefreshProfile");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 20, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContact.RefreshProfile");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Contact - the wrapper has no events for this class.");
    }
}

/*! \class SktConversation
  \brief
  The Conversation class encapsulates all types of communication possible with Skype client. Instant messaging,
  calls, video calls, file transfers, SMS, screen sharing - all take place within the context of a Conversation.
  Contacts are represented in Conversation as Participant objects. This also applies to contacts of PSTN
  type. All events in a conversation are represented as Message objects.
 @n <h2>Events</h2>
<tt>void <b>SktEvents.OnConversationParticipantListChange</b> (SktConversation sender, SktEvents.OnConversationParticipantListChangeArgs e)</tt>@n
 
  This callback gets fired when participants join or leave the conversation.
 
<hr />
 @n 
<tt>void <b>SktEvents.OnConversationMessage</b> (SktConversation sender, SktEvents.OnConversationMessageArgs e)</tt>@n
 
  Called for each message in currently loaded conversations
  @param message  (SktMessage)
 
<hr />
 @n 
<tt>void <b>SktEvents.OnConversationSpawnConference</b> (SktConversation sender, SktEvents.OnConversationSpawnConferenceArgs e)</tt>@n
 
  This callback gets fired when a new Conversation is created using SpawnConference.
  @param spawned  Conversation object that got created. (SktConversation)
 
<hr />
 @n 
 */
public class SktConversation : SktObject
{
    public override String ClassName { get { return "Conversation"; } }
    
    public override uint ClassId { get { return 18; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktConversation (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(32);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktConversation objects.
     */
    public class List : SktObjectList
    {
        new public SktConversation this[int index]
        {
            get { return (SktConversation)base[index]; }
        }

        public void Add(SktConversation item)
        {
            base.Add((SktConversation)item);
        }
    }
    

    /* SktConversation property cache fields */
    private volatile String                           cache_identity;
    private volatile SktConversation.TYPE             cache_type;
    private volatile String                           cache_live_host;
    private volatile uint                             cache_live_start_timestamp;
    private volatile Boolean                          cache_live_is_muted;
    private volatile String                           cache_alert_string;
    private volatile Boolean                          cache_is_bookmarked;
    private volatile String                           cache_given_displayname;
    private volatile String                           cache_displayname;
    private volatile SktConversation.LOCAL_LIVESTATUS cache_local_livestatus;
    private volatile uint                             cache_inbox_timestamp;
    private volatile SktMessage                       cache_inbox_message_id;
    private volatile uint                             cache_unconsumed_suppressed_messages;
    private volatile uint                             cache_unconsumed_normal_messages;
    private volatile uint                             cache_unconsumed_elevated_messages;
    private volatile Boolean                          cache_unconsumed_messages_voice;
    private volatile SktVoicemail                     cache_active_vm_id;
    private volatile uint                             cache_consumption_horizon;
    private volatile uint                             cache_last_activity_timestamp;
    private volatile SktConversation                  cache_spawned_from_convo_id;
    private volatile String                           cache_creator;
    private volatile uint                             cache_creation_timestamp;
    private volatile SktConversation.MY_STATUS        cache_my_status;
    private volatile Boolean                          cache_opt_joining_enabled;
    private volatile SktParticipant.RANK              cache_opt_entry_level_rank;
    private volatile Boolean                          cache_opt_disclose_history;
    private volatile SktConversation.ALLOWED_ACTIVITY cache_opt_admin_only_activities;
    private volatile String                           cache_passwordhint;
    private volatile String                           cache_meta_name;
    private volatile String                           cache_meta_topic;
    private volatile String                           cache_meta_guidelines;
    private volatile byte[]                           cache_meta_picture;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 973: return 9;
            case 971: return 9;
            case 915: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 972: /* Conversation.P_IDENTITY */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_identity = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_IDENTITY = " + cache_identity.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_IDENTITY - update without value");
                skypeRef.events.FireOnConversationIdentity(this, cache_identity);
                break;
                
            case 902: /* Conversation.P_TYPE */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktConversation.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_TYPE - update without value");
                skypeRef.events.FireOnConversationType(this, cache_type);
                break;
                
            case 918: /* Conversation.P_LIVE_HOST */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_host = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_HOST = " + cache_live_host.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_HOST - update without value");
                skypeRef.events.FireOnConversationLiveHost(this, cache_live_host);
                break;
                
            case 974: /* Conversation.P_LIVE_START_TIMESTAMP */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_start_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_START_TIMESTAMP = " + cache_live_start_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_START_TIMESTAMP - update without value");
                skypeRef.events.FireOnConversationLiveStartTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_live_start_timestamp));
                break;
                
            case 996: /* Conversation.P_LIVE_IS_MUTED */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_live_is_muted = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_IS_MUTED = " + cache_live_is_muted.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_LIVE_IS_MUTED - update without value");
                skypeRef.events.FireOnConversationLiveIsMuted(this, cache_live_is_muted);
                break;
                
            case 920: /* Conversation.P_ALERT_STRING */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_alert_string = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_ALERT_STRING = " + cache_alert_string.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_ALERT_STRING - update without value");
                skypeRef.events.FireOnConversationAlertString(this, cache_alert_string);
                break;
                
            case 921: /* Conversation.P_IS_BOOKMARKED */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_is_bookmarked = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_IS_BOOKMARKED = " + cache_is_bookmarked.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_IS_BOOKMARKED - update without value");
                skypeRef.events.FireOnConversationIsBookmarked(this, cache_is_bookmarked);
                break;
                
            case 925: /* Conversation.P_GIVEN_DISPLAYNAME */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_given_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_GIVEN_DISPLAYNAME = " + cache_given_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_GIVEN_DISPLAYNAME - update without value");
                skypeRef.events.FireOnConversationGivenDisplayname(this, cache_given_displayname);
                break;
                
            case 924: /* Conversation.P_DISPLAYNAME */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_displayname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_DISPLAYNAME = " + cache_displayname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_DISPLAYNAME - update without value");
                skypeRef.events.FireOnConversationDisplayname(this, cache_displayname);
                break;
                
            case 927: /* Conversation.P_LOCAL_LIVESTATUS */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_local_livestatus = (SktConversation.LOCAL_LIVESTATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_LOCAL_LIVESTATUS = " + cache_local_livestatus.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_LOCAL_LIVESTATUS - update without value");
                skypeRef.events.FireOnConversationLocalLivestatus(this, cache_local_livestatus);
                break;
                
            case 928: /* Conversation.P_INBOX_TIMESTAMP */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_inbox_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_INBOX_TIMESTAMP = " + cache_inbox_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_INBOX_TIMESTAMP - update without value");
                skypeRef.events.FireOnConversationInboxTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_inbox_timestamp));
                break;
                
            case 973: /* Conversation.P_INBOX_MESSAGE_ID */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_inbox_message_id = (SktMessage)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_INBOX_MESSAGE_ID = " + cache_inbox_message_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_INBOX_MESSAGE_ID - update without value");
                skypeRef.events.FireOnConversationInboxMessageId(this, cache_inbox_message_id);
                break;
                
            case 975: /* Conversation.P_UNCONSUMED_SUPPRESSED_MESSAGES */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_unconsumed_suppressed_messages = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_SUPPRESSED_MESSAGES = " + cache_unconsumed_suppressed_messages.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_SUPPRESSED_MESSAGES - update without value");
                skypeRef.events.FireOnConversationUnconsumedSuppressedMessages(this, cache_unconsumed_suppressed_messages);
                break;
                
            case 976: /* Conversation.P_UNCONSUMED_NORMAL_MESSAGES */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_unconsumed_normal_messages = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_NORMAL_MESSAGES = " + cache_unconsumed_normal_messages.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_NORMAL_MESSAGES - update without value");
                skypeRef.events.FireOnConversationUnconsumedNormalMessages(this, cache_unconsumed_normal_messages);
                break;
                
            case 977: /* Conversation.P_UNCONSUMED_ELEVATED_MESSAGES */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_unconsumed_elevated_messages = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_ELEVATED_MESSAGES = " + cache_unconsumed_elevated_messages.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_ELEVATED_MESSAGES - update without value");
                skypeRef.events.FireOnConversationUnconsumedElevatedMessages(this, cache_unconsumed_elevated_messages);
                break;
                
            case 970: /* Conversation.P_UNCONSUMED_MESSAGES_VOICE */
                cache[15] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_unconsumed_messages_voice = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_MESSAGES_VOICE = " + cache_unconsumed_messages_voice.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_UNCONSUMED_MESSAGES_VOICE - update without value");
                skypeRef.events.FireOnConversationUnconsumedMessagesVoice(this, cache_unconsumed_messages_voice);
                break;
                
            case 971: /* Conversation.P_ACTIVE_VM_ID */
                cache[16] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_active_vm_id = (SktVoicemail)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_ACTIVE_VM_ID = " + cache_active_vm_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_ACTIVE_VM_ID - update without value");
                skypeRef.events.FireOnConversationActiveVmId(this, cache_active_vm_id);
                break;
                
            case 979: /* Conversation.P_CONSUMPTION_HORIZON */
                cache[17] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_consumption_horizon = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_CONSUMPTION_HORIZON = " + cache_consumption_horizon.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_CONSUMPTION_HORIZON - update without value");
                skypeRef.events.FireOnConversationConsumptionHorizon(this, skypeRef.UnixTimestampToDateTime(cache_consumption_horizon));
                break;
                
            case 981: /* Conversation.P_LAST_ACTIVITY_TIMESTAMP */
                cache[18] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_last_activity_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_LAST_ACTIVITY_TIMESTAMP = " + cache_last_activity_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_LAST_ACTIVITY_TIMESTAMP - update without value");
                skypeRef.events.FireOnConversationLastActivityTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_last_activity_timestamp));
                break;
                
            case 915: /* Conversation.P_SPAWNED_FROM_CONVO_ID */
                cache[19] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_spawned_from_convo_id = (SktConversation)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_SPAWNED_FROM_CONVO_ID = " + cache_spawned_from_convo_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_SPAWNED_FROM_CONVO_ID - update without value");
                skypeRef.events.FireOnConversationSpawnedFromConvoId(this, cache_spawned_from_convo_id);
                break;
                
            case 903: /* Conversation.P_CREATOR */
                cache[20] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_creator = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_CREATOR = " + cache_creator.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_CREATOR - update without value");
                skypeRef.events.FireOnConversationCreator(this, cache_creator);
                break;
                
            case 904: /* Conversation.P_CREATION_TIMESTAMP */
                cache[21] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_creation_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_CREATION_TIMESTAMP = " + cache_creation_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_CREATION_TIMESTAMP - update without value");
                skypeRef.events.FireOnConversationCreationTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_creation_timestamp));
                break;
                
            case 919: /* Conversation.P_MY_STATUS */
                cache[22] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_my_status = (SktConversation.MY_STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_MY_STATUS = " + cache_my_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_MY_STATUS - update without value");
                skypeRef.events.FireOnConversationMyStatus(this, cache_my_status);
                break;
                
            case 922: /* Conversation.P_OPT_JOINING_ENABLED */
                cache[23] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_opt_joining_enabled = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_JOINING_ENABLED = " + cache_opt_joining_enabled.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_JOINING_ENABLED - update without value");
                skypeRef.events.FireOnConversationOptJoiningEnabled(this, cache_opt_joining_enabled);
                break;
                
            case 906: /* Conversation.P_OPT_ENTRY_LEVEL_RANK */
                cache[24] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_opt_entry_level_rank = (SktParticipant.RANK)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_ENTRY_LEVEL_RANK = " + cache_opt_entry_level_rank.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_ENTRY_LEVEL_RANK - update without value");
                skypeRef.events.FireOnConversationOptEntryLevelRank(this, cache_opt_entry_level_rank);
                break;
                
            case 907: /* Conversation.P_OPT_DISCLOSE_HISTORY */
                cache[25] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_opt_disclose_history = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_DISCLOSE_HISTORY = " + cache_opt_disclose_history.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_DISCLOSE_HISTORY - update without value");
                skypeRef.events.FireOnConversationOptDiscloseHistory(this, cache_opt_disclose_history);
                break;
                
            case 909: /* Conversation.P_OPT_ADMIN_ONLY_ACTIVITIES */
                cache[26] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_opt_admin_only_activities = (SktConversation.ALLOWED_ACTIVITY)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_ADMIN_ONLY_ACTIVITIES = " + cache_opt_admin_only_activities.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_OPT_ADMIN_ONLY_ACTIVITIES - update without value");
                skypeRef.events.FireOnConversationOptAdminOnlyActivities(this, cache_opt_admin_only_activities);
                break;
                
            case 980: /* Conversation.P_PASSWORDHINT */
                cache[27] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_passwordhint = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_PASSWORDHINT = " + cache_passwordhint.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_PASSWORDHINT - update without value");
                skypeRef.events.FireOnConversationPasswordhint(this, cache_passwordhint);
                break;
                
            case 910: /* Conversation.P_META_NAME */
                cache[28] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_meta_name = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_META_NAME = " + cache_meta_name.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_META_NAME - update without value");
                skypeRef.events.FireOnConversationMetaName(this, cache_meta_name);
                break;
                
            case 911: /* Conversation.P_META_TOPIC */
                cache[29] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_meta_topic = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_META_TOPIC = " + cache_meta_topic.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_META_TOPIC - update without value");
                skypeRef.events.FireOnConversationMetaTopic(this, cache_meta_topic);
                break;
                
            case 913: /* Conversation.P_META_GUIDELINES */
                cache[30] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_meta_guidelines = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_META_GUIDELINES = " + cache_meta_guidelines.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_META_GUIDELINES - update without value");
                skypeRef.events.FireOnConversationMetaGuidelines(this, cache_meta_guidelines);
                break;
                
            case 914: /* Conversation.P_META_PICTURE */
                cache[31] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_meta_picture = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Conversation.P_META_PICTURE = binary size " + cache_meta_picture.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Conversation.P_META_PICTURE - update without value");
                skypeRef.events.FireOnConversationMetaPicture(this, cache_meta_picture);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Conversation class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktConversation property accessors **/
    
    /**  contact identity in case of dialogs, chat name in case of conferences
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationIdentity</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationIdentity(SktConversation sender, SktEvents.OnConversationIdentityArgs e)</b></tt>
     */
    public String P_IDENTITY
    {
        get { if (!cache[0]) FetchIdentityFromRuntime(); return cache_identity; }
    }
    
    internal void FetchIdentityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IDENTITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 972, this.OID);
        if (skypeRef.transport.PropResponseWasOk(972))
        {
            cache_identity = skypeRef.decoder.DecodeString();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  type of the conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationType(SktConversation sender, SktEvents.OnConversationTypeArgs e)</b></tt>
     */
    public SktConversation.TYPE P_TYPE
    {
        get { if (!cache[1]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 902, this.OID);
        if (skypeRef.transport.PropResponseWasOk(902))
        {
            cache_type = (SktConversation.TYPE)skypeRef.decoder.DecodeUint();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  host of current live session. none => no session. myself in case of 1:1 calls
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationLiveHost</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationLiveHost(SktConversation sender, SktEvents.OnConversationLiveHostArgs e)</b></tt>
     */
    public String P_LIVE_HOST
    {
        get { if (!cache[2]) FetchLiveHostFromRuntime(); return cache_live_host; }
    }
    
    internal void FetchLiveHostFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_HOST from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 918, this.OID);
        if (skypeRef.transport.PropResponseWasOk(918))
        {
            cache_live_host = skypeRef.decoder.DecodeString();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  moment when first participant other than host joined the current or last live session
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationLiveStartTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationLiveStartTimestamp(SktConversation sender, SktEvents.OnConversationLiveStartTimestampArgs e)</b></tt>
     */
    public DateTime P_LIVE_START_TIMESTAMP
    {
        get { if (!cache[3]) FetchLiveStartTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_live_start_timestamp); }
    }
    
    internal void FetchLiveStartTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_START_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 974, this.OID);
        if (skypeRef.transport.PropResponseWasOk(974))
        {
            cache_live_start_timestamp = skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if live session is muted
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationLiveIsMuted</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationLiveIsMuted(SktConversation sender, SktEvents.OnConversationLiveIsMutedArgs e)</b></tt>
     */
    public Boolean P_LIVE_IS_MUTED
    {
        get { if (!cache[4]) FetchLiveIsMutedFromRuntime(); return cache_live_is_muted; }
    }
    
    internal void FetchLiveIsMutedFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LIVE_IS_MUTED from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 996, this.OID);
        if (skypeRef.transport.PropResponseWasOk(996))
        {
            cache_live_is_muted = skypeRef.decoder.DecodeBool();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  '' everything matches, '=' nothing matches, '=string' string matches
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationAlertString</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationAlertString(SktConversation sender, SktEvents.OnConversationAlertStringArgs e)</b></tt>
     */
    public String P_ALERT_STRING
    {
        get { if (!cache[5]) FetchAlertStringFromRuntime(); return cache_alert_string; }
    }
    
    internal void FetchAlertStringFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ALERT_STRING from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 920, this.OID);
        if (skypeRef.transport.PropResponseWasOk(920))
        {
            cache_alert_string = skypeRef.decoder.DecodeString();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if conversation is bookmarked/flagged
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationIsBookmarked</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationIsBookmarked(SktConversation sender, SktEvents.OnConversationIsBookmarkedArgs e)</b></tt>
     */
    public Boolean P_IS_BOOKMARKED
    {
        get { if (!cache[6]) FetchIsBookmarkedFromRuntime(); return cache_is_bookmarked; }
    }
    
    internal void FetchIsBookmarkedFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IS_BOOKMARKED from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 921, this.OID);
        if (skypeRef.transport.PropResponseWasOk(921))
        {
            cache_is_bookmarked = skypeRef.decoder.DecodeBool();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  local name assigned via Rename
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationGivenDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationGivenDisplayname(SktConversation sender, SktEvents.OnConversationGivenDisplaynameArgs e)</b></tt>
     */
    public String P_GIVEN_DISPLAYNAME
    {
        get { if (!cache[7]) FetchGivenDisplaynameFromRuntime(); return cache_given_displayname; }
    }
    
    internal void FetchGivenDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GIVEN_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 925, this.OID);
        if (skypeRef.transport.PropResponseWasOk(925))
        {
            cache_given_displayname = skypeRef.decoder.DecodeString();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  resulting display name of the conversation (based on given name, topic, participant list, etc)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationDisplayname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationDisplayname(SktConversation sender, SktEvents.OnConversationDisplaynameArgs e)</b></tt>
     */
    public String P_DISPLAYNAME
    {
        get { if (!cache[8]) FetchDisplaynameFromRuntime(); return cache_displayname; }
    }
    
    internal void FetchDisplaynameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_DISPLAYNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 924, this.OID);
        if (skypeRef.transport.PropResponseWasOk(924))
        {
            cache_displayname = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if the conversation is live and in which status it is then
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationLocalLivestatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationLocalLivestatus(SktConversation sender, SktEvents.OnConversationLocalLivestatusArgs e)</b></tt>
     */
    public SktConversation.LOCAL_LIVESTATUS P_LOCAL_LIVESTATUS
    {
        get { if (!cache[9]) FetchLocalLivestatusFromRuntime(); return cache_local_livestatus; }
    }
    
    internal void FetchLocalLivestatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LOCAL_LIVESTATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 927, this.OID);
        if (skypeRef.transport.PropResponseWasOk(927))
        {
            cache_local_livestatus = (SktConversation.LOCAL_LIVESTATUS)skypeRef.decoder.DecodeUint();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  timestamp to sort the conversations in inbox by. 0 means not in inbox
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationInboxTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationInboxTimestamp(SktConversation sender, SktEvents.OnConversationInboxTimestampArgs e)</b></tt>
     */
    public DateTime P_INBOX_TIMESTAMP
    {
        get { if (!cache[10]) FetchInboxTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_inbox_timestamp); }
    }
    
    internal void FetchInboxTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_INBOX_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 928, this.OID);
        if (skypeRef.transport.PropResponseWasOk(928))
        {
            cache_inbox_timestamp = skypeRef.decoder.DecodeUint();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ID of the message that caused INBOX_TIMESTAMP to be set
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationInboxMessageId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationInboxMessageId(SktConversation sender, SktEvents.OnConversationInboxMessageIdArgs e)</b></tt>
     */
    public SktMessage P_INBOX_MESSAGE_ID
    {
        get { if (!cache[11]) FetchInboxMessageIdFromRuntime(); return cache_inbox_message_id; }
    }
    
    internal void FetchInboxMessageIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_INBOX_MESSAGE_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 973, this.OID);
        if (skypeRef.transport.PropResponseWasOk(973))
        {
            cache_inbox_message_id = (SktMessage)skypeRef.decoder.DecodeObject(9); // SktMessage class ID = 9
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  number of messages in UNCONSUMED_SUPPRESSED consumption status
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationUnconsumedSuppressedMessages</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationUnconsumedSuppressedMessages(SktConversation sender, SktEvents.OnConversationUnconsumedSuppressedMessagesArgs e)</b></tt>
     */
    public uint P_UNCONSUMED_SUPPRESSED_MESSAGES
    {
        get { if (!cache[12]) FetchUnconsumedSuppressedMessagesFromRuntime(); return cache_unconsumed_suppressed_messages; }
    }
    
    internal void FetchUnconsumedSuppressedMessagesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_UNCONSUMED_SUPPRESSED_MESSAGES from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 975, this.OID);
        if (skypeRef.transport.PropResponseWasOk(975))
        {
            cache_unconsumed_suppressed_messages = skypeRef.decoder.DecodeUint();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  number of messages in UNCONSUMED_NORMAL consumption status
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationUnconsumedNormalMessages</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationUnconsumedNormalMessages(SktConversation sender, SktEvents.OnConversationUnconsumedNormalMessagesArgs e)</b></tt>
     */
    public uint P_UNCONSUMED_NORMAL_MESSAGES
    {
        get { if (!cache[13]) FetchUnconsumedNormalMessagesFromRuntime(); return cache_unconsumed_normal_messages; }
    }
    
    internal void FetchUnconsumedNormalMessagesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_UNCONSUMED_NORMAL_MESSAGES from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 976, this.OID);
        if (skypeRef.transport.PropResponseWasOk(976))
        {
            cache_unconsumed_normal_messages = skypeRef.decoder.DecodeUint();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  DEPRECATED, not set anymore
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationUnconsumedElevatedMessages</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationUnconsumedElevatedMessages(SktConversation sender, SktEvents.OnConversationUnconsumedElevatedMessagesArgs e)</b></tt>
     */
    public uint P_UNCONSUMED_ELEVATED_MESSAGES
    {
        get { if (!cache[14]) FetchUnconsumedElevatedMessagesFromRuntime(); return cache_unconsumed_elevated_messages; }
    }
    
    internal void FetchUnconsumedElevatedMessagesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_UNCONSUMED_ELEVATED_MESSAGES from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 977, this.OID);
        if (skypeRef.transport.PropResponseWasOk(977))
        {
            cache_unconsumed_elevated_messages = skypeRef.decoder.DecodeUint();
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if there are unconsumed voice or call messages in the conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationUnconsumedMessagesVoice</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationUnconsumedMessagesVoice(SktConversation sender, SktEvents.OnConversationUnconsumedMessagesVoiceArgs e)</b></tt>
     */
    public Boolean P_UNCONSUMED_MESSAGES_VOICE
    {
        get { if (!cache[15]) FetchUnconsumedMessagesVoiceFromRuntime(); return cache_unconsumed_messages_voice; }
    }
    
    internal void FetchUnconsumedMessagesVoiceFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_UNCONSUMED_MESSAGES_VOICE from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 970, this.OID);
        if (skypeRef.transport.PropResponseWasOk(970))
        {
            cache_unconsumed_messages_voice = skypeRef.decoder.DecodeBool();
            cache[15] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ID of voice message that is being played or recorded in this conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationActiveVmId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationActiveVmId(SktConversation sender, SktEvents.OnConversationActiveVmIdArgs e)</b></tt>
     */
    public SktVoicemail P_ACTIVE_VM_ID
    {
        get { if (!cache[16]) FetchActiveVmIdFromRuntime(); return cache_active_vm_id; }
    }
    
    internal void FetchActiveVmIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ACTIVE_VM_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 971, this.OID);
        if (skypeRef.transport.PropResponseWasOk(971))
        {
            cache_active_vm_id = (SktVoicemail)skypeRef.decoder.DecodeObject(7); // SktVoicemail class ID = 7
            cache[16] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  consumption cutoff timestamp: messages after (but not including) this are considered unconsumed
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationConsumptionHorizon</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationConsumptionHorizon(SktConversation sender, SktEvents.OnConversationConsumptionHorizonArgs e)</b></tt>
     */
    public DateTime P_CONSUMPTION_HORIZON
    {
        get { if (!cache[17]) FetchConsumptionHorizonFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_consumption_horizon); }
    }
    
    internal void FetchConsumptionHorizonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONSUMPTION_HORIZON from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 979, this.OID);
        if (skypeRef.transport.PropResponseWasOk(979))
        {
            cache_consumption_horizon = skypeRef.decoder.DecodeUint();
            cache[17] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  timestamp of last activity in conversation
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationLastActivityTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationLastActivityTimestamp(SktConversation sender, SktEvents.OnConversationLastActivityTimestampArgs e)</b></tt>
     */
    public DateTime P_LAST_ACTIVITY_TIMESTAMP
    {
        get { if (!cache[18]) FetchLastActivityTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_last_activity_timestamp); }
    }
    
    internal void FetchLastActivityTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LAST_ACTIVITY_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 981, this.OID);
        if (skypeRef.transport.PropResponseWasOk(981))
        {
            cache_last_activity_timestamp = skypeRef.decoder.DecodeUint();
            cache[18] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  dialog this conference was spawned from
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationSpawnedFromConvoId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationSpawnedFromConvoId(SktConversation sender, SktEvents.OnConversationSpawnedFromConvoIdArgs e)</b></tt>
     */
    public SktConversation P_SPAWNED_FROM_CONVO_ID
    {
        get { if (!cache[19]) FetchSpawnedFromConvoIdFromRuntime(); return cache_spawned_from_convo_id; }
    }
    
    internal void FetchSpawnedFromConvoIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SPAWNED_FROM_CONVO_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 915, this.OID);
        if (skypeRef.transport.PropResponseWasOk(915))
        {
            cache_spawned_from_convo_id = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
            cache[19] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  identity of conversation creator (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationCreator</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationCreator(SktConversation sender, SktEvents.OnConversationCreatorArgs e)</b></tt>
     */
    public String P_CREATOR
    {
        get { if (!cache[20]) FetchCreatorFromRuntime(); return cache_creator; }
    }
    
    internal void FetchCreatorFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CREATOR from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 903, this.OID);
        if (skypeRef.transport.PropResponseWasOk(903))
        {
            cache_creator = skypeRef.decoder.DecodeString();
            cache[20] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  timestamp of creation, tells you how far you can retrieve messages
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationCreationTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationCreationTimestamp(SktConversation sender, SktEvents.OnConversationCreationTimestampArgs e)</b></tt>
     */
    public DateTime P_CREATION_TIMESTAMP
    {
        get { if (!cache[21]) FetchCreationTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_creation_timestamp); }
    }
    
    internal void FetchCreationTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CREATION_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 904, this.OID);
        if (skypeRef.transport.PropResponseWasOk(904))
        {
            cache_creation_timestamp = skypeRef.decoder.DecodeUint();
            cache[21] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  my status in this conversation (connecting, participating, retired, etc) (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationMyStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationMyStatus(SktConversation sender, SktEvents.OnConversationMyStatusArgs e)</b></tt>
     */
    public SktConversation.MY_STATUS P_MY_STATUS
    {
        get { if (!cache[22]) FetchMyStatusFromRuntime(); return cache_my_status; }
    }
    
    internal void FetchMyStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MY_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 919, this.OID);
        if (skypeRef.transport.PropResponseWasOk(919))
        {
            cache_my_status = (SktConversation.MY_STATUS)skypeRef.decoder.DecodeUint();
            cache[22] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if it's a public conversation (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationOptJoiningEnabled</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationOptJoiningEnabled(SktConversation sender, SktEvents.OnConversationOptJoiningEnabledArgs e)</b></tt>
     */
    public Boolean P_OPT_JOINING_ENABLED
    {
        get { if (!cache[23]) FetchOptJoiningEnabledFromRuntime(); return cache_opt_joining_enabled; }
    }
    
    internal void FetchOptJoiningEnabledFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OPT_JOINING_ENABLED from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 922, this.OID);
        if (skypeRef.transport.PropResponseWasOk(922))
        {
            cache_opt_joining_enabled = skypeRef.decoder.DecodeBool();
            cache[23] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  rank that is auto-assigned at join (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationOptEntryLevelRank</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationOptEntryLevelRank(SktConversation sender, SktEvents.OnConversationOptEntryLevelRankArgs e)</b></tt>
     */
    public SktParticipant.RANK P_OPT_ENTRY_LEVEL_RANK
    {
        get { if (!cache[24]) FetchOptEntryLevelRankFromRuntime(); return cache_opt_entry_level_rank; }
    }
    
    internal void FetchOptEntryLevelRankFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OPT_ENTRY_LEVEL_RANK from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 906, this.OID);
        if (skypeRef.transport.PropResponseWasOk(906))
        {
            cache_opt_entry_level_rank = (SktParticipant.RANK)skypeRef.decoder.DecodeUint();
            cache[24] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  if history visible to new consumers (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationOptDiscloseHistory</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationOptDiscloseHistory(SktConversation sender, SktEvents.OnConversationOptDiscloseHistoryArgs e)</b></tt>
     */
    public Boolean P_OPT_DISCLOSE_HISTORY
    {
        get { if (!cache[25]) FetchOptDiscloseHistoryFromRuntime(); return cache_opt_disclose_history; }
    }
    
    internal void FetchOptDiscloseHistoryFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OPT_DISCLOSE_HISTORY from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 907, this.OID);
        if (skypeRef.transport.PropResponseWasOk(907))
        {
            cache_opt_disclose_history = skypeRef.decoder.DecodeBool();
            cache[25] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  activities that only ADMIN can do. Bitmap of ALLOWED_ACTIVITY values (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationOptAdminOnlyActivities</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationOptAdminOnlyActivities(SktConversation sender, SktEvents.OnConversationOptAdminOnlyActivitiesArgs e)</b></tt>
     */
    public SktConversation.ALLOWED_ACTIVITY P_OPT_ADMIN_ONLY_ACTIVITIES
    {
        get { if (!cache[26]) FetchOptAdminOnlyActivitiesFromRuntime(); return cache_opt_admin_only_activities; }
    }
    
    internal void FetchOptAdminOnlyActivitiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OPT_ADMIN_ONLY_ACTIVITIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 909, this.OID);
        if (skypeRef.transport.PropResponseWasOk(909))
        {
            cache_opt_admin_only_activities = (SktConversation.ALLOWED_ACTIVITY)skypeRef.decoder.DecodeUint();
            cache[26] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  public conversation password hint, use SetPassword to set (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationPasswordhint</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationPasswordhint(SktConversation sender, SktEvents.OnConversationPasswordhintArgs e)</b></tt>
     */
    public String P_PASSWORDHINT
    {
        get { if (!cache[27]) FetchPasswordhintFromRuntime(); return cache_passwordhint; }
    }
    
    internal void FetchPasswordhintFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PASSWORDHINT from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 980, this.OID);
        if (skypeRef.transport.PropResponseWasOk(980))
        {
            cache_passwordhint = skypeRef.decoder.DecodeString();
            cache[27] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  deprecated, not used
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationMetaName</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationMetaName(SktConversation sender, SktEvents.OnConversationMetaNameArgs e)</b></tt>
     */
    public String P_META_NAME
    {
        get { if (!cache[28]) FetchMetaNameFromRuntime(); return cache_meta_name; }
    }
    
    internal void FetchMetaNameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_META_NAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 910, this.OID);
        if (skypeRef.transport.PropResponseWasOk(910))
        {
            cache_meta_name = skypeRef.decoder.DecodeString();
            cache[28] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  conversation topic (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationMetaTopic</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationMetaTopic(SktConversation sender, SktEvents.OnConversationMetaTopicArgs e)</b></tt>
     */
    public String P_META_TOPIC
    {
        get { if (!cache[29]) FetchMetaTopicFromRuntime(); return cache_meta_topic; }
    }
    
    internal void FetchMetaTopicFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_META_TOPIC from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 911, this.OID);
        if (skypeRef.transport.PropResponseWasOk(911))
        {
            cache_meta_topic = skypeRef.decoder.DecodeXML();
            cache[29] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  guidelines (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationMetaGuidelines</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationMetaGuidelines(SktConversation sender, SktEvents.OnConversationMetaGuidelinesArgs e)</b></tt>
     */
    public String P_META_GUIDELINES
    {
        get { if (!cache[30]) FetchMetaGuidelinesFromRuntime(); return cache_meta_guidelines; }
    }
    
    internal void FetchMetaGuidelinesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_META_GUIDELINES from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 913, this.OID);
        if (skypeRef.transport.PropResponseWasOk(913))
        {
            cache_meta_guidelines = skypeRef.decoder.DecodeXML();
            cache[30] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  conversation picture, in jpeg format (doesn't apply to dialogs)
     @n Assign your own event handler method to the <tt><b>skype.events.OnConversationMetaPicture</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnConversationMetaPicture(SktConversation sender, SktEvents.OnConversationMetaPictureArgs e)</b></tt>
     */
    public byte[] P_META_PICTURE
    {
        get { if (!cache[31]) FetchMetaPictureFromRuntime(); return cache_meta_picture; }
    }
    
    internal void FetchMetaPictureFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_META_PICTURE from runtime");
        skypeRef.transport.SubmitPropertyRequest(18, 914, this.OID);
        if (skypeRef.transport.PropResponseWasOk(914))
        {
            cache_meta_picture = skypeRef.decoder.DecodeBinary();
            cache[31] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktConversation class PropKeys */
    
    public enum PropKeys 
    {
        P_IDENTITY                        =  972,
        P_TYPE                            =  902,
        P_LIVE_HOST                       =  918,
        P_LIVE_START_TIMESTAMP            =  974,
        P_LIVE_IS_MUTED                   =  996,
        P_ALERT_STRING                    =  920,
        P_IS_BOOKMARKED                   =  921,
        P_GIVEN_DISPLAYNAME               =  925,
        P_DISPLAYNAME                     =  924,
        P_LOCAL_LIVESTATUS                =  927,
        P_INBOX_TIMESTAMP                 =  928,
        P_INBOX_MESSAGE_ID                =  973,
        P_UNCONSUMED_SUPPRESSED_MESSAGES  =  975,
        P_UNCONSUMED_NORMAL_MESSAGES      =  976,
        P_UNCONSUMED_ELEVATED_MESSAGES    =  977,
        P_UNCONSUMED_MESSAGES_VOICE       =  970,
        P_ACTIVE_VM_ID                    =  971,
        P_CONSUMPTION_HORIZON             =  979,
        P_LAST_ACTIVITY_TIMESTAMP         =  981,
        P_SPAWNED_FROM_CONVO_ID           =  915,
        P_CREATOR                         =  903,
        P_CREATION_TIMESTAMP              =  904,
        P_MY_STATUS                       =  919,
        P_OPT_JOINING_ENABLED             =  922,
        P_OPT_ENTRY_LEVEL_RANK            =  906,
        P_OPT_DISCLOSE_HISTORY            =  907,
        P_OPT_ADMIN_ONLY_ACTIVITIES       =  909,
        P_PASSWORDHINT                    =  980,
        P_META_NAME                       =  910,
        P_META_TOPIC                      =  911,
        P_META_GUIDELINES                 =  913,
        P_META_PICTURE                    =  914 
    }
    
    /* SktConversation class enums */
    
    /**  TYPE
     */
    public enum TYPE
    {
        DIALOG                    =    1, /*!< 1:1 conversations, there is a one dialog per identity */
        CONFERENCE                =    2, /*!< equivalent of a multichat */
        TERMINATED_CONFERENCE     =    3, /*!< a conference that has been terminated (disbanded chat) */
        LEGACY_VOICE_CONFERENCE   =    4, /*!< voice-only conference, when host is using a legacy non-conversation client */
        LEGACY_SHAREDGROUP        =    5  /*!< chat used for legacy shared groups, can be ignored */
    }
    
    /**  MY_STATUS
     */
    public enum MY_STATUS
    {
        CONNECTING             =    1, /*!< connecting to conference */
        RETRY_CONNECTING       =    2, /*!<   */
        DOWNLOADING_MESSAGES   =    3, /*!< unused */
        QUEUED_TO_ENTER        =    4, /*!< conference is full for now, being queued */
        APPLICANT              =    5, /*!< I'm applying to join the conference */
        APPLICATION_DENIED     =    6, /*!< My application to join the conference was denied */
        INVALID_ACCESS_TOKEN   =    7, /*!< The password I provided is incorrect */
        CONSUMER               =    8, /*!< I'm part of the conference, I can participate */
        RETIRED_FORCEFULLY     =    9, /*!< I was kicked from the conference */
        RETIRED_VOLUNTARILY    =   10  /*!< I left the conference */
    }
    
    /**  LOCAL_LIVESTATUS
     */
    public enum LOCAL_LIVESTATUS
    {
        NONE                      =    0, /*!< there isn't a live session */
        STARTING                  =    1, /*!< trying to start or join a live session */
        RINGING_FOR_ME            =    2, /*!< there is a live session ringing */
        IM_LIVE                   =    3, /*!< the conference is live for me */
        ON_HOLD_LOCALLY           =    5, /*!< I put the live session on hold */
        ON_HOLD_REMOTELY          =    6, /*!< the live session was put on hold by someone else */
        OTHERS_ARE_LIVE           =    7, /*!< there is a live session on-going, I'm not participating but I could join */
        OTHERS_ARE_LIVE_FULL      =   11, /*!< there is a live session on-going without me, but I can't join because it's full */
        PLAYING_VOICE_MESSAGE     =    8, /*!< playing a voicemail (dialog only) */
        RECORDING_VOICE_MESSAGE   =    9, /*!< recording a voicemail (dialog only) */
        RECENTLY_LIVE             =   10, /*!< a live session just finished, we stay in this state for RECENTLY_LIVE_TIMEOUT setup key */
        TRANSFERRING              =   12  /*!< call is being transferred */
    }
    
    /**  values for opt_admin_only_activities property
     */
    public enum ALLOWED_ACTIVITY
    {
        SET_META          =    1, /*!< allowed to set the CONVERSATION_META properties */
        ADD_CONSUMERS     =    2, /*!< allowed to add participants to the conference */
        SPEAK             =    4, /*!< allowed to speak, but not write */
        SPEAK_AND_WRITE   =    8  /*!< allowed to speak and write */
    }
    
    /**  PARTICIPANTFILTER
     */
    public enum PARTICIPANTFILTER
    {
        ALL                        =    0, /*!< All participants (may included some that are RETIRED or OUTLAW, but not all of them) */
        CONSUMERS                  =    1, /*!< Participants that can receive messages, including myself */
        APPLICANTS                 =    2, /*!< Only people who are applying to join the conversation */
        CONSUMERS_AND_APPLICANTS   =    3, /*!< Consumers and applicants */
        MYSELF                     =    4, /*!< Myself */
        OTHER_CONSUMERS            =    5  /*!< All consumers except myself */
    }
    
    /**  LIST_TYPE
     */
    public enum LIST_TYPE
    {
        ALL_CONVERSATIONS          =    0, /*!< bookmarked or in_inbox or live or with_meta_info or activity in last 30 days */
        INBOX_CONVERSATIONS        =    1, /*!< only last 6 months conversations are kept there */
        BOOKMARKED_CONVERSATIONS   =    2, /*!< is_bookmarked is set */
        LIVE_CONVERSATIONS         =    3, /*!< local_livestatus is different from NONE */
        REALLY_ALL_CONVERSATIONS   =    5  /*!< all conversations, without any of the limits of ALL_CONVERSATIONS */
    }
    
    /* SktConversation class methods */
    
    /**  Setter method for Conversation option properties. Option properties are all Conversation properties starting
      with OPT_ prefix.
        @param [in] propKey - Conversation property key, for example: SktConversation.OPT_JOINING_ENABLED
        @param [in] value - New value for the option property.
     */
    public void SetOption (int propKey, uint value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetOption");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddUintParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetOption");
    }
    
    /**  Setter for Conversation class META_TOPIC. This topic will be set for remote participants as well.
        @param [in] topic - New conversation topic.
        @param [in] isXML - Notifies remote UIs that the new topic contains xml tags. Default value is false
     */
    public void SetTopic (String topic, Boolean isXML)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetTopic");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.encoder.AddStringParam(1, topic);
        skypeRef.encoder.AddBoolParam(2, isXML);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetTopic");
    }
    
    /**  Setter for Conversation META_GUIDELINES. This property will be visible to remote participants of the
      conversation.
        @param [in] guidelines - New value for the META_GUIDELINES property.
        @param [in] isXML - Set true to notify remote UIs that the new guideline contains XML tags. Default value is false
     */
    public void SetGuidelines (String guidelines, Boolean isXML)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetGuidelines");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.encoder.AddStringParam(1, guidelines);
        skypeRef.encoder.AddBoolParam(2, isXML);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetGuidelines");
    }
    
    /**  Sets the conversation's avatar to the specified JPEG image, which is propagated to both local and remote
      participants. Before calling this method, you should use SktSkype.ValidateAvatar to verify that jpeg
      references a valid JPEG image.
        @param [in] jpeg - Conversation avatar binary.
     */
    public void SetPicture (byte[] jpeg)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetPicture");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.encoder.AddBinaryParam(1, jpeg);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetPicture");
    }
    
    /**  When called from dialog conversation, this spawns a new conversation, with existing two dialog participants
      plus new contact identities given in the identitiesToAdd list. You do not need to add existing dialog
      participants to the string list. In fact, passing only the existing participants in the identities list
      will cause the method call to fail (return false), the same as if the list was empty. This method will
      also return false if the original conversation was not a dialog (contained more than two participants).
      Also note that this method always creates a new Conversation - even if a conversation with exactly the
      same participant list existed before.
        @returns conference Returns the resulting conversation or 0 if the method call failed. 
        @param [in] identitiesToAdd - String list of additional participant identities. You do not need to add existing two participants
      from the original dialog to this list.
     */
    public SktConversation SpawnConference (List<String> identitiesToAdd)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SpawnConference");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddStringListParam(1, identitiesToAdd);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktConversation.SpawnConference");
        return (SktConversation)args[0];
    }
    
    /**  Takes one or more Contact identities and creates corresponding Participant objects within the context
      of this Conversation, which must be of type CONFERENCE. If you have an existing dialog conversation,
      use SpawnConference instead.
        @param [in] identities - Contact identities to be added to the Conversation.
     */
    public void AddConsumers (List<String> identities)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.AddConsumers");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddStringListParam(1, identities);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.AddConsumers");
    }
    
    /**  Merges two live conversations. For example, if the user already has a live conversation up - let's call
      it conversation A. Then a new incoming call occurs - another conversation obtains LOCAL_LIVESTATUS ==
      SktConversation.RINGING_FOR_ME, let's call it conversation B. The user wishes to pick up the new incoming
      call and add it to the existing one. For this you can first call B->JoinLiveSession and then merge two
      calls with A->Assimilate(B, A). The second argument will return the merged conversation. Note that there
      are actually three conversation objects involved: A (before merge), B and C (after the merge). Normally
      it would make sense to have the first conversation (A) as the second argument, so that it gets overwritten
      with the assimilation result.
        @returns conversation Returns a 3rd live conversation, result of merging two existing ones. 
        @param [in] otherConversation - The new conversation to be merged with the one already in live state.
     */
    public SktConversation Assimilate (SktConversation otherConversation)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.Assimilate");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 9, OID);
        skypeRef.encoder.AddObjectParam(1, otherConversation);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{18}, ref tagMap, "SktConversation.Assimilate");
        return (SktConversation)args[0];
    }
    
    /**  starts, answers or joins a live session (first one to join becomes LIVE_HOST)
        @param [in] accessToken - if starting a live session, allows to set a custom access token Default value is ""
     */
    public void JoinLiveSession (String accessToken)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.JoinLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.encoder.AddStringParam(1, accessToken);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.JoinLiveSession");
    }
    
    /**  This is an alternative to calling Ring method for each Participant individually. This also works with
      dialogs (with identities containing only one item).
        @param [in] identities - List of Participants to ring. Leaving the list empty will result in ringing all participants of at
      least speaker level.
        @param [in] videoCall - If true, indicates that we want to do a video call (video still needs to be separately enabled) Default value is false
        @param [in] origin - When call is initiated from web link, this argument must contain the URI that was used Default value is ""
     */
    public void RingOthers (
        List<String> identities,
        Boolean      videoCall,
        String       origin)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.RingOthers");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 36, OID);
        skypeRef.encoder.AddStringListParam(1, identities);
        skypeRef.encoder.AddBoolParam(2, videoCall);
        skypeRef.encoder.AddStringParam(3, origin);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.RingOthers");
    }
    
    /**  Sets VOICE_STATUS to LISTENING in the Participant instance associated with us, causing any input from
      our microphone to be ignored. This is a Conversation class method, rather than Participant class, because
      this only applies to local participant.
     */
    public void MuteMyMicrophone ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.MuteMyMicrophone");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 11, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.MuteMyMicrophone");
    }
    
    /**  Sets VOICE_STATUS to SPEAKING in the Participant instance associated with us, causing any input from
      our microphone to be sent to the call host. This is a Conversation class method, rather than Participant
      class, because this only applies to local participant.
     */
    public void UnmuteMyMicrophone ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.UnmuteMyMicrophone");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.UnmuteMyMicrophone");
    }
    
    /**  Puts the conversation on hold - Conversation LOCAL_LIVESTATUS changes to ON_HOLD_LOCALLY and to ON_HOLD_REMOTELY
      for remote participants.
     */
    public void HoldMyLiveSession ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.HoldMyLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.HoldMyLiveSession");
    }
    
    /**  Resumes call from local hold.
     */
    public void ResumeMyLiveSession ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.ResumeMyLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 14, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.ResumeMyLiveSession");
    }
    
    /**  Hang up or refuse to answer an incoming call. Set postVoiceAutoresponse to true to enable a caller to
      leave a voicemail message.
        @param [in] postVoiceAutoresponse Default value is false
     */
    public void LeaveLiveSession (Boolean postVoiceAutoresponse)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.LeaveLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 15, OID);
        skypeRef.encoder.AddBoolParam(1, postVoiceAutoresponse);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.LeaveLiveSession");
    }
    
    /**  Begin recording a voice mail for this conversation's remote participant. Applies to conversations of
      type DIALOG only.
     */
    public void StartVoiceMessage ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.StartVoiceMessage");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 45, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.StartVoiceMessage");
    }
    
    /**  This method is for doing call transfers. NB! Call transfers only work in one-on-one conversations (dialogs).
      Before attempting call transfer, you should check availability of transfer recipients with Conversation
      class CanTransferLiveSession method. If the current conversation has a live session up, that session
      (call) will be transferred to targets specified in the identities list. Note that identities is a string
      list - all identities in that list will get incoming calls. The first one of them to pick up the call
      - wins, and rest of the transfer targets will stop ringing. Let's take a closer look how this works in
      practice. We have three call participants involved in the process, and two separate conversations. Let there be three callers: Caller A (call originator), Caller
      B (transferor) and Caller C (recipient of transfer). @li Caller A - calls Caller B; Caller B picks up
      the call - live conversation C1 is now up with A and B in it. @li After awhile, Caller B initiates call transfers to Caller C (and optionally to Callers D,
      E, F.. ). LOCAL_LIVESTATUS of C1 will get set to TRANSFERRING for both A and B. @li Caller C picks up
      the call. Conversation C1 will go off live status. For Caller B, conversation C1 LOCAL_LIVESTATUS will
      change to RECENTLY_LIVE. Another live conversation - C2 gets spawned, with Caller A and Caller C in it.
      For caller C, participant object representing caller A will have TRANSFERRED_BY property set to identity
      of caller A. For Caller B (in now no longer live conversation C1), participant object representing caller
      A gets its TRANSFERRED_TO property set to identity of caller C.
        @param [in] identities - String list of transfer target identities. As soon as first one in this list picks up the call, others
      will stop ringing.
        @param [in] transferTopic - Optional conversation topic. This value will get set as META_TOPIC property of the conversation at
      the transferee end. Note that this is the only case where META_TOPIC field is used in context of dialog
      conversations. Thus assumption that remote UI will display topic field in case of dialogs may not be
      100% correct. Default value is ""
        @param [in] context - Leave empty if you don't know what to use it for Default value is null
     */
    public void TransferLiveSession (
        List<String> identities,
        String       transferTopic,
        byte[]       context)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.TransferLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 40, OID);
        skypeRef.encoder.AddStringListParam(1, identities);
        skypeRef.encoder.AddStringParam(2, transferTopic);
        skypeRef.encoder.AddBinaryParam(3, context);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.TransferLiveSession");
    }
    
    /**  Checks if the identity is available for receiving a transferred live session. If you are going to attempt
      to go for multiple transfer targets, you should use this check for all the target identities.
        @returns result Returns true if call transfer to given target is possible. 
        @param [in] identity - Target identity.
     */
    public Boolean CanTransferLiveSession (String identity)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.CanTransferLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 46, OID);
        skypeRef.encoder.AddStringParam(1, identity);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktConversation.CanTransferLiveSession");
        return (Boolean)args[0];
    }
    
    /**  Sends DTMF tone to a live conversation.
        @param [in] dtmf - Outgoing dtmf tone, possible values come from SktParticipant.DTMF enumerator.
        @param [in] lengthInMS - Duration in milliseconds. Defaults to 260 ms. Note that the DTMF tone can be also cancelled with SktConversation.StopSendDTMF
      method. Default value is 260
     */
    public void SendDTMF (SktParticipant.DTMF dtmf, uint lengthInMS)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SendDTMF");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 16, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)dtmf);
        skypeRef.encoder.AddUintParam(2, lengthInMS);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SendDTMF");
    }
    
    /**  Stops the current DTMF tone being played into conversation. For example, use this method to cancel DTMF
      signals started with SktConversation.SendDTMF before the duration given in lengthInMS runs out.
     */
    public void StopSendDTMF ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.StopSendDTMF");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 48, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.StopSendDTMF");
    }
    
    /**  Sets local user typing indicator in the Conversation. Remote Participants can display these in their
      UI.
        @param [in] status - Typing indicator status value - SktParticipant.TEXT_STATUS
     */
    public void SetMyTextStatusTo (SktParticipant.TEXT_STATUS status)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetMyTextStatusTo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 18, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)status);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetMyTextStatusTo");
    }
    
    /**  Posts the specified text the conversation, and populates message with a reference to the corresponding
      Message object (if no error occurred during execution). The isXML argument can be used if the client
      UI has already taken care of converting message text to xml (for example, your UI might enable users
      to use bold tags in text messages.)
        @returns message Returns the Message object created as a result of this method (if successful). 
        @param [in] text - Text value of the outgoing message (gets set as BODY_XML property of the Message object).
        @param [in] isXML - For cases where the text argument was already encoded as xml message. Default value is false
     */
    public SktMessage PostText (String text, Boolean isXML)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.PostText");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 19, OID);
        skypeRef.encoder.AddStringParam(1, text);
        skypeRef.encoder.AddBoolParam(2, isXML);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{9}, ref tagMap, "SktConversation.PostText");
        return (SktMessage)args[0];
    }
    
    /**  Takes a list of Contacts as an argument and posts the list into the Conversation. The purpose of this
      feature is to enable sharing contacts between users, without resorting to contact search. Instead, if
      user A has contacts B and C, he can post contact C into chat with contact B. At this point, Contact B
      can add contact C to his contact list. From remote side, the posted contacts will appear as messages
      with type SktMessage.POSTED_CONTACTS appearing in the conversation. The UI should allow adding these
      contacts from messages with this type into the contact list. The list of posted contacts can be retrieved
      with the SktMessage.GetContacts method. Additionally, the UI then can parse the posted Contact data out
      of the SktMessage.P_BODY_XML property. The list of contacts is wrapped between <contacts ..> </contacts> tags. Each contact item in the xml
      has following format: @li t - contact type. "s" - skype contact; "p" - phone number; @li s - skypename,
      present only in skypename contacts (t="s") @li p - phone number, present only in phone number contacts
      (t="p") @li f - contact's full name, if available @li d - contact's display name, if available Note that
      only the type (t) field is mandatory. Depending on type, either skypename (s) or phone number (p) fields are always present. Full name and display name fields are optional. Example BODY_XML with
      skypname contact: @code <contacts alt="alt text"><c t="s" s="skypename" f="full name"/></contacts> @endcode
      Example BODY_XML with PSTN contact: @code <contacts alt="alt text"><c t="p" p="+37212345678" d="Some
      PSTN number"/></contacts> @endcode Example BODY_XML with multiple contacts: @code <contacts alt="alt
      text"><c t="p" p="+37212345678" d="Some PSTN number"/><c t="s" s="someskypename"/></contacts> @endcode
        @param [in] contacts - List of Contact objects, to be posted in the conversation.
     */
    public void PostContacts (SktContact.List contacts)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.PostContacts");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 20, OID);
        skypeRef.encoder.AddObjectListParam(1, contacts);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.PostContacts");
    }
    
    /**  Takes a list of fully-qualified filenames and initiates corresponding file transfers in the conversation.
      From the remote side, incoming file transfers will appear as a conversation message with type POSTED_FILES.
      Once such a message is detected, the list of file transfer objects can be retrieved with SktMessage.GetTransfers.
      At that point, remote participants will need to accept or decline those transfers.
        @param [out] error_code Error code, possible values come from the TRANSFER_SENDFILE_ERROR enumerator. This will be set for the first failed fail. The failed file is identified in the error_file return argument. 
        @param [out] error_file Filename of the file that triggered error. 
        @param [in] paths - list of fully-qualified filenames to be transferred
        @param [in] body - Optional BODY_XML property for POSTED_FILES type messages that show up in remote UI.
     */
    public void PostFiles (
        out SktSkype.TRANSFER_SENDFILE_ERROR error_code,
        out String        error_file,
        List<String>      paths,
        String            body)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.PostFiles");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 21, OID);
        skypeRef.encoder.AddFilenameListParam(1, paths);
        skypeRef.encoder.AddStringParam(2, body);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktConversation.PostFiles");
        error_code = (SktSkype.TRANSFER_SENDFILE_ERROR)args[0];
        error_file = (String)args[1];
    }
    
    /**  Stops the active voicemail recording and sends it (dialog only)
        @param [in] voicemail - This argument is deprecated as of SDK version 3.2. Instead of manually constructing Voicemail object,
      you can call SktConversation.StartVoiceMessage method to start recording a voicemail in context of a
      dialog. PostVoiceMessage will stop recording this voicemail and post it in the dialog. If instead of
      sending Voicemail, the user decides to cancel it, you should use SktConversation.LeaveLiveSession method
      Skt(Voicemail.Cancel is deprecated).
        @param [in] body - Optional text message that remote UI can display in conversation, to notify the user of a new voicemail.
     
     */
    public void PostVoiceMessage (SktVoicemail voicemail, String body)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.PostVoiceMessage");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 22, OID);
        skypeRef.encoder.AddObjectParam(1, voicemail);
        skypeRef.encoder.AddStringParam(2, body);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.PostVoiceMessage");
    }
    
    /**  Takes an SMS instance created by SktSkype.CreateOutgoingSms and posts it in the conversation. Note that
      you will need to set both Sms body text Skt(Sms.SetBody) and recipient list Skt(Sms.SetTargets) before
      you can post the object.
        @param [in] sms - SMS object.
        @param [in] body - This argument is currently ignored. The message text needs to be set with SktSms.SetBody method, prior
      to passing the Sms object to this method Default value is ""
     */
    public void PostSMS (SktSms sms, String body)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.PostSMS");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 23, OID);
        skypeRef.encoder.AddObjectParam(1, sms);
        skypeRef.encoder.AddStringParam(2, body);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.PostSMS");
    }
    
    /**  Retrieves a binary join blob for joining public conversations, which are always of type CONFERENCE. If
      called for a dialog, the blob argument will contain the empty string. The best way to create a Public
      Chat is to first create a fresh conversation with Skype class CreateConference, then minimally apply
      the public chat options OPT_JOINING_ENABLED and OPT_ENTRY_LEVEL_RANK - options, like this (C++): @code
      SktC->SetOption(Conversation.OPT_JOINING_ENABLED, true); @endcode When that is done, you can call GetJoinBlob
      to retrieve the blob string. Use the blob string to generate and post an HTML link whose href attribute looks like this: href="skype:?chat&blob=_BLOB_GOES_HERE" A
      person running Skype desktop client can click this link to join the conversation and have that conversation
      opened in his UI. Note that the conversation host (creator) needs to be online for new joiners-via-link
      to start participating in the Public Chat.
        @returns blob Returns the public conversation join blob. 
     */
    public String GetJoinBlob ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.GetJoinBlob");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 24, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktConversation.GetJoinBlob");
        return (String)args[0];
    }
    
    /**  Tries to join a public conversation (aka public chat). This method is only useful if you have used SktSkype.GetConversationByBlob
      method with alsoJoin argument set to false.
     */
    public void Join ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.Join");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 25, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.Join");
    }
    
    /**  Submits password for joining password-protected conversation.
        @param [in] password - Password string.
     */
    public void EnterPassword (String password)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.EnterPassword");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 26, OID);
        skypeRef.encoder.AddStringParam(1, password);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.EnterPassword");
    }
    
    /**  Sets password protection/new password for the conversation.
        @param [in] password - New password.
        @param [in] hint - Password hint.
     */
    public void SetPassword (String password, String hint)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetPassword");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 27, OID);
        skypeRef.encoder.AddStringParam(1, password);
        skypeRef.encoder.AddStringParam(2, hint);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetPassword");
    }
    
    /**  Leaves the conference. Not applicable to dialogs.
     */
    public void RetireFrom ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.RetireFrom");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 28, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.RetireFrom");
    }
    
    /**  Deletes this conversation, which must be of type CONFERENCE - dialogs between local user and any of his
      contacts are always persistant. Note that this also removes corresponding Message and Participant objects.
     
     */
    public void Delete ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.Delete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 47, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.Delete");
    }
    
    /**  Changes the META_NAME property of the conversation. Note that unlike topic and guidelines, this rename
      is just local - remote participants can have their own private names for conversations.
        @param [in] name - New name for the conversation. Passing an empty string in this argument causes the META_NAME to unset.
     
     */
    public void RenameTo (String name)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.RenameTo");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 29, OID);
        skypeRef.encoder.AddStringParam(1, name);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.RenameTo");
    }
    
    /**  Setter for Conversation class IS_BOOKMARKED.
        @param [in] bookmark - Set true to set the bookmark, false to remove the bookmark.
     */
    public void SetBookmark (Boolean bookmark)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetBookmark");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 30, OID);
        skypeRef.encoder.AddBoolParam(1, bookmark);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetBookmark");
    }
    
    /**  Setter for Conversation class ALERT_STRING property. The main use of this property is checking bodies
      of incoming messages in the conversation for the alert string and producing notifications in UI for the
      user, when appropriate.
        @param [in] alertString - Substring to check in BODY_XML property of incoming messages.
     */
    public void SetAlertString (String alertString)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetAlertString");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 31, OID);
        skypeRef.encoder.AddStringParam(1, alertString);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetAlertString");
    }
    
    /**  Removes conversation from Inbox.
     */
    public void RemoveFromInbox ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.RemoveFromInbox");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 32, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.RemoveFromInbox");
    }
    
    /**  Sets Conversation inbox_timestamp property. If the timestamp argument is left empty or is greater than
      conversation consumption horizon, then the conversation will be restored to the inbox.
        @param [in] timestamp - If left empty or set to 0, the inbox_timestamp property is set to current time.
     */
    public void AddToInbox (DateTime timestamp)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.AddToInbox");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 33, OID);
        skypeRef.encoder.AddTimeStampParam(1, timestamp);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.AddToInbox");
    }
    
    /**  This method can be used to set the consumption (read) status of messages in the conversation. It sets
      SktMessage.CONSUMPTION_STATUS to SktMessage.CONSUMED for all messages in the conversation, older than
      the given timestamp. If the second argument is set to true, it also modifies messages more recent than
      the timestamp, by marking them as unconsumed.
        @param [in] timestamp - Consumption cutoff timestamp. Setting this to current time will mark all messages in the conversation
      as consumed.
        @param [in] also_unconsume - If set to true, this also marks messages newer than the cutoff timestamp as unconsumed. For example,
      setting timestamp to 0 and also_unconsumed to true, will unconsume all messages in the conversation.
      Default value is false
     */
    public void SetConsumedHorizon (DateTime timestamp, Boolean also_unconsume)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.SetConsumedHorizon");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 34, OID);
        skypeRef.encoder.AddTimeStampParam(1, timestamp);
        skypeRef.encoder.AddBoolParam(2, also_unconsume);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.SetConsumedHorizon");
    }
    
    /**  sets consumption horizon to last inbox message id timestamp
     */
    public void MarkUnread ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.MarkUnread");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 35, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.MarkUnread");
    }
    
    /**  Checks if the conversation is a member of the given ContactGroup
        @returns result True if this conversation is a member of the ContactGroup specified by the group argument contains the conversation 
        @param [in] group - ContactGroup
     */
    public Boolean IsMemberOf (SktContactGroup group)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.IsMemberOf");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 37, OID);
        skypeRef.encoder.AddObjectParam(1, group);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktConversation.IsMemberOf");
        return (Boolean)args[0];
    }
    
    /**  Retrieves the list of this conversation's current participants, which you can optionally request to be
      filtered. If no Participants pass the filter, an empty list will be returned (the method itself still
      returns true).
        @returns participants List of conversation Participant objects that passed the filter. 
        @param [in] filter - SktConversation.PARTICIPANTFILTER - defaults to SktConversation.ALL Default value is SktConversation.PARTICIPANTFILTER.ALL
     */
    public SktParticipant.List GetParticipants (SktConversation.PARTICIPANTFILTER filter)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.GetParticipants");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 38, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)filter);
        SktParticipant.List participants = new SktParticipant.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktConversation.GetParticipants failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        participants = (SktParticipant.List)skypeRef.decoder.DecodeObjectList(19);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktConversation.GetParticipants", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return participants;
    } // SktConversation.GetParticipants
    
    /**  Returns recent messages. The messages are returned in two lists - new messages (unconsumed) and recent
      message history (context messages). The context message list contains messages that are already above
      the consumption horizon but are fairly recent, making it likely that displaying them in UI would be good
      default behaviour.
        @param [out] contextMessages Already consumed messages, provided for context
        @param [out] unconsumedMessages Unconsumed messages
        @param [in] requireTimestamp - If set to a non-zero value, includes messages no earlier than this timestamp, if not, includes messages
      from the last 24 hours only
     */
    public void GetLastMessages (
        out SktMessage.List contextMessages,
        out SktMessage.List unconsumedMessages,
        DateTime      requireTimestamp)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.GetLastMessages");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 39, OID);
        skypeRef.encoder.AddTimeStampParam(1, requireTimestamp);
        contextMessages = new SktMessage.List(); // We always guarantee non-null list is returned
        unconsumedMessages = new SktMessage.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktConversation.GetLastMessages failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        contextMessages = (SktMessage.List)skypeRef.decoder.DecodeObjectList(9);
                        break;
                    case 2:
                        unconsumedMessages = (SktMessage.List)skypeRef.decoder.DecodeObjectList(9);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktConversation.GetLastMessages", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktConversation.GetLastMessages
    
    /**  Finds the most recent Message object in the conversation that contains the substring specified by the
      text argument. If no matching messages are found, this method will return false. The search proceeds
      backwards in time, starting from the timestamp argument. To continue searching, you can start with timestamp=MAX_UINT,
      retrieve the TIMESTAMP property of the matching message, decrement it by one, and submit it as timestamp
      for the next FindMessage call.
        @returns message Returns matching message or 0 if there was no match. As the likelihood of this object being invalid is quite high, you should always check for method return value before you start calling methods of this object. 
        @param [in] text - Substring to search for.
        @param [in] fromTimestampUp
     */
    public SktMessage FindMessage (String text, DateTime fromTimestampUp)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.FindMessage");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 41, OID);
        skypeRef.encoder.AddStringParam(1, text);
        skypeRef.encoder.AddTimeStampParam(2, fromTimestampUp);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = null;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{9}, ref tagMap, "SktConversation.FindMessage");
        return (SktMessage)args[0];
    }
    
    /**  Attaches send video to livesession. There is no detach. If you don't want to use this video in livesession
      anymore - stop it. Video object will stay attached until the end of livesession
        @param [in] sendVideo
     */
    public void AttachVideoToLiveSession (SktVideo sendVideo)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Conversation.AttachVideoToLiveSession");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 147, OID);
        skypeRef.encoder.AddObjectParam(1, sendVideo);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktConversation.AttachVideoToLiveSession");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        switch (eventId)
        {
            case 1:
                skypeRef.events.ProcessOnConversationParticipantListChange(this);
                break;
            case 2:
                skypeRef.events.ProcessOnConversationMessage(this);
                break;
            case 3:
                skypeRef.events.ProcessOnConversationSpawnConference(this);
                break;
            default:
                skypeRef.Error(String.Format("Invalid event ID {0} received for class Conversation", eventId)); break;
        }
    }
}

/*! \class SktContactSearch
  \brief
  This class encapsulates functionality for looking up contacts on the Skype network. Contacts can be searched
  by portion of their name, e-mail address, language preferences, etc. @brief Contact search is asynchronous. SktContactSearch.Submit is a non-blocking function that initiates the
  search. Upon finding a matching contact, SktContactSearch.OnNewResult event gets fired, that gives you
  the reference to the discovered contact. You can get up to 100 matching contacts per search. Note that
  you will need to keep a live reference of the ContactSearch object while the search is doing its work.
  So, to perform a contact search: 
  @li create a contact search object 
  @li specify search terms and conditions
  
  @li submit search 
  @li in SktContactSearch.OnNewResult callback, update your UI 
  @li in SktContactSearch.OnChange,
  check for terminal values of P_CONTACT_SEARCH_STATUS and update the UI accordingly. When the search has done its job, the SktContactSearch.P_CONTACT_SEARCH_STATUS property will go to one
  of the terminal values. The terminal values are: 
  @li FINISHED - the search has stopped. Note that this does not mean any matches
  were actually found. 
  @li FAILED - the search has failed. 
  @li EXTENDABLE - this state should be considered
  the same as FINISHED. The feature of extending long search results is about to be deprecated. It is still
  possible for search objects to occasionally reach that state, so it should be handled in the UI (as FINISHED),
  but the extending feature itself should not be implemented in your UI. When a ContactSearch object reacges a terminal state, SktContactSearch.Release has to be called to dispose
  of the object. There are three methods to create the ContactSearch objects. A) SktSkype.CreateIdentitySearch This method takes a string argument and looks for exact matches against SktContact.P_SKYPENAME property.
  So for example, identity search for "echo" will return 0 results and search for "echo123" will return
  exactly one. Identity in this case means skypename - contact search does not work with PSTN type contacts. However,
  it does work for SKYPE type contacts that have supplied P_PHONE_HOME, P_PHONE_OFFICE or P_PHONE_MOBILE
  values in their account data. To search for those, you will need to use complex search (see below). Note that you should always check for boolean return value of the CreateIdentitySearch method. If the
  user submits a string that is not a valid skypename, the method will return false and the ContactSearchRef
  argument will return as NULL. B) SktSkype.CreateBasicContactSearch This method takes a string argument and looks for non-exact matches against both P_SKYPENAME and P_FULLNAME
  properties of the contact. If you intend to implement a simple, one-input search feature - this is the
  best method for you. The non-exact matching operates similarly to the SQL LIKE condition. C) SktSkype.CreateContactSearch This method enables you to implement advanced contact search, matching against multiple seach criteria.
  It takes no input arguments and expects search criteria to be added to the already constructed search
  object. Criteria can be added with SktContactSearch.AddStrTerm and SktContactSearch.AddIntTerm methods. These methods take Contact class porperty ID, condition, and the match pattern as inputs. Only the following Contact properties can be used for search: 
  @li P_SKYPENAME 
  @li P_FULLNAME 
  @li P_BIRTHDAY
  (uint) 
  @li P_GENDER (uint: 1-male, 2-female) 
  @li P_LANGUAGES 
  @li P_COUNTRY 
  @li P_PROVINCE 
  @li P_CITY
  
  @li P_PHONE_HOME 
  @li P_PHONE_OFFICE 
  @li P_PHONE_MOBILE 
  @li P_EMAILS 
  @li P_HOMEPAGE 
  @li P_ABOUT String searches are case insensitive, i.e. search for echo123 also matches ECHO123 When adding multiple criteria, default behaviour is that the criterions are additive. I.e. a term skypename
  == "joe" followed by term country == "us" will result in intersection between all joes and everybody
  in US. You can explicitly add an "OR" instead of "AND" between conditions, using the AddOr method. By default, AND criteria are grouped together, before OR's, so that: AddTerm(condition1) AddTerm(condition2) AddOr() AddTerm(condition3) AddTerm(condition4) will result in the following logical statement: (condition1 AND condition2) OR (condition3 AND condition4) However, you can add "global" critera, by using the add_to_subs argument of the AddXX methods. AddTerm(condition1) AddTerm(condition2) AddOr() AddTerm(condition3) AddTerm(condition4, add_to_subs=true) which would result in: (condition1 AND condition2 AND condition4) OR (condition3 AND condition4) Every one of the contact properties can only be used once, per search. For example, you cannot create
  a search for two different P_FULLNAME patterns. The &valid argument will still return tue if you do this,
  but the last criteria for any given property will override all previous ones. So, a search like this:
  Sktcs->AddStrTerm(Contact.P_FULLNAME, SktContactSearch.EQ, "John Smith", isValid); cs->AddOr(); Sktcs->AddStrTerm(Contact.P_FULLNAME, SktContactSearch.EQ, "Ivan Sidorov", isValid); will only return matches for "Ivan Sidorov" and none for "John Smith". Some of the contact properties are automatically combined for purposes of search. A search for P_SKYPENAME also returns matches from the P_FULLNAME property and vice versa. So that this: Sktcs->AddStrTerm(Contact.P_SKYPENAME, SktContactSearch.EQ, "john.smith", isValid); ..and this: Sktcs->AddStrTerm(Contact.P_FULLNAME, SktContactSearch.EQ, "John Smith", isValid); ..and this: Sktcs->AddStrTerm(Contact.P_SKYPENAME, SktContactSearch.EQ, "john.smith", isValid); cs->AddOr(); Sktcs->AddStrTerm(Contact.P_FULLNAME, SktContactSearch.EQ, "John Smith", isValid); ..all search from both the P_FULLNAME and P_SKYPENAME fields. Before using SktContactGroup.Submit to start the search, you should always check whether the search criteria
  ended up being valid. This you can do with SktContactSearch.IsValid method. As you probably noticed, each of the AddXX methods also return a validity check boolean. However, it
  is a better practice to do the overall check as well, even if all the individual search criteria ended
  up looking Ok. For example, lets take a search for contact's e-mail. This can be done with two different methods. Firstly
  we can use the SktContactSearch.AddEmailTerm method. This method will actually validate whether the input
  is a valid e-mail address: cs->AddEmailTerm ("test@test@test", isValid); will return the isValid argument as false. However, you can also add the e-mail search criterion as a simple string, like this: Sktcs->AddStrTerm(Contact.P_EMAILS, SktContactSearch.EQ, "test@test@test@", isValid); in which case the isValid will return true. However, if you then check entire search object with: cs->IsValid(isValid); the isValid will correctly return false.
 @n <h2>Events</h2>
<tt>void <b>SktEvents.OnContactSearchNewResult</b> (SktContactSearch sender, SktEvents.OnContactSearchNewResultArgs e)</tt>@n
 
  This callback is fired when a new matching contact has been found during the search.
  @param contact  (SktContact)
  @param rankValue  (uint)
 
<hr />
 @n 
 */
public class SktContactSearch : SktObject
{
    public override String ClassName { get { return "ContactSearch"; } }
    
    public override uint ClassId { get { return 1; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktContactSearch (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(1);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktContactSearch objects.
     */
    public class List : SktObjectList
    {
        new public SktContactSearch this[int index]
        {
            get { return (SktContactSearch)base[index]; }
        }

        public void Add(SktContactSearch item)
        {
            base.Add((SktContactSearch)item);
        }
    }
    

    /* SktContactSearch property cache fields */
    private volatile SktContactSearch.STATUS cache_contact_search_status;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        skypeRef.Error("MapPropIdToClassId called for ContactSearch - the wrapper has no object properties for this class.");
        return 0;
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 200: /* ContactSearch.P_CONTACT_SEARCH_STATUS */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_contact_search_status = (SktContactSearch.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("ContactSearch.P_CONTACT_SEARCH_STATUS = " + cache_contact_search_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("ContactSearch.P_CONTACT_SEARCH_STATUS - update without value");
                skypeRef.events.FireOnContactSearchContactSearchStatus(this, cache_contact_search_status);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid ContactSearch class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktContactSearch property accessors **/
    
    /**  See SktSTATUS for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnContactSearchContactSearchStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnContactSearchContactSearchStatus(SktContactSearch sender, SktEvents.OnContactSearchContactSearchStatusArgs e)</b></tt>
     */
    public SktContactSearch.STATUS P_CONTACT_SEARCH_STATUS
    {
        get { if (!cache[0]) FetchContactSearchStatusFromRuntime(); return cache_contact_search_status; }
    }
    
    internal void FetchContactSearchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CONTACT_SEARCH_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(1, 200, this.OID);
        if (skypeRef.transport.PropResponseWasOk(200))
        {
            cache_contact_search_status = (SktContactSearch.STATUS)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktContactSearch class PropKeys */
    
    public enum PropKeys 
    {
        P_CONTACT_SEARCH_STATUS  =  200 
    }
    
    /* SktContactSearch class enums */
    
    /**  Possible values for the ContactSearch.P_STATUS property.
     */
    public enum STATUS
    {
        CONSTRUCTION   =    1, /*!< Transient state, obtained after submission and actually initiating the search on the network.   */
        PENDING        =    2, /*!< Waiting for results to show up. This is a transient state.   */
        EXTENDABLE     =    3, /*!< Enough matches are found. No more OnNewResult events will fire. The feature of extending long search results is about to be deprecated. It is still possible for search objects to occasionally reach that state, so it should be handled in the UI (as FINISHED), but the extending feature itself should not be implemented in your UI.    */
        FINISHED       =    4, /*!< The search is finished. No more matches are expected. This is a terminal state.   */
        FAILED         =    5  /*!< ContactSearch failed. Better check if the search terms made any sense, with ContactSearch::IsValid. This is a terminal state.   */
    }
    
    /**  List of available matching conditions that can be used in AddTerm methods.
     */
    public enum CONDITION
    {
        EQ                       =    0, /*!< Equals   */
        GT                       =    1, /*!< Is greater than   */
        GE                       =    2, /*!< Is greater or equal.   */
        LT                       =    3, /*!< Is less than   */
        LE                       =    4, /*!< Less or equal   */
        PREFIX_EQ                =    5, /*!< Start of a word macthes exactly (string properties only).   */
        PREFIX_GE                =    6, /*!< Start of a word is greater or equal (string properties only).   */
        PREFIX_LE                =    7, /*!< Start of a word is less or equal (string properties only).   */
        CONTAINS_WORDS           =    8, /*!< Contains the word (string properties only).   */
        CONTAINS_WORD_PREFIXES   =    9  /*!< One of the words starts with searched value (string properties only).   */
    }
    
    /* SktContactSearch class methods */
    
    /**  construct CONTACT_BIRTHDAY term based on current time
        @returns valid
        @param [in] min_age_in_years
        @param [in] add_to_subs Default value is false
     */
    public Boolean AddMinAgeTerm (uint min_age_in_years, Boolean add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddMinAgeTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.encoder.AddUintParam(1, min_age_in_years);
        skypeRef.encoder.AddBoolParam(2, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddMinAgeTerm");
        return (Boolean)args[0];
    }
    
    /**  construct CONTACT_BIRTHDAY term based on current time
        @returns valid
        @param [in] max_age_in_years
        @param [in] add_to_subs Default value is false
     */
    public Boolean AddMaxAgeTerm (uint max_age_in_years, Boolean add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddMaxAgeTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.encoder.AddUintParam(1, max_age_in_years);
        skypeRef.encoder.AddBoolParam(2, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddMaxAgeTerm");
        return (Boolean)args[0];
    }
    
    /**  Adds a search term against SktContact.P_EMAILS property and pre-validates the value given in the email
      argument.
        @returns valid Returns false if the value in email property did not look like a valid email address. 
        @param [in] email - e-mail addres to search for.
        @param [in] add_to_subs - This argument enables you to group conditions. See ContactSearch class details for more information.
      Default value is false
     */
    public Boolean AddEmailTerm (String email, Boolean add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddEmailTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.encoder.AddStringParam(1, email);
        skypeRef.encoder.AddBoolParam(2, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddEmailTerm");
        return (Boolean)args[0];
    }
    
    /** 
        @returns valid
        @param [in] language
        @param [in] add_to_subs Default value is false
     */
    public Boolean AddLanguageTerm (String language, Boolean add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddLanguageTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.encoder.AddStringParam(1, language);
        skypeRef.encoder.AddBoolParam(2, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddLanguageTerm");
        return (Boolean)args[0];
    }
    
    /**  Adds a string search term to a custom contact search object.
        @returns valid Returns true if the ContactSearch term-set remains valid after adding this term. 
        @param [in] prop - Following Contact class string propkeys can be used for Contact search: @li SktContact.P_SKYPENAME
      @li SktContact.P_FULLNAME @li SktContact.P_LANGUAGES @li SktContact.P_COUNTRY @li SktContact.P_PROVINCE
      @li SktContact.P_CITY @li SktContact.P_PHONE_HOME @li SktContact.P_PHONE_OFFICE @li SktContact.P_PHONE_MOBILE
      @li SktContact.P_EMAILS @li SktContact.P_HOMEPAGE @li SktContact.P_ABOUT Note that while SktContact.P_EMAILS is technically a string and can be used in this method, it is recommended
      that you use ContactSearch.AddEmailTerm method instead.
        @param [in] cond - Search condition Skt(ContactSearch.CONDITION)
        @param [in] value - Value to match against.
        @param [in] add_to_subs - This argument enables you to group conditions. See ContactSearch class details for more information.
      Default value is false
     */
    public Boolean AddStrTerm (
        int                             prop,
        SktContactSearch.CONDITION      cond,
        String                          value,
        Boolean                         add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddStrTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.encoder.AddPropkeyParam(1, prop);
        skypeRef.encoder.AddEnumParam(2, (uint)cond);
        skypeRef.encoder.AddStringParam(3, value);
        skypeRef.encoder.AddBoolParam(4, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddStrTerm");
        return (Boolean)args[0];
    }
    
    /**  Adds a search term to a custom contact search object. For now, there are only two searchable Contact
      properties that are integers, so this can oly be used for SktContact.P_BIRTHDAY and SktContact.P_GENDER.
     
        @returns valid Returns true if the ContactSearch term-set remains valid after adding this term. 
        @param [in] prop - Propkey to search for. Either SktContact.P_BIRTHDAY or SktContact.P_GENDER
        @param [in] cond - Search condition Skt(ContactSearch.CONDITION)
        @param [in] value - Value to match against.
        @param [in] add_to_subs - This argument enables you to group conditions. See ContactSearch class details for more information.
      Default value is false
     */
    public Boolean AddIntTerm (
        int                             prop,
        SktContactSearch.CONDITION      cond,
        uint                            value,
        Boolean                         add_to_subs)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddIntTerm");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddPropkeyParam(1, prop);
        skypeRef.encoder.AddEnumParam(2, (uint)cond);
        skypeRef.encoder.AddUintParam(3, value);
        skypeRef.encoder.AddBoolParam(4, add_to_subs);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.AddIntTerm");
        return (Boolean)args[0];
    }
    
    /**  used to group terms (AddTerm(1), AddTerm(2), Or(), AddTerm(3), AddTerm(4), etc)
     */
    public void AddOr ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.AddOr");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactSearch.AddOr");
    }
    
    /**  checks that terms list is non-empty and does not contain unsupported keys
        @returns result
     */
    public Boolean IsValid ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.IsValid");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktContactSearch.IsValid");
        return (Boolean)args[0];
    }
    
    /**  launch search
     */
    public void Submit ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.Submit");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 9, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactSearch.Submit");
    }
    
    /**  extend if search is EXTENDABLE
     */
    public void Extend ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.Extend");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactSearch.Extend");
    }
    
    /**  Releases and disposes of the ContactSearch object. This needs to be called when the ContactSearch object
      reaches a terminal state (FINISHED, FAILED, EXTENDABLE).
     */
    public void Release ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.Release");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktContactSearch.Release");
    }
    
    /**  result list is dynamically updated
        @returns contacts
        @param [in] from Default value is 0
        @param [in] count Default value is uint.MaxValue
     */
    public SktContact.List GetResults (uint from, uint count)
    {
        if (skypeRef.logging) skypeRef.Log("Executing ContactSearch.GetResults");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 11, OID);
        skypeRef.encoder.AddUintParam(1, from);
        skypeRef.encoder.AddUintParam(2, count);
        SktContact.List contacts = new SktContact.List(); // We always guarantee non-null list is returned
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktContactSearch.GetResults failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        contacts = (SktContact.List)skypeRef.decoder.DecodeObjectList(2);
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktContactSearch.GetResults", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
        return contacts;
    } // SktContactSearch.GetResults
    
    internal override void DispatchEvent (uint eventId)
    {
        switch (eventId)
        {
            case 1:
                skypeRef.events.ProcessOnContactSearchNewResult(this);
                break;
            default:
                skypeRef.Error(String.Format("Invalid event ID {0} received for class ContactSearch", eventId)); break;
        }
    }
}

/*! \class SktSms
  \brief
  Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice. Instantiate
  SMS instances using SktSkype.CreateOutgoingSms; post SMS messages to a Conversation using SktConversation.PostSMS.
  @brief Each SMS can have multiple targets (normalized phone numbers). Note that in a Conversation context, every
  SMS instance has a corresponding Message instance. Once you've posted an SMS, you can retrieve its corresponding
  Message instance using SktSms.GetPropChatmsgId. That Message instance's P_BODY_XML property contains
  the SMS message data, such as price, target phone number(s), failure codes, and so forth, which you can
  parsed out and display in the UI. To put it another way, the object chain goes like this: @code Conversation->Message->SMS @endcode Note that SkypeKit SDK supports outgoing SMS messages only. SkypeKit clients, even when logged in with
  accounts that have SkypeIn numbers, cannot receive SMS messages.
 */
public class SktSms : SktObject
{
    public override String ClassName { get { return "Sms"; } }
    
    public override uint ClassId { get { return 12; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktSms (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(14);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktSms objects.
     */
    public class List : SktObjectList
    {
        new public SktSms this[int index]
        {
            get { return (SktSms)base[index]; }
        }

        public void Add(SktSms item)
        {
            base.Add((SktSms)item);
        }
    }
    

    /* SktSms property cache fields */
    private volatile SktSms.TYPE                cache_type;
    private volatile SktSms.OUTGOING_REPLY_TYPE cache_outgoing_reply_type;
    private volatile SktSms.STATUS              cache_status;
    private volatile SktSms.FAILUREREASON       cache_failurereason;
    private volatile Boolean                    cache_is_failed_unseen;
    private volatile uint                       cache_timestamp;
    private volatile uint                       cache_price;
    private volatile uint                       cache_price_precision;
    private volatile String                     cache_price_currency;
    private volatile String                     cache_reply_to_number;
    private volatile String                     cache_target_numbers;
    private volatile byte[]                     cache_target_statuses;
    private volatile String                     cache_body;
    private volatile SktMessage                 cache_chatmsg_id;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        switch (propId)
        {
            case 840: return 18;
            default: skypeRef.Error("Invalid property ID while trying to map for Class ID."); return 0;
        }
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 190: /* Sms.P_TYPE */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_type = (SktSms.TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_TYPE = " + cache_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_TYPE - update without value");
                skypeRef.events.FireOnSmsType(this, cache_type);
                break;
                
            case 1211: /* Sms.P_OUTGOING_REPLY_TYPE */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_outgoing_reply_type = (SktSms.OUTGOING_REPLY_TYPE)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_OUTGOING_REPLY_TYPE = " + cache_outgoing_reply_type.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_OUTGOING_REPLY_TYPE - update without value");
                skypeRef.events.FireOnSmsOutgoingReplyType(this, cache_outgoing_reply_type);
                break;
                
            case 191: /* Sms.P_STATUS */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_status = (SktSms.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_STATUS = " + cache_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_STATUS - update without value");
                skypeRef.events.FireOnSmsStatus(this, cache_status);
                break;
                
            case 192: /* Sms.P_FAILUREREASON */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_failurereason = (SktSms.FAILUREREASON)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_FAILUREREASON = " + cache_failurereason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_FAILUREREASON - update without value");
                skypeRef.events.FireOnSmsFailurereason(this, cache_failurereason);
                break;
                
            case 48: /* Sms.P_IS_FAILED_UNSEEN */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_is_failed_unseen = (Boolean)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_IS_FAILED_UNSEEN = " + cache_is_failed_unseen.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_IS_FAILED_UNSEEN - update without value");
                skypeRef.events.FireOnSmsIsFailedUnseen(this, cache_is_failed_unseen);
                break;
                
            case 198: /* Sms.P_TIMESTAMP */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_TIMESTAMP = " + cache_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_TIMESTAMP - update without value");
                skypeRef.events.FireOnSmsTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_timestamp));
                break;
                
            case 193: /* Sms.P_PRICE */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_price = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE = " + cache_price.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE - update without value");
                skypeRef.events.FireOnSmsPrice(this, cache_price);
                break;
                
            case 49: /* Sms.P_PRICE_PRECISION */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_price_precision = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE_PRECISION = " + cache_price_precision.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE_PRECISION - update without value");
                skypeRef.events.FireOnSmsPricePrecision(this, cache_price_precision);
                break;
                
            case 194: /* Sms.P_PRICE_CURRENCY */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_price_currency = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE_CURRENCY = " + cache_price_currency.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_PRICE_CURRENCY - update without value");
                skypeRef.events.FireOnSmsPriceCurrency(this, cache_price_currency);
                break;
                
            case 199: /* Sms.P_REPLY_TO_NUMBER */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_reply_to_number = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_REPLY_TO_NUMBER = " + cache_reply_to_number.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_REPLY_TO_NUMBER - update without value");
                skypeRef.events.FireOnSmsReplyToNumber(this, cache_reply_to_number);
                break;
                
            case 195: /* Sms.P_TARGET_NUMBERS */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_target_numbers = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_TARGET_NUMBERS = " + cache_target_numbers.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_TARGET_NUMBERS - update without value");
                skypeRef.events.FireOnSmsTargetNumbers(this, cache_target_numbers);
                break;
                
            case 196: /* Sms.P_TARGET_STATUSES */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_target_statuses = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_TARGET_STATUSES = binary size " + cache_target_statuses.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_TARGET_STATUSES - update without value");
                skypeRef.events.FireOnSmsTargetStatuses(this, cache_target_statuses);
                break;
                
            case 197: /* Sms.P_BODY */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_body = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_BODY = " + cache_body.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_BODY - update without value");
                skypeRef.events.FireOnSmsBody(this, cache_body);
                break;
                
            case 840: /* Sms.P_CHATMSG_ID */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_chatmsg_id = (SktMessage)value;
                    if (skypeRef.logging) skypeRef.Log("Sms.P_CHATMSG_ID = " + cache_chatmsg_id.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Sms.P_CHATMSG_ID - update without value");
                skypeRef.events.FireOnSmsChatmsgId(this, cache_chatmsg_id);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Sms class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktSms property accessors **/
    
    /**  See SktTYPE for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsType(SktSms sender, SktEvents.OnSmsTypeArgs e)</b></tt>
     */
    public SktSms.TYPE P_TYPE
    {
        get { if (!cache[0]) FetchTypeFromRuntime(); return cache_type; }
    }
    
    internal void FetchTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 190, this.OID);
        if (skypeRef.transport.PropResponseWasOk(190))
        {
            cache_type = (SktSms.TYPE)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktOUTGOING_REPLY_TYPE for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsOutgoingReplyType</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsOutgoingReplyType(SktSms sender, SktEvents.OnSmsOutgoingReplyTypeArgs e)</b></tt>
     */
    public SktSms.OUTGOING_REPLY_TYPE P_OUTGOING_REPLY_TYPE
    {
        get { if (!cache[1]) FetchOutgoingReplyTypeFromRuntime(); return cache_outgoing_reply_type; }
    }
    
    internal void FetchOutgoingReplyTypeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OUTGOING_REPLY_TYPE from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 1211, this.OID);
        if (skypeRef.transport.PropResponseWasOk(1211))
        {
            cache_outgoing_reply_type = (SktSms.OUTGOING_REPLY_TYPE)skypeRef.decoder.DecodeUint();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See SktSTATUS for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsStatus(SktSms sender, SktEvents.OnSmsStatusArgs e)</b></tt>
     */
    public SktSms.STATUS P_STATUS
    {
        get { if (!cache[2]) FetchStatusFromRuntime(); return cache_status; }
    }
    
    internal void FetchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 191, this.OID);
        if (skypeRef.transport.PropResponseWasOk(191))
        {
            cache_status = (SktSms.STATUS)skypeRef.decoder.DecodeUint();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Set asynchronously and meaningful only after invoking SktConversation.PostSMS and detecting SktSms.STATUS
      of SOME_TARGETS_FAILED or FAILED.
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsFailurereason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsFailurereason(SktSms sender, SktEvents.OnSmsFailurereasonArgs e)</b></tt>
     */
    public SktSms.FAILUREREASON P_FAILUREREASON
    {
        get { if (!cache[3]) FetchFailurereasonFromRuntime(); return cache_failurereason; }
    }
    
    internal void FetchFailurereasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FAILUREREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 192, this.OID);
        if (skypeRef.transport.PropResponseWasOk(192))
        {
            cache_failurereason = (SktSms.FAILUREREASON)skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  set to 1 when status goes to FAILED. use MarkSeen() to clear
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsIsFailedUnseen</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsIsFailedUnseen(SktSms sender, SktEvents.OnSmsIsFailedUnseenArgs e)</b></tt>
     */
    public Boolean P_IS_FAILED_UNSEEN
    {
        get { if (!cache[4]) FetchIsFailedUnseenFromRuntime(); return cache_is_failed_unseen; }
    }
    
    internal void FetchIsFailedUnseenFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_IS_FAILED_UNSEEN from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 48, this.OID);
        if (skypeRef.transport.PropResponseWasOk(48))
        {
            cache_is_failed_unseen = skypeRef.decoder.DecodeBool();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  unix timestamp of message submission
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsTimestamp(SktSms sender, SktEvents.OnSmsTimestampArgs e)</b></tt>
     */
    public DateTime P_TIMESTAMP
    {
        get { if (!cache[5]) FetchTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_timestamp); }
    }
    
    internal void FetchTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 198, this.OID);
        if (skypeRef.transport.PropResponseWasOk(198))
        {
            cache_timestamp = skypeRef.decoder.DecodeUint();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The total price of sending this SMS message (sum of the individual prices to send to each recipient).
      Defaults to -1 on instantiation and incremented by the price for each recipient once that recipient's
      status reflects TARGET_ACCEPTABLE. Use SktSms.GetTargetPrice to retrieve individual target prices. A value of MAX_UINT indicates that SkypeKit is actively querying and/or updating the value. Note that
      P_PRICE is an integer value. Calculate the actual price (in units specified by P_PRICE_CURRENCY) using
      P_PRICE_PRECISION as: @code actualPrice = price / 10^pricePrecision; @endcode
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsPrice</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsPrice(SktSms sender, SktEvents.OnSmsPriceArgs e)</b></tt>
     */
    public uint P_PRICE
    {
        get { if (!cache[6]) FetchPriceFromRuntime(); return cache_price; }
    }
    
    internal void FetchPriceFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PRICE from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 193, this.OID);
        if (skypeRef.transport.PropResponseWasOk(193))
        {
            cache_price = skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  The decimal precision of the SMS price values, both individual and total. For example, a value of 2 indicates
      that you should divide the price (represented as an integer) by 100 (10^2) to obtain the actual price.
     
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsPricePrecision</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsPricePrecision(SktSms sender, SktEvents.OnSmsPricePrecisionArgs e)</b></tt>
     */
    public uint P_PRICE_PRECISION
    {
        get { if (!cache[7]) FetchPricePrecisionFromRuntime(); return cache_price_precision; }
    }
    
    internal void FetchPricePrecisionFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PRICE_PRECISION from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 49, this.OID);
        if (skypeRef.transport.PropResponseWasOk(49))
        {
            cache_price_precision = skypeRef.decoder.DecodeUint();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  should be same as account currency at the time of composing/sending
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsPriceCurrency</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsPriceCurrency(SktSms sender, SktEvents.OnSmsPriceCurrencyArgs e)</b></tt>
     */
    public String P_PRICE_CURRENCY
    {
        get { if (!cache[8]) FetchPriceCurrencyFromRuntime(); return cache_price_currency; }
    }
    
    internal void FetchPriceCurrencyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PRICE_CURRENCY from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 194, this.OID);
        if (skypeRef.transport.PropResponseWasOk(194))
        {
            cache_price_currency = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  TYPE is outgoing: number that should receive the replies (DEPRECATED). TYPE is incoming: original source
      mobile number
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsReplyToNumber</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsReplyToNumber(SktSms sender, SktEvents.OnSmsReplyToNumberArgs e)</b></tt>
     */
    public String P_REPLY_TO_NUMBER
    {
        get { if (!cache[9]) FetchReplyToNumberFromRuntime(); return cache_reply_to_number; }
    }
    
    internal void FetchReplyToNumberFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_REPLY_TO_NUMBER from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 199, this.OID);
        if (skypeRef.transport.PropResponseWasOk(199))
        {
            cache_reply_to_number = skypeRef.decoder.DecodeString();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  space-separated normalised pstn numbers
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsTargetNumbers</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsTargetNumbers(SktSms sender, SktEvents.OnSmsTargetNumbersArgs e)</b></tt>
     */
    public String P_TARGET_NUMBERS
    {
        get { if (!cache[10]) FetchTargetNumbersFromRuntime(); return cache_target_numbers; }
    }
    
    internal void FetchTargetNumbersFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TARGET_NUMBERS from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 195, this.OID);
        if (skypeRef.transport.PropResponseWasOk(195))
        {
            cache_target_numbers = skypeRef.decoder.DecodeString();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  binary blob. track with OnPropertyChange(), access with GetTargetStatus(target)
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsTargetStatuses</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsTargetStatuses(SktSms sender, SktEvents.OnSmsTargetStatusesArgs e)</b></tt>
     */
    public byte[] P_TARGET_STATUSES
    {
        get { if (!cache[11]) FetchTargetStatusesFromRuntime(); return cache_target_statuses; }
    }
    
    internal void FetchTargetStatusesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TARGET_STATUSES from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 196, this.OID);
        if (skypeRef.transport.PropResponseWasOk(196))
        {
            cache_target_statuses = skypeRef.decoder.DecodeBinary();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  actual payload
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsBody</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsBody(SktSms sender, SktEvents.OnSmsBodyArgs e)</b></tt>
     */
    public String P_BODY
    {
        get { if (!cache[12]) FetchBodyFromRuntime(); return cache_body; }
    }
    
    internal void FetchBodyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BODY from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 197, this.OID);
        if (skypeRef.transport.PropResponseWasOk(197))
        {
            cache_body = skypeRef.decoder.DecodeString();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  reference to Message
     @n Assign your own event handler method to the <tt><b>skype.events.OnSmsChatmsgId</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnSmsChatmsgId(SktSms sender, SktEvents.OnSmsChatmsgIdArgs e)</b></tt>
     */
    public SktMessage P_CHATMSG_ID
    {
        get { if (!cache[13]) FetchChatmsgIdFromRuntime(); return cache_chatmsg_id; }
    }
    
    internal void FetchChatmsgIdFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CHATMSG_ID from runtime");
        skypeRef.transport.SubmitPropertyRequest(12, 840, this.OID);
        if (skypeRef.transport.PropResponseWasOk(840))
        {
            cache_chatmsg_id = (SktMessage)skypeRef.decoder.DecodeObject(9); // SktMessage class ID = 9
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktSms class PropKeys */
    
    public enum PropKeys 
    {
        P_TYPE                 =  190,
        P_OUTGOING_REPLY_TYPE  = 1211,
        P_STATUS               =  191,
        P_FAILUREREASON        =  192,
        P_IS_FAILED_UNSEEN     =   48,
        P_TIMESTAMP            =  198,
        P_PRICE                =  193,
        P_PRICE_PRECISION      =   49,
        P_PRICE_CURRENCY       =  194,
        P_REPLY_TO_NUMBER      =  199,
        P_TARGET_NUMBERS       =  195,
        P_TARGET_STATUSES      =  196,
        P_BODY                 =  197,
        P_CHATMSG_ID           =  840 
    }
    
    /* SktSms class enums */
    
    /**  TYPE
     */
    public enum TYPE
    {
        OUTGOING                    =    2, /*!< a normal outgoing SMS message */
        CONFIRMATION_CODE_REQUEST   =    3, /*!< a message requesting a SMS confirmation code be sent to the number provided */
        CONFIRMATION_CODE_SUBMIT    =    4  /*!< a message returning the SMS confirmation code received as a result of a CONFIRMATION_CODE_REQUEST to authorize it */
    }
    
    /**  OUTGOING_REPLY_TYPE
     */
    public enum OUTGOING_REPLY_TYPE
    {
        REPLY_SKYPENAME              =    1, /*!< outgoing Sms source ID is set to skypename (where applicable) */
        REPLY_USER_PHONE_NR          =    2, /*!< user's verified mobile nr is used as outgoing Sms source ID */
        REPLY_2WAY_AUTOASSIGNED_NR   =    3, /*!< outgoing Sms source ID was allocated from 2-way number pool */
        REPLY_TYPE_MIXED             =    4  /*!< outgoing Sms targets have different types, use GetTargetReplyType to see the real type */
    }
    
    /**  STATUS
     */
    public enum STATUS
    {
        COMPOSING             =    3, /*!< SMS can be edited and targets changed */
        SENDING_TO_SERVER     =    4, /*!< SMS is being sent currently to server */
        SENT_TO_SERVER        =    5, /*!< SMS has been sent to server, pending delivery notification */
        DELIVERED             =    6, /*!< SMS has been successfully delivered to all recipients */
        SOME_TARGETS_FAILED   =    7, /*!< SMS has been delivered to some recipients, but some failed */
        FAILED                =    8  /*!< SMS has not been delivered to any recipient */
    }
    
    /**  FAILUREREASON
     */
    public enum FAILUREREASON
    {
        MISC_ERROR                  =    1, /*!<   */
        SERVER_CONNECT_FAILED       =    2, /*!<   */
        NO_SMS_CAPABILITY           =    3, /*!<   */
        INSUFFICIENT_FUNDS          =    4, /*!<   */
        INVALID_CONFIRMATION_CODE   =    5, /*!<   */
        USER_BLOCKED                =    6, /*!<   */
        IP_BLOCKED                  =    7, /*!<   */
        NODE_BLOCKED                =    8, /*!<   */
        NO_SENDERID_CAPABILITY      =    9  /*!<   */
    }
    
    /**  this status shows target properties and usability for sending
     */
    public enum TARGETSTATUS
    {
        TARGET_ANALYZING             =    1, /*!<   */
        TARGET_UNDEFINED             =    2, /*!<   */
        TARGET_ACCEPTABLE            =    3, /*!<   */
        TARGET_NOT_ROUTABLE          =    4, /*!<   */
        TARGET_DELIVERY_PENDING      =    5, /*!<   */
        TARGET_DELIVERY_SUCCESSFUL   =    6, /*!<   */
        TARGET_DELIVERY_FAILED       =    7  /*!<   */
    }
    
    /**  SETBODYRESULT
     */
    public enum SETBODYRESULT
    {
        BODY_INVALID            =    0, /*!< body not set. message status wrong or invalid, or body not valid utf8 string */
        BODY_TRUNCATED          =    1, /*!< body too long. set, but truncated. charsUntilNextChunk contains maxChunks value */
        BODY_OK                 =    2, /*!< body was set OK */
        BODY_LASTCHAR_IGNORED   =    3  /*!< last unicode char was ignored, as some of the text would be deleted due to conversion */
    }
    
    /**  CONFIRM_TYPE
     */
    public enum CONFIRM_TYPE
    {
        ID_SMS       =    1, /*!< Confirm mobile number as SMS sender number */
        ID_MOBILE    =    2, /*!< Confirm mobile number as CLI for SkypeOut calls */
        ID_SKYPEIN   =    3  /*!< unused currently */
    }
    
    /* SktSms class methods */
    
    /**  Retrieves the send status of this SMS to a particular recipient (P_TARGET_STATUSES) either prior to or
      after invoking SktConversation.PostSMS.
        @returns status The send status of the target recipient, for example, TARGET_ANALYZING, TARGET_DELIVERY_PENDING, TARGET_DELIVERY_SUCCESSFUL, TARGET_DELIVERY_FAILED, and so forth. TARGET_UNDEFINED implies that the specified target is not a recipient of this SMS. 
        @param [in] target - The normalized phone number of the target recipient.
     */
    public SktSms.TARGETSTATUS GetTargetStatus (String target)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.GetTargetStatus");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 4, OID);
        skypeRef.encoder.AddStringParam(1, target);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSms.GetTargetStatus");
        return (SktSms.TARGETSTATUS)args[0];
    }
    
    /**  Call this when target has been delivered, to see what is the assigned number. Calling before target has
      been delivered shows preliminary assigned number, which may not be allocated (ie when delivery fails)
     
        @returns number
        @param [in] target
     */
    public String GetTargetReplyNumber (String target)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.GetTargetReplyNumber");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.encoder.AddStringParam(1, target);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSms.GetTargetReplyNumber");
        return (String)args[0];
    }
    
    /**  Fetch target reply type if toplevel Sms type is REPLY_TYPE_MIXED
        @returns type
        @param [in] target
     */
    public SktSms.OUTGOING_REPLY_TYPE GetTargetReplyType (String target)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.GetTargetReplyType");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.encoder.AddStringParam(1, target);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSms.GetTargetReplyType");
        return (SktSms.OUTGOING_REPLY_TYPE)args[0];
    }
    
    /**  Retrieves the amount of Skype credit necessary to send the SMS to a particular recipient. Defaults to
      -1 on instantiation and set only when that recipient's status reflects TARGET_ACCEPTABLE. Use SktSms.GetPropPrice
      to retrieve the total cost of this SMS. Note that the target price is an integer value. Calculate the
      actual price (in units specified by P_PRICE_CURRENCY) using P_PRICE_PRECISION as: @code actualTargetPrice = targetPrice / 10^pricePrecision; @endcode
        @returns price The price of sending this SMS message to the target recipient. 
        @param [in] target - The normalized phone number of the target recipient.
     */
    public uint GetTargetPrice (String target)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.GetTargetPrice");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.encoder.AddStringParam(1, target);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSms.GetTargetPrice");
        return (uint)args[0];
    }
    
    /**  Sets the recipient(s) of this SMS. Note that each invocation replaces the target list and re-calculates
      all prices - they are not additive!
        @returns success Set to true if the target list appears to contain valid, normalized telephone numbers. Note that this check is not very reliable. Actual target validity checking occurs asynchronously in the background, and manifests itself as a series of Sms::P_TARGET_STATUSES property change events. 
        @param [in] numbers - Normalized phone number(s) of the intended recipient(s).
     */
    public Boolean SetTargets (List<String> numbers)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.SetTargets");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddStringListParam(1, numbers);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = false;
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktSms.SetTargets");
        return (Boolean)args[0];
    }
    
    /**  -The- method for setting the body text of this SMS. While SktConversation.PostSMS does have a body argument,
      that argument is currently unused.
        @param [out] result Whether the Message body was successfully set and if not, why not. 
        @param [out] chunks The Message body as a list of individual chunks. 
        @param [out] charsUntilNextChunk Number of available characters until creation of the next chunk becomes necessary. 
        @param [in] text - Message body text.
     */
    public void SetBody (
        out SktSms.SETBODYRESULT result,
        out List<String> chunks,
        out uint    charsUntilNextChunk,
        String      text)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.SetBody");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddStringParam(1, text);
        result = 0;
        chunks = new List<String>(); // We always guarantee non-null list is returned
        charsUntilNextChunk = 0;
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSms.SetBody failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        result = (SktSms.SETBODYRESULT)skypeRef.decoder.DecodeInt();
                        break;
                    case 2:
                        chunks = skypeRef.decoder.DecodeStringList();
                        break;
                    case 3:
                        charsUntilNextChunk = skypeRef.decoder.DecodeUint();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSms.SetBody", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSms.SetBody
    
    /**  Retrieves string list of SMS text chunks in first argument, while the second argument contains the number
      of available characters until creation of the next chunk becomes necessary.
        @param [out] textChunks List of text chunk strings 
        @param [out] charsUntilNextChunk Number of available characters until creation of the next chunk becomes necessary. 
     */
    public void GetBodyChunks (out List<String> textChunks, out uint charsUntilNextChunk)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Sms.GetBodyChunks");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        textChunks = new List<String>(); // We always guarantee non-null list is returned
        charsUntilNextChunk = 0;
        skypeRef.transport.SubmitMethodRequest (RequestId);
        int argNr, marker;
        do
        {
            marker = (char)skypeRef.transport.ReadByte();
            if (marker != 'z')
            {
                if (marker == 'N') skypeRef.Error("SktSms.GetBodyChunks failed.");
                argNr = (char)skypeRef.transport.ReadByte();
                switch (argNr)
                {
                    case 1:
                        textChunks = skypeRef.decoder.DecodeStringList();
                        break;
                    case 2:
                        charsUntilNextChunk = skypeRef.decoder.DecodeUint();
                        break;
                    case 'z': marker = argNr; break; // exiting the arg loop if the method failed
                    default:
                        skypeRef.Error(String.Format("Got unexpected response argument {0} from runtime in SktSms.GetBodyChunks", argNr));
                        break;
                }
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromMethod();
    } // SktSms.GetBodyChunks
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Sms - the wrapper has no events for this class.");
    }
}

/*! \class SktAccount
  \brief
  Represents a local account. Encapsulates methods for Skype account creation, login and logout as well
  as account profile setting properties. NB! Unlike all the other SkypeKit classes, most of the Account
  class properties are actually read-write. @brief In fact, there are two sorts of Account's read-write
  properties: server-side properties and local properties. Different setter methods need to be used for
  those two kinds. The subset of server-side properties consists of all the policy properties (everything with _POLICY suffix)
  that are all of type int and can be set with SetServersideIntProperty method. There is currently only
  one server-side string property - OFFLINE_CALLFORWARD which can be set with SetServersideStrProperty
  setter. The set of writeable account profile properties (local profile) is as follows; 
  @li P_FULLNAME, 
  @li P_BIRTHDAY,
  
  @li P_GENDER, 
  @li P_LANGUAGES, 
  @li P_COUNTRY, 
  @li P_PROVINCE, 
  @li P_CITY, 
  @li P_PHONE_HOME, 
  @li P_PHONE_OFFICE,
  
  @li P_PHONE_MOBILE, 
  @li P_EMAILS, 
  @li P_HOMEPAGE, 
  @li P_ABOUT, 
  @li P_MOOD_TEXT, 
  @li P_TIMEZONE, 
  @li P_AVATAR_IMAGE,
  
  @li P_RICH_MOOD_TEXT These can be set with SetIntProperty, SetStrProperty and SetBinProperty setter methods. Note that there
  are special methods for changing account online status (availability) and enabling/disabling auto-login
  - SetAvailability and SetSavePwd. Note that to set Account properties, you that Account needs to be logged in. Generally, assumption is
  that the first thing you do with an Account object after you retrieve it with SktSkype.GetAccount is
  login, with exception of creating a new account. The Account class has no default constructor and creating an Account instance is not the same as creating
  a Skype account. To create a Skype account: 
  @li obtain an Account instance by invoking SktSkype.GetAccount. This automatically sets P_SKYPENAME.
  
  @li set any additional profile-related properties. Skype recommends that you minimally set the following:
  
  @li their email address so that they can retrieve a lost password (P_EMAILS) 
  @li the user's full name
  (P_FULLNAME) 
  @li at least one phone number (P_PHONE_HOME, P_PHONE_HOME, P_PHONE_OFFICE) 
  @li invoke SktAccount.Register
  to actually create the account
 */
public class SktAccount : SktObject
{
    public override String ClassName { get { return "Account"; } }
    
    public override uint ClassId { get { return 5; } }
    
    /** All derived classes should call this base from their own constructors.
        <b>Warning!</b> You cannot access class properties from within constructors.
     */
    public SktAccount (uint ObjectID, SktSkype Skype) : base (ObjectID, Skype)
    {
        cache = new BitArray(47);
    }
    
  
    /*! \class List
     *  \brief
     *  Use this class for lists that hold SktAccount objects.
     */
    public class List : SktObjectList
    {
        new public SktAccount this[int index]
        {
            get { return (SktAccount)base[index]; }
        }

        public void Add(SktAccount item)
        {
            base.Add((SktAccount)item);
        }
    }
    

    /* SktAccount property cache fields */
    private volatile SktAccount.STATUS             cache_status;
    private volatile SktAccount.PWDCHANGESTATUS    cache_pwdchangestatus;
    private volatile SktAccount.LOGOUTREASON       cache_logoutreason;
    private volatile SktAccount.COMMITSTATUS       cache_commitstatus;
    private volatile String                        cache_suggested_skypename;
    private volatile String                        cache_skypeout_balance_currency;
    private volatile uint                          cache_skypeout_balance;
    private volatile uint                          cache_skypeout_precision;
    private volatile String                        cache_skypein_numbers;
    private volatile SktAccount.CBLSYNCSTATUS      cache_cblsyncstatus;
    private volatile String                        cache_offline_callforward;
    private volatile SktAccount.CHATPOLICY         cache_chat_policy;
    private volatile SktAccount.SKYPECALLPOLICY    cache_skype_call_policy;
    private volatile SktAccount.PSTNCALLPOLICY     cache_pstn_call_policy;
    private volatile SktAccount.AVATARPOLICY       cache_avatar_policy;
    private volatile SktAccount.BUDDYCOUNTPOLICY   cache_buddycount_policy;
    private volatile SktAccount.TIMEZONEPOLICY     cache_timezone_policy;
    private volatile SktAccount.WEBPRESENCEPOLICY  cache_webpresence_policy;
    private volatile SktAccount.PHONENUMBERSPOLICY cache_phonenumbers_policy;
    private volatile SktAccount.VOICEMAILPOLICY    cache_voicemail_policy;
    private volatile String                        cache_partner_optedout;
    private volatile String                        cache_service_provider_info;
    private volatile uint                          cache_registration_timestamp;
    private volatile uint                          cache_nr_of_other_instances;
    private volatile String                        cache_skypename;
    private volatile String                        cache_fullname;
    private volatile uint                          cache_birthday;
    private volatile uint                          cache_gender;
    private volatile String                        cache_languages;
    private volatile String                        cache_country;
    private volatile String                        cache_province;
    private volatile String                        cache_city;
    private volatile String                        cache_phone_home;
    private volatile String                        cache_phone_office;
    private volatile String                        cache_phone_mobile;
    private volatile String                        cache_emails;
    private volatile String                        cache_homepage;
    private volatile String                        cache_about;
    private volatile uint                          cache_profile_timestamp;
    private volatile String                        cache_mood_text;
    private volatile uint                          cache_timezone;
    private volatile uint                          cache_nrof_authed_buddies;
    private volatile SktContact.AVAILABILITY       cache_availability;
    private volatile byte[]                        cache_avatar_image;
    private volatile uint                          cache_avatar_timestamp;
    private volatile uint                          cache_mood_timestamp;
    private volatile String                        cache_rich_mood_text;
    
    internal override uint MapPropIdToClassId(uint propId)
    {
        skypeRef.Error("MapPropIdToClassId called for Account - the wrapper has no object properties for this class.");
        return 0;
    }
    
    /** When the socket reader receives a property update from runtime, it decodes object ID
     * property ID and the new value of the property. It then calls this method of
     * the target object, to update the new value in property cache. After updating the cache,
     * this method then fires appropriate event in skype.events to notify the UI of what has happened.
     * DispatchPropertyUpdate is executed in the socket reader thread.
     */
    internal override void DispatchPropertyUpdate (uint propId, object value, bool hasValue)
    {
        switch (propId)
        {
            case 70: /* Account.P_STATUS */
                cache[0] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_status = (SktAccount.STATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_STATUS = " + cache_status.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_STATUS - update without value");
                skypeRef.events.FireOnAccountStatus(this, cache_status);
                break;
                
            case 71: /* Account.P_PWDCHANGESTATUS */
                cache[1] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_pwdchangestatus = (SktAccount.PWDCHANGESTATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PWDCHANGESTATUS = " + cache_pwdchangestatus.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PWDCHANGESTATUS - update without value");
                skypeRef.events.FireOnAccountPwdchangestatus(this, cache_pwdchangestatus);
                break;
                
            case 73: /* Account.P_LOGOUTREASON */
                cache[2] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_logoutreason = (SktAccount.LOGOUTREASON)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_LOGOUTREASON = " + cache_logoutreason.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_LOGOUTREASON - update without value");
                skypeRef.events.FireOnAccountLogoutreason(this, cache_logoutreason);
                break;
                
            case 78: /* Account.P_COMMITSTATUS */
                cache[3] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_commitstatus = (SktAccount.COMMITSTATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_COMMITSTATUS = " + cache_commitstatus.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_COMMITSTATUS - update without value");
                skypeRef.events.FireOnAccountCommitstatus(this, cache_commitstatus);
                break;
                
            case 72: /* Account.P_SUGGESTED_SKYPENAME */
                cache[4] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_suggested_skypename = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SUGGESTED_SKYPENAME = " + cache_suggested_skypename.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SUGGESTED_SKYPENAME - update without value");
                skypeRef.events.FireOnAccountSuggestedSkypename(this, cache_suggested_skypename);
                break;
                
            case 74: /* Account.P_SKYPEOUT_BALANCE_CURRENCY */
                cache[5] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypeout_balance_currency = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_BALANCE_CURRENCY = " + cache_skypeout_balance_currency.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_BALANCE_CURRENCY - update without value");
                skypeRef.events.FireOnAccountSkypeoutBalanceCurrency(this, cache_skypeout_balance_currency);
                break;
                
            case 75: /* Account.P_SKYPEOUT_BALANCE */
                cache[6] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypeout_balance = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_BALANCE = " + cache_skypeout_balance.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_BALANCE - update without value");
                skypeRef.events.FireOnAccountSkypeoutBalance(this, cache_skypeout_balance);
                break;
                
            case 804: /* Account.P_SKYPEOUT_PRECISION */
                cache[7] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypeout_precision = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_PRECISION = " + cache_skypeout_precision.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEOUT_PRECISION - update without value");
                skypeRef.events.FireOnAccountSkypeoutPrecision(this, cache_skypeout_precision);
                break;
                
            case 76: /* Account.P_SKYPEIN_NUMBERS */
                cache[8] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypein_numbers = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEIN_NUMBERS = " + cache_skypein_numbers.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPEIN_NUMBERS - update without value");
                skypeRef.events.FireOnAccountSkypeinNumbers(this, cache_skypein_numbers);
                break;
                
            case 79: /* Account.P_CBLSYNCSTATUS */
                cache[9] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_cblsyncstatus = (SktAccount.CBLSYNCSTATUS)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_CBLSYNCSTATUS = " + cache_cblsyncstatus.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_CBLSYNCSTATUS - update without value");
                skypeRef.events.FireOnAccountCblsyncstatus(this, cache_cblsyncstatus);
                break;
                
            case 77: /* Account.P_OFFLINE_CALLFORWARD */
                cache[10] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_offline_callforward = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_OFFLINE_CALLFORWARD = " + cache_offline_callforward.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_OFFLINE_CALLFORWARD - update without value");
                skypeRef.events.FireOnAccountOfflineCallforward(this, cache_offline_callforward);
                break;
                
            case 160: /* Account.P_CHAT_POLICY */
                cache[11] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_chat_policy = (SktAccount.CHATPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_CHAT_POLICY = " + cache_chat_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_CHAT_POLICY - update without value");
                skypeRef.events.FireOnAccountChatPolicy(this, cache_chat_policy);
                break;
                
            case 161: /* Account.P_SKYPE_CALL_POLICY */
                cache[12] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skype_call_policy = (SktAccount.SKYPECALLPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPE_CALL_POLICY = " + cache_skype_call_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPE_CALL_POLICY - update without value");
                skypeRef.events.FireOnAccountSkypeCallPolicy(this, cache_skype_call_policy);
                break;
                
            case 162: /* Account.P_PSTN_CALL_POLICY */
                cache[13] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_pstn_call_policy = (SktAccount.PSTNCALLPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PSTN_CALL_POLICY = " + cache_pstn_call_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PSTN_CALL_POLICY - update without value");
                skypeRef.events.FireOnAccountPstnCallPolicy(this, cache_pstn_call_policy);
                break;
                
            case 163: /* Account.P_AVATAR_POLICY */
                cache[14] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_avatar_policy = (SktAccount.AVATARPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_POLICY = " + cache_avatar_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_POLICY - update without value");
                skypeRef.events.FireOnAccountAvatarPolicy(this, cache_avatar_policy);
                break;
                
            case 164: /* Account.P_BUDDYCOUNT_POLICY */
                cache[15] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_buddycount_policy = (SktAccount.BUDDYCOUNTPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_BUDDYCOUNT_POLICY = " + cache_buddycount_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_BUDDYCOUNT_POLICY - update without value");
                skypeRef.events.FireOnAccountBuddycountPolicy(this, cache_buddycount_policy);
                break;
                
            case 165: /* Account.P_TIMEZONE_POLICY */
                cache[16] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timezone_policy = (SktAccount.TIMEZONEPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_TIMEZONE_POLICY = " + cache_timezone_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_TIMEZONE_POLICY - update without value");
                skypeRef.events.FireOnAccountTimezonePolicy(this, cache_timezone_policy);
                break;
                
            case 166: /* Account.P_WEBPRESENCE_POLICY */
                cache[17] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_webpresence_policy = (SktAccount.WEBPRESENCEPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_WEBPRESENCE_POLICY = " + cache_webpresence_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_WEBPRESENCE_POLICY - update without value");
                skypeRef.events.FireOnAccountWebpresencePolicy(this, cache_webpresence_policy);
                break;
                
            case 168: /* Account.P_PHONENUMBERS_POLICY */
                cache[18] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phonenumbers_policy = (SktAccount.PHONENUMBERSPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PHONENUMBERS_POLICY = " + cache_phonenumbers_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PHONENUMBERS_POLICY - update without value");
                skypeRef.events.FireOnAccountPhonenumbersPolicy(this, cache_phonenumbers_policy);
                break;
                
            case 169: /* Account.P_VOICEMAIL_POLICY */
                cache[19] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_voicemail_policy = (SktAccount.VOICEMAILPOLICY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_VOICEMAIL_POLICY = " + cache_voicemail_policy.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_VOICEMAIL_POLICY - update without value");
                skypeRef.events.FireOnAccountVoicemailPolicy(this, cache_voicemail_policy);
                break;
                
            case 773: /* Account.P_PARTNER_OPTEDOUT */
                cache[20] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_partner_optedout = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PARTNER_OPTEDOUT = " + cache_partner_optedout.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PARTNER_OPTEDOUT - update without value");
                skypeRef.events.FireOnAccountPartnerOptedout(this, cache_partner_optedout);
                break;
                
            case 800: /* Account.P_SERVICE_PROVIDER_INFO */
                cache[21] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_service_provider_info = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SERVICE_PROVIDER_INFO = " + cache_service_provider_info.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SERVICE_PROVIDER_INFO - update without value");
                skypeRef.events.FireOnAccountServiceProviderInfo(this, cache_service_provider_info);
                break;
                
            case 801: /* Account.P_REGISTRATION_TIMESTAMP */
                cache[22] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_registration_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_REGISTRATION_TIMESTAMP = " + cache_registration_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_REGISTRATION_TIMESTAMP - update without value");
                skypeRef.events.FireOnAccountRegistrationTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_registration_timestamp));
                break;
                
            case 802: /* Account.P_NR_OF_OTHER_INSTANCES */
                cache[23] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_nr_of_other_instances = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_NR_OF_OTHER_INSTANCES = " + cache_nr_of_other_instances.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_NR_OF_OTHER_INSTANCES - update without value");
                skypeRef.events.FireOnAccountNrOfOtherInstances(this, cache_nr_of_other_instances);
                break;
                
            case 4: /* Account.P_SKYPENAME */
                cache[24] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_skypename = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_SKYPENAME = " + cache_skypename.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_SKYPENAME - update without value");
                skypeRef.events.FireOnAccountSkypename(this, cache_skypename);
                break;
                
            case 5: /* Account.P_FULLNAME */
                cache[25] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_fullname = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_FULLNAME = " + cache_fullname.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_FULLNAME - update without value");
                skypeRef.events.FireOnAccountFullname(this, cache_fullname);
                break;
                
            case 7: /* Account.P_BIRTHDAY */
                cache[26] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_birthday = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_BIRTHDAY = " + cache_birthday.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_BIRTHDAY - update without value");
                skypeRef.events.FireOnAccountBirthday(this, cache_birthday);
                break;
                
            case 8: /* Account.P_GENDER */
                cache[27] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_gender = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_GENDER = " + cache_gender.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_GENDER - update without value");
                skypeRef.events.FireOnAccountGender(this, cache_gender);
                break;
                
            case 9: /* Account.P_LANGUAGES */
                cache[28] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_languages = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_LANGUAGES = " + cache_languages.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_LANGUAGES - update without value");
                skypeRef.events.FireOnAccountLanguages(this, cache_languages);
                break;
                
            case 10: /* Account.P_COUNTRY */
                cache[29] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_country = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_COUNTRY = " + cache_country.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_COUNTRY - update without value");
                skypeRef.events.FireOnAccountCountry(this, cache_country);
                break;
                
            case 11: /* Account.P_PROVINCE */
                cache[30] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_province = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PROVINCE = " + cache_province.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PROVINCE - update without value");
                skypeRef.events.FireOnAccountProvince(this, cache_province);
                break;
                
            case 12: /* Account.P_CITY */
                cache[31] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_city = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_CITY = " + cache_city.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_CITY - update without value");
                skypeRef.events.FireOnAccountCity(this, cache_city);
                break;
                
            case 13: /* Account.P_PHONE_HOME */
                cache[32] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_home = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_HOME = " + cache_phone_home.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_HOME - update without value");
                skypeRef.events.FireOnAccountPhoneHome(this, cache_phone_home);
                break;
                
            case 14: /* Account.P_PHONE_OFFICE */
                cache[33] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_office = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_OFFICE = " + cache_phone_office.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_OFFICE - update without value");
                skypeRef.events.FireOnAccountPhoneOffice(this, cache_phone_office);
                break;
                
            case 15: /* Account.P_PHONE_MOBILE */
                cache[34] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_phone_mobile = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_MOBILE = " + cache_phone_mobile.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PHONE_MOBILE - update without value");
                skypeRef.events.FireOnAccountPhoneMobile(this, cache_phone_mobile);
                break;
                
            case 16: /* Account.P_EMAILS */
                cache[35] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_emails = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_EMAILS = " + cache_emails.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_EMAILS - update without value");
                skypeRef.events.FireOnAccountEmails(this, cache_emails);
                break;
                
            case 17: /* Account.P_HOMEPAGE */
                cache[36] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_homepage = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_HOMEPAGE = " + cache_homepage.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_HOMEPAGE - update without value");
                skypeRef.events.FireOnAccountHomepage(this, cache_homepage);
                break;
                
            case 18: /* Account.P_ABOUT */
                cache[37] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_about = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_ABOUT = " + cache_about.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_ABOUT - update without value");
                skypeRef.events.FireOnAccountAbout(this, cache_about);
                break;
                
            case 19: /* Account.P_PROFILE_TIMESTAMP */
                cache[38] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_profile_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_PROFILE_TIMESTAMP = " + cache_profile_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_PROFILE_TIMESTAMP - update without value");
                skypeRef.events.FireOnAccountProfileTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_profile_timestamp));
                break;
                
            case 26: /* Account.P_MOOD_TEXT */
                cache[39] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_mood_text = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_MOOD_TEXT = " + cache_mood_text.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_MOOD_TEXT - update without value");
                skypeRef.events.FireOnAccountMoodText(this, cache_mood_text);
                break;
                
            case 27: /* Account.P_TIMEZONE */
                cache[40] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_timezone = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_TIMEZONE = " + cache_timezone.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_TIMEZONE - update without value");
                skypeRef.events.FireOnAccountTimezone(this, cache_timezone);
                break;
                
            case 28: /* Account.P_NROF_AUTHED_BUDDIES */
                cache[41] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_nrof_authed_buddies = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_NROF_AUTHED_BUDDIES = " + cache_nrof_authed_buddies.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_NROF_AUTHED_BUDDIES - update without value");
                skypeRef.events.FireOnAccountNrofAuthedBuddies(this, cache_nrof_authed_buddies);
                break;
                
            case 34: /* Account.P_AVAILABILITY */
                cache[42] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_availability = (SktContact.AVAILABILITY)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_AVAILABILITY = " + cache_availability.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_AVAILABILITY - update without value");
                skypeRef.events.FireOnAccountAvailability(this, cache_availability);
                break;
                
            case 37: /* Account.P_AVATAR_IMAGE */
                cache[43] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_avatar_image = (byte[])value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_IMAGE = binary size " + cache_avatar_image.Length.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_IMAGE - update without value");
                skypeRef.events.FireOnAccountAvatarImage(this, cache_avatar_image);
                break;
                
            case 182: /* Account.P_AVATAR_TIMESTAMP */
                cache[44] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_avatar_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_TIMESTAMP = " + cache_avatar_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_AVATAR_TIMESTAMP - update without value");
                skypeRef.events.FireOnAccountAvatarTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_avatar_timestamp));
                break;
                
            case 183: /* Account.P_MOOD_TIMESTAMP */
                cache[45] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_mood_timestamp = (uint)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_MOOD_TIMESTAMP = " + cache_mood_timestamp.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_MOOD_TIMESTAMP - update without value");
                skypeRef.events.FireOnAccountMoodTimestamp(this, skypeRef.UnixTimestampToDateTime(cache_mood_timestamp));
                break;
                
            case 205: /* Account.P_RICH_MOOD_TEXT */
                cache[46] = hasValue; // if no value - invalidate cache
                if (hasValue)
                {
                    cache_rich_mood_text = (String)value;
                    if (skypeRef.logging) skypeRef.Log("Account.P_RICH_MOOD_TEXT = " + cache_rich_mood_text.ToString());
                }
                else if (skypeRef.logging) skypeRef.Log("Account.P_RICH_MOOD_TEXT - update without value");
                skypeRef.events.FireOnAccountRichMoodText(this, cache_rich_mood_text);
                break;
                
            default:
                skypeRef.Error(String.Format("Invalid Account class property ID ({0})received from socket.", propId)); break;
        }
    }
    
    /** SktAccount property accessors **/
    
    /**  SktAccount.STATUS
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountStatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountStatus(SktAccount sender, SktEvents.OnAccountStatusArgs e)</b></tt>
     */
    public SktAccount.STATUS P_STATUS
    {
        get { if (!cache[0]) FetchStatusFromRuntime(); return cache_status; }
    }
    
    internal void FetchStatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_STATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 70, this.OID);
        if (skypeRef.transport.PropResponseWasOk(70))
        {
            cache_status = (SktAccount.STATUS)skypeRef.decoder.DecodeUint();
            cache[0] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktAccount.PWDCHANGESTATUS
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPwdchangestatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPwdchangestatus(SktAccount sender, SktEvents.OnAccountPwdchangestatusArgs e)</b></tt>
     */
    public SktAccount.PWDCHANGESTATUS P_PWDCHANGESTATUS
    {
        get { if (!cache[1]) FetchPwdchangestatusFromRuntime(); return cache_pwdchangestatus; }
    }
    
    internal void FetchPwdchangestatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PWDCHANGESTATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 71, this.OID);
        if (skypeRef.transport.PropResponseWasOk(71))
        {
            cache_pwdchangestatus = (SktAccount.PWDCHANGESTATUS)skypeRef.decoder.DecodeUint();
            cache[1] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This property should only be examined when SktAccount.P_STATUS is LOGGED_OUT or LOGGED_OUT_AND_PWD_SAVED.
      That is, you should not monitor changes to this property in SktAccount.OnChange callback, other than
      after already having checked that P_STATUS property has appropriate value. The reason for this is that
      the LOGOUTREASON does not get reset before the next login attempt. For example: if a user tried to log
      in with a wrong password, the LOGOUTREASON gets set to INCORRECT_PASSWORD. Now, if the user tries to
      log in again, and yet again submits an incorrect password, the value of the LOGOUTREASON does not change
      anymore, because it already is set to INCORRECT_PASSWORD. Consequently, SktAccount.OnChange will not
      fire in this case.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountLogoutreason</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountLogoutreason(SktAccount sender, SktEvents.OnAccountLogoutreasonArgs e)</b></tt>
     */
    public SktAccount.LOGOUTREASON P_LOGOUTREASON
    {
        get { if (!cache[2]) FetchLogoutreasonFromRuntime(); return cache_logoutreason; }
    }
    
    internal void FetchLogoutreasonFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LOGOUTREASON from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 73, this.OID);
        if (skypeRef.transport.PropResponseWasOk(73))
        {
            cache_logoutreason = (SktAccount.LOGOUTREASON)skypeRef.decoder.DecodeUint();
            cache[2] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktAccount.COMMITSTATUS
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountCommitstatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountCommitstatus(SktAccount sender, SktEvents.OnAccountCommitstatusArgs e)</b></tt>
     */
    public SktAccount.COMMITSTATUS P_COMMITSTATUS
    {
        get { if (!cache[3]) FetchCommitstatusFromRuntime(); return cache_commitstatus; }
    }
    
    internal void FetchCommitstatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_COMMITSTATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 78, this.OID);
        if (skypeRef.transport.PropResponseWasOk(78))
        {
            cache_commitstatus = (SktAccount.COMMITSTATUS)skypeRef.decoder.DecodeUint();
            cache[3] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  suggested skypenames, semi-colon separated. present if logoutreason==SKYPENAME_TAKEN
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSuggestedSkypename</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSuggestedSkypename(SktAccount sender, SktEvents.OnAccountSuggestedSkypenameArgs e)</b></tt>
     */
    public String P_SUGGESTED_SKYPENAME
    {
        get { if (!cache[4]) FetchSuggestedSkypenameFromRuntime(); return cache_suggested_skypename; }
    }
    
    internal void FetchSuggestedSkypenameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SUGGESTED_SKYPENAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 72, this.OID);
        if (skypeRef.transport.PropResponseWasOk(72))
        {
            cache_suggested_skypename = skypeRef.decoder.DecodeString();
            cache[4] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  'EUR', 'USD', etc.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypeoutBalanceCurrency</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypeoutBalanceCurrency(SktAccount sender, SktEvents.OnAccountSkypeoutBalanceCurrencyArgs e)</b></tt>
     */
    public String P_SKYPEOUT_BALANCE_CURRENCY
    {
        get { if (!cache[5]) FetchSkypeoutBalanceCurrencyFromRuntime(); return cache_skypeout_balance_currency; }
    }
    
    internal void FetchSkypeoutBalanceCurrencyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPEOUT_BALANCE_CURRENCY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 74, this.OID);
        if (skypeRef.transport.PropResponseWasOk(74))
        {
            cache_skypeout_balance_currency = skypeRef.decoder.DecodeString();
            cache[5] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  balance in 'cents'
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypeoutBalance</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypeoutBalance(SktAccount sender, SktEvents.OnAccountSkypeoutBalanceArgs e)</b></tt>
     */
    public uint P_SKYPEOUT_BALANCE
    {
        get { if (!cache[6]) FetchSkypeoutBalanceFromRuntime(); return cache_skypeout_balance; }
    }
    
    internal void FetchSkypeoutBalanceFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPEOUT_BALANCE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 75, this.OID);
        if (skypeRef.transport.PropResponseWasOk(75))
        {
            cache_skypeout_balance = skypeRef.decoder.DecodeUint();
            cache[6] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  decimal points in ACCOUNT_SKYPEOUT_BALANCE
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypeoutPrecision</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypeoutPrecision(SktAccount sender, SktEvents.OnAccountSkypeoutPrecisionArgs e)</b></tt>
     */
    public uint P_SKYPEOUT_PRECISION
    {
        get { if (!cache[7]) FetchSkypeoutPrecisionFromRuntime(); return cache_skypeout_precision; }
    }
    
    internal void FetchSkypeoutPrecisionFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPEOUT_PRECISION from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 804, this.OID);
        if (skypeRef.transport.PropResponseWasOk(804))
        {
            cache_skypeout_precision = skypeRef.decoder.DecodeUint();
            cache[7] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  space-separated list of skypein numbers
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypeinNumbers</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypeinNumbers(SktAccount sender, SktEvents.OnAccountSkypeinNumbersArgs e)</b></tt>
     */
    public String P_SKYPEIN_NUMBERS
    {
        get { if (!cache[8]) FetchSkypeinNumbersFromRuntime(); return cache_skypein_numbers; }
    }
    
    internal void FetchSkypeinNumbersFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPEIN_NUMBERS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 76, this.OID);
        if (skypeRef.transport.PropResponseWasOk(76))
        {
            cache_skypein_numbers = skypeRef.decoder.DecodeString();
            cache[8] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktAccount.CBLSYNCSTATUS
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountCblsyncstatus</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountCblsyncstatus(SktAccount sender, SktEvents.OnAccountCblsyncstatusArgs e)</b></tt>
     */
    public SktAccount.CBLSYNCSTATUS P_CBLSYNCSTATUS
    {
        get { if (!cache[9]) FetchCblsyncstatusFromRuntime(); return cache_cblsyncstatus; }
    }
    
    internal void FetchCblsyncstatusFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CBLSYNCSTATUS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 79, this.OID);
        if (skypeRef.transport.PropResponseWasOk(79))
        {
            cache_cblsyncstatus = (SktAccount.CBLSYNCSTATUS)skypeRef.decoder.DecodeUint();
            cache[9] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  space-separated list of 'begSecond,endSecond,identity' tokens
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountOfflineCallforward</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountOfflineCallforward(SktAccount sender, SktEvents.OnAccountOfflineCallforwardArgs e)</b></tt>
     */
    public String P_OFFLINE_CALLFORWARD
    {
        get { if (!cache[10]) FetchOfflineCallforwardFromRuntime(); return cache_offline_callforward; }
    }
    
    internal void FetchOfflineCallforwardFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_OFFLINE_CALLFORWARD from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 77, this.OID);
        if (skypeRef.transport.PropResponseWasOk(77))
        {
            cache_offline_callforward = skypeRef.decoder.DecodeString();
            cache[10] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountChatPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountChatPolicy(SktAccount sender, SktEvents.OnAccountChatPolicyArgs e)</b></tt>
     */
    public SktAccount.CHATPOLICY P_CHAT_POLICY
    {
        get { if (!cache[11]) FetchChatPolicyFromRuntime(); return cache_chat_policy; }
    }
    
    internal void FetchChatPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CHAT_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 160, this.OID);
        if (skypeRef.transport.PropResponseWasOk(160))
        {
            cache_chat_policy = (SktAccount.CHATPOLICY)skypeRef.decoder.DecodeUint();
            cache[11] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypeCallPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypeCallPolicy(SktAccount sender, SktEvents.OnAccountSkypeCallPolicyArgs e)</b></tt>
     */
    public SktAccount.SKYPECALLPOLICY P_SKYPE_CALL_POLICY
    {
        get { if (!cache[12]) FetchSkypeCallPolicyFromRuntime(); return cache_skype_call_policy; }
    }
    
    internal void FetchSkypeCallPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPE_CALL_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 161, this.OID);
        if (skypeRef.transport.PropResponseWasOk(161))
        {
            cache_skype_call_policy = (SktAccount.SKYPECALLPOLICY)skypeRef.decoder.DecodeUint();
            cache[12] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPstnCallPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPstnCallPolicy(SktAccount sender, SktEvents.OnAccountPstnCallPolicyArgs e)</b></tt>
     */
    public SktAccount.PSTNCALLPOLICY P_PSTN_CALL_POLICY
    {
        get { if (!cache[13]) FetchPstnCallPolicyFromRuntime(); return cache_pstn_call_policy; }
    }
    
    internal void FetchPstnCallPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PSTN_CALL_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 162, this.OID);
        if (skypeRef.transport.PropResponseWasOk(162))
        {
            cache_pstn_call_policy = (SktAccount.PSTNCALLPOLICY)skypeRef.decoder.DecodeUint();
            cache[13] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountAvatarPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountAvatarPolicy(SktAccount sender, SktEvents.OnAccountAvatarPolicyArgs e)</b></tt>
     */
    public SktAccount.AVATARPOLICY P_AVATAR_POLICY
    {
        get { if (!cache[14]) FetchAvatarPolicyFromRuntime(); return cache_avatar_policy; }
    }
    
    internal void FetchAvatarPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVATAR_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 163, this.OID);
        if (skypeRef.transport.PropResponseWasOk(163))
        {
            cache_avatar_policy = (SktAccount.AVATARPOLICY)skypeRef.decoder.DecodeUint();
            cache[14] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountBuddycountPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountBuddycountPolicy(SktAccount sender, SktEvents.OnAccountBuddycountPolicyArgs e)</b></tt>
     */
    public SktAccount.BUDDYCOUNTPOLICY P_BUDDYCOUNT_POLICY
    {
        get { if (!cache[15]) FetchBuddycountPolicyFromRuntime(); return cache_buddycount_policy; }
    }
    
    internal void FetchBuddycountPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BUDDYCOUNT_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 164, this.OID);
        if (skypeRef.transport.PropResponseWasOk(164))
        {
            cache_buddycount_policy = (SktAccount.BUDDYCOUNTPOLICY)skypeRef.decoder.DecodeUint();
            cache[15] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountTimezonePolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountTimezonePolicy(SktAccount sender, SktEvents.OnAccountTimezonePolicyArgs e)</b></tt>
     */
    public SktAccount.TIMEZONEPOLICY P_TIMEZONE_POLICY
    {
        get { if (!cache[16]) FetchTimezonePolicyFromRuntime(); return cache_timezone_policy; }
    }
    
    internal void FetchTimezonePolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMEZONE_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 165, this.OID);
        if (skypeRef.transport.PropResponseWasOk(165))
        {
            cache_timezone_policy = (SktAccount.TIMEZONEPOLICY)skypeRef.decoder.DecodeUint();
            cache[16] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountWebpresencePolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountWebpresencePolicy(SktAccount sender, SktEvents.OnAccountWebpresencePolicyArgs e)</b></tt>
     */
    public SktAccount.WEBPRESENCEPOLICY P_WEBPRESENCE_POLICY
    {
        get { if (!cache[17]) FetchWebpresencePolicyFromRuntime(); return cache_webpresence_policy; }
    }
    
    internal void FetchWebpresencePolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_WEBPRESENCE_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 166, this.OID);
        if (skypeRef.transport.PropResponseWasOk(166))
        {
            cache_webpresence_policy = (SktAccount.WEBPRESENCEPOLICY)skypeRef.decoder.DecodeUint();
            cache[17] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPhonenumbersPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPhonenumbersPolicy(SktAccount sender, SktEvents.OnAccountPhonenumbersPolicyArgs e)</b></tt>
     */
    public SktAccount.PHONENUMBERSPOLICY P_PHONENUMBERS_POLICY
    {
        get { if (!cache[18]) FetchPhonenumbersPolicyFromRuntime(); return cache_phonenumbers_policy; }
    }
    
    internal void FetchPhonenumbersPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONENUMBERS_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 168, this.OID);
        if (skypeRef.transport.PropResponseWasOk(168))
        {
            cache_phonenumbers_policy = (SktAccount.PHONENUMBERSPOLICY)skypeRef.decoder.DecodeUint();
            cache[18] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Server-side account property, use SetServerside*Property() to set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountVoicemailPolicy</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountVoicemailPolicy(SktAccount sender, SktEvents.OnAccountVoicemailPolicyArgs e)</b></tt>
     */
    public SktAccount.VOICEMAILPOLICY P_VOICEMAIL_POLICY
    {
        get { if (!cache[19]) FetchVoicemailPolicyFromRuntime(); return cache_voicemail_policy; }
    }
    
    internal void FetchVoicemailPolicyFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_VOICEMAIL_POLICY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 169, this.OID);
        if (skypeRef.transport.PropResponseWasOk(169))
        {
            cache_voicemail_policy = (SktAccount.VOICEMAILPOLICY)skypeRef.decoder.DecodeUint();
            cache[19] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Alerts: opted out partner id's, space separated
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPartnerOptedout</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPartnerOptedout(SktAccount sender, SktEvents.OnAccountPartnerOptedoutArgs e)</b></tt>
     */
    public String P_PARTNER_OPTEDOUT
    {
        get { if (!cache[20]) FetchPartnerOptedoutFromRuntime(); return cache_partner_optedout; }
    }
    
    internal void FetchPartnerOptedoutFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PARTNER_OPTEDOUT from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 773, this.OID);
        if (skypeRef.transport.PropResponseWasOk(773))
        {
            cache_partner_optedout = skypeRef.decoder.DecodeString();
            cache[20] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  service information if the user is a paid service provider
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountServiceProviderInfo</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountServiceProviderInfo(SktAccount sender, SktEvents.OnAccountServiceProviderInfoArgs e)</b></tt>
     */
    public String P_SERVICE_PROVIDER_INFO
    {
        get { if (!cache[21]) FetchServiceProviderInfoFromRuntime(); return cache_service_provider_info; }
    }
    
    internal void FetchServiceProviderInfoFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SERVICE_PROVIDER_INFO from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 800, this.OID);
        if (skypeRef.transport.PropResponseWasOk(800))
        {
            cache_service_provider_info = skypeRef.decoder.DecodeString();
            cache[21] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  NB! Unlike your common UNIX timestamps, the registration_timestamp is special, as it counts MINUTES rather
      than seconds, from Epoch (January 1, 1970)
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountRegistrationTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountRegistrationTimestamp(SktAccount sender, SktEvents.OnAccountRegistrationTimestampArgs e)</b></tt>
     */
    public DateTime P_REGISTRATION_TIMESTAMP
    {
        get { if (!cache[22]) FetchRegistrationTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_registration_timestamp); }
    }
    
    internal void FetchRegistrationTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_REGISTRATION_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 801, this.OID);
        if (skypeRef.transport.PropResponseWasOk(801))
        {
            cache_registration_timestamp = skypeRef.decoder.DecodeUint();
            cache[22] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  number of times this user is logged in from other computers
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountNrOfOtherInstances</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountNrOfOtherInstances(SktAccount sender, SktEvents.OnAccountNrOfOtherInstancesArgs e)</b></tt>
     */
    public uint P_NR_OF_OTHER_INSTANCES
    {
        get { if (!cache[23]) FetchNrOfOtherInstancesFromRuntime(); return cache_nr_of_other_instances; }
    }
    
    internal void FetchNrOfOtherInstancesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_NR_OF_OTHER_INSTANCES from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 802, this.OID);
        if (skypeRef.transport.PropResponseWasOk(802))
        {
            cache_nr_of_other_instances = skypeRef.decoder.DecodeUint();
            cache[23] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountSkypename</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountSkypename(SktAccount sender, SktEvents.OnAccountSkypenameArgs e)</b></tt>
     */
    public String P_SKYPENAME
    {
        get { if (!cache[24]) FetchSkypenameFromRuntime(); return cache_skypename; }
    }
    
    internal void FetchSkypenameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_SKYPENAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 4, this.OID);
        if (skypeRef.transport.PropResponseWasOk(4))
        {
            cache_skypename = skypeRef.decoder.DecodeString();
            cache[24] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountFullname</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountFullname(SktAccount sender, SktEvents.OnAccountFullnameArgs e)</b></tt>
     */
    public String P_FULLNAME
    {
        get { if (!cache[25]) FetchFullnameFromRuntime(); return cache_fullname; }
    }
    
    internal void FetchFullnameFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_FULLNAME from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 5, this.OID);
        if (skypeRef.transport.PropResponseWasOk(5))
        {
            cache_fullname = skypeRef.decoder.DecodeString();
            cache[25] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  YYYYMMDD
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountBirthday</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountBirthday(SktAccount sender, SktEvents.OnAccountBirthdayArgs e)</b></tt>
     */
    public uint P_BIRTHDAY
    {
        get { if (!cache[26]) FetchBirthdayFromRuntime(); return cache_birthday; }
    }
    
    internal void FetchBirthdayFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_BIRTHDAY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 7, this.OID);
        if (skypeRef.transport.PropResponseWasOk(7))
        {
            cache_birthday = skypeRef.decoder.DecodeUint();
            cache[26] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  1-male, 2-female
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountGender</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountGender(SktAccount sender, SktEvents.OnAccountGenderArgs e)</b></tt>
     */
    public uint P_GENDER
    {
        get { if (!cache[27]) FetchGenderFromRuntime(); return cache_gender; }
    }
    
    internal void FetchGenderFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_GENDER from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 8, this.OID);
        if (skypeRef.transport.PropResponseWasOk(8))
        {
            cache_gender = skypeRef.decoder.DecodeUint();
            cache[27] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ISO language codes, space-separated
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountLanguages</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountLanguages(SktAccount sender, SktEvents.OnAccountLanguagesArgs e)</b></tt>
     */
    public String P_LANGUAGES
    {
        get { if (!cache[28]) FetchLanguagesFromRuntime(); return cache_languages; }
    }
    
    internal void FetchLanguagesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_LANGUAGES from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 9, this.OID);
        if (skypeRef.transport.PropResponseWasOk(9))
        {
            cache_languages = skypeRef.decoder.DecodeString();
            cache[28] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  ISO country code
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountCountry</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountCountry(SktAccount sender, SktEvents.OnAccountCountryArgs e)</b></tt>
     */
    public String P_COUNTRY
    {
        get { if (!cache[29]) FetchCountryFromRuntime(); return cache_country; }
    }
    
    internal void FetchCountryFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_COUNTRY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 10, this.OID);
        if (skypeRef.transport.PropResponseWasOk(10))
        {
            cache_country = skypeRef.decoder.DecodeString();
            cache[29] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountProvince</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountProvince(SktAccount sender, SktEvents.OnAccountProvinceArgs e)</b></tt>
     */
    public String P_PROVINCE
    {
        get { if (!cache[30]) FetchProvinceFromRuntime(); return cache_province; }
    }
    
    internal void FetchProvinceFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PROVINCE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 11, this.OID);
        if (skypeRef.transport.PropResponseWasOk(11))
        {
            cache_province = skypeRef.decoder.DecodeString();
            cache[30] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountCity</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountCity(SktAccount sender, SktEvents.OnAccountCityArgs e)</b></tt>
     */
    public String P_CITY
    {
        get { if (!cache[31]) FetchCityFromRuntime(); return cache_city; }
    }
    
    internal void FetchCityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_CITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 12, this.OID);
        if (skypeRef.transport.PropResponseWasOk(12))
        {
            cache_city = skypeRef.decoder.DecodeString();
            cache[31] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  NB! string not integer
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPhoneHome</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPhoneHome(SktAccount sender, SktEvents.OnAccountPhoneHomeArgs e)</b></tt>
     */
    public String P_PHONE_HOME
    {
        get { if (!cache[32]) FetchPhoneHomeFromRuntime(); return cache_phone_home; }
    }
    
    internal void FetchPhoneHomeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_HOME from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 13, this.OID);
        if (skypeRef.transport.PropResponseWasOk(13))
        {
            cache_phone_home = skypeRef.decoder.DecodeString();
            cache[32] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPhoneOffice</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPhoneOffice(SktAccount sender, SktEvents.OnAccountPhoneOfficeArgs e)</b></tt>
     */
    public String P_PHONE_OFFICE
    {
        get { if (!cache[33]) FetchPhoneOfficeFromRuntime(); return cache_phone_office; }
    }
    
    internal void FetchPhoneOfficeFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_OFFICE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 14, this.OID);
        if (skypeRef.transport.PropResponseWasOk(14))
        {
            cache_phone_office = skypeRef.decoder.DecodeString();
            cache[33] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountPhoneMobile</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountPhoneMobile(SktAccount sender, SktEvents.OnAccountPhoneMobileArgs e)</b></tt>
     */
    public String P_PHONE_MOBILE
    {
        get { if (!cache[34]) FetchPhoneMobileFromRuntime(); return cache_phone_mobile; }
    }
    
    internal void FetchPhoneMobileFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PHONE_MOBILE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 15, this.OID);
        if (skypeRef.transport.PropResponseWasOk(15))
        {
            cache_phone_mobile = skypeRef.decoder.DecodeString();
            cache[34] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  This is a string property, that contains space-separated list of email addresses. When surfacing this
      property in your UI, you will need to take into account that there may be more than one email addresses
      in this property (i.e. split the value at spaces and display them as list). Similarly, when modifying
      this property with SetStrProperty method, your editor should allow editing of component email addresses
      separately and add them all up again, before submitting back to the account.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountEmails</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountEmails(SktAccount sender, SktEvents.OnAccountEmailsArgs e)</b></tt>
     */
    public String P_EMAILS
    {
        get { if (!cache[35]) FetchEmailsFromRuntime(); return cache_emails; }
    }
    
    internal void FetchEmailsFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_EMAILS from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 16, this.OID);
        if (skypeRef.transport.PropResponseWasOk(16))
        {
            cache_emails = skypeRef.decoder.DecodeString();
            cache[35] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  See Sktstring for more information.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountHomepage</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountHomepage(SktAccount sender, SktEvents.OnAccountHomepageArgs e)</b></tt>
     */
    public String P_HOMEPAGE
    {
        get { if (!cache[36]) FetchHomepageFromRuntime(); return cache_homepage; }
    }
    
    internal void FetchHomepageFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_HOMEPAGE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 17, this.OID);
        if (skypeRef.transport.PropResponseWasOk(17))
        {
            cache_homepage = skypeRef.decoder.DecodeString();
            cache[36] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  arbitrary introductory text
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountAbout</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountAbout(SktAccount sender, SktEvents.OnAccountAboutArgs e)</b></tt>
     */
    public String P_ABOUT
    {
        get { if (!cache[37]) FetchAboutFromRuntime(); return cache_about; }
    }
    
    internal void FetchAboutFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_ABOUT from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 18, this.OID);
        if (skypeRef.transport.PropResponseWasOk(18))
        {
            cache_about = skypeRef.decoder.DecodeString();
            cache[37] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of last profile change
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountProfileTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountProfileTimestamp(SktAccount sender, SktEvents.OnAccountProfileTimestampArgs e)</b></tt>
     */
    public DateTime P_PROFILE_TIMESTAMP
    {
        get { if (!cache[38]) FetchProfileTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_profile_timestamp); }
    }
    
    internal void FetchProfileTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_PROFILE_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 19, this.OID);
        if (skypeRef.transport.PropResponseWasOk(19))
        {
            cache_profile_timestamp = skypeRef.decoder.DecodeUint();
            cache[38] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Personal mood text (visible to authorised users only). Max length 300 bytes.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountMoodText</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountMoodText(SktAccount sender, SktEvents.OnAccountMoodTextArgs e)</b></tt>
     */
    public String P_MOOD_TEXT
    {
        get { if (!cache[39]) FetchMoodTextFromRuntime(); return cache_mood_text; }
    }
    
    internal void FetchMoodTextFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MOOD_TEXT from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 26, this.OID);
        if (skypeRef.transport.PropResponseWasOk(26))
        {
            cache_mood_text = skypeRef.decoder.DecodeString();
            cache[39] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  24*3600+diff_to_UTC_in_seconds. nb! changes with DST
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountTimezone</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountTimezone(SktAccount sender, SktEvents.OnAccountTimezoneArgs e)</b></tt>
     */
    public uint P_TIMEZONE
    {
        get { if (!cache[40]) FetchTimezoneFromRuntime(); return cache_timezone; }
    }
    
    internal void FetchTimezoneFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_TIMEZONE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 27, this.OID);
        if (skypeRef.transport.PropResponseWasOk(27))
        {
            cache_timezone = skypeRef.decoder.DecodeUint();
            cache[40] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Count of this user's authorized contacts.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountNrofAuthedBuddies</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountNrofAuthedBuddies(SktAccount sender, SktEvents.OnAccountNrofAuthedBuddiesArgs e)</b></tt>
     */
    public uint P_NROF_AUTHED_BUDDIES
    {
        get { if (!cache[41]) FetchNrofAuthedBuddiesFromRuntime(); return cache_nrof_authed_buddies; }
    }
    
    internal void FetchNrofAuthedBuddiesFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_NROF_AUTHED_BUDDIES from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 28, this.OID);
        if (skypeRef.transport.PropResponseWasOk(28))
        {
            cache_nrof_authed_buddies = skypeRef.decoder.DecodeUint();
            cache[41] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  SktContact.AVAILABILITY
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountAvailability</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountAvailability(SktAccount sender, SktEvents.OnAccountAvailabilityArgs e)</b></tt>
     */
    public SktContact.AVAILABILITY P_AVAILABILITY
    {
        get { if (!cache[42]) FetchAvailabilityFromRuntime(); return cache_availability; }
    }
    
    internal void FetchAvailabilityFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVAILABILITY from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 34, this.OID);
        if (skypeRef.transport.PropResponseWasOk(34))
        {
            cache_availability = (SktContact.AVAILABILITY)skypeRef.decoder.DecodeUint();
            cache[42] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  Account avatar picture can be set with SktAccount.SetBinProperty method. The contact avatar picture is
      limited to max 96x96 pixels and 32000 bytes. If the submitted avatar picture exceeds either of these
      size limits, it is the responsibility of your client to scale the image down to appropriate size. The avatar pictures have to be in JPG format. A SkypeKit client can enable the user to set the Account
      avatar in other picture formats, in which case the picture should be converted to JPG before submitting
      it. In any case, the avatar picture should be pre-validated with the SktSkype.ValidateAvatar method.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountAvatarImage</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountAvatarImage(SktAccount sender, SktEvents.OnAccountAvatarImageArgs e)</b></tt>
     */
    public byte[] P_AVATAR_IMAGE
    {
        get { if (!cache[43]) FetchAvatarImageFromRuntime(); return cache_avatar_image; }
    }
    
    internal void FetchAvatarImageFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVATAR_IMAGE from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 37, this.OID);
        if (skypeRef.transport.PropResponseWasOk(37))
        {
            cache_avatar_image = skypeRef.decoder.DecodeBinary();
            cache[43] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of when current avatar was set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountAvatarTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountAvatarTimestamp(SktAccount sender, SktEvents.OnAccountAvatarTimestampArgs e)</b></tt>
     */
    public DateTime P_AVATAR_TIMESTAMP
    {
        get { if (!cache[44]) FetchAvatarTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_avatar_timestamp); }
    }
    
    internal void FetchAvatarTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_AVATAR_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 182, this.OID);
        if (skypeRef.transport.PropResponseWasOk(182))
        {
            cache_avatar_timestamp = skypeRef.decoder.DecodeUint();
            cache[44] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  UNIX timestamp of when current mood was set
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountMoodTimestamp</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountMoodTimestamp(SktAccount sender, SktEvents.OnAccountMoodTimestampArgs e)</b></tt>
     */
    public DateTime P_MOOD_TIMESTAMP
    {
        get { if (!cache[45]) FetchMoodTimestampFromRuntime(); return skypeRef.UnixTimestampToDateTime(cache_mood_timestamp); }
    }
    
    internal void FetchMoodTimestampFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_MOOD_TIMESTAMP from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 183, this.OID);
        if (skypeRef.transport.PropResponseWasOk(183))
        {
            cache_mood_timestamp = skypeRef.decoder.DecodeUint();
            cache[45] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    /**  XML version of CONTACT_MOOD_TEXT. Max length 1000 bytes.
     @n Assign your own event handler method to the <tt><b>skype.events.OnAccountRichMoodText</b></tt> to catch updates for this property.
     @n The handler method signature is <tt><b>void OnAccountRichMoodText(SktAccount sender, SktEvents.OnAccountRichMoodTextArgs e)</b></tt>
     */
    public String P_RICH_MOOD_TEXT
    {
        get { if (!cache[46]) FetchRichMoodTextFromRuntime(); return cache_rich_mood_text; }
    }
    
    internal void FetchRichMoodTextFromRuntime()
    {
        if (skypeRef.logging) skypeRef.Log("Fetching P_RICH_MOOD_TEXT from runtime");
        skypeRef.transport.SubmitPropertyRequest(5, 205, this.OID);
        if (skypeRef.transport.PropResponseWasOk(205))
        {
            cache_rich_mood_text = skypeRef.decoder.DecodeXML();
            cache[46] = true;
        }
        skypeRef.transport.ResumeSocketReaderFromPropRequest();
    }
    
    
    /* SktAccount class PropKeys */
    
    public enum PropKeys 
    {
        P_STATUS                     =   70,
        P_PWDCHANGESTATUS            =   71,
        P_LOGOUTREASON               =   73,
        P_COMMITSTATUS               =   78,
        P_SUGGESTED_SKYPENAME        =   72,
        P_SKYPEOUT_BALANCE_CURRENCY  =   74,
        P_SKYPEOUT_BALANCE           =   75,
        P_SKYPEOUT_PRECISION         =  804,
        P_SKYPEIN_NUMBERS            =   76,
        P_CBLSYNCSTATUS              =   79,
        P_OFFLINE_CALLFORWARD        =   77,
        P_CHAT_POLICY                =  160,
        P_SKYPE_CALL_POLICY          =  161,
        P_PSTN_CALL_POLICY           =  162,
        P_AVATAR_POLICY              =  163,
        P_BUDDYCOUNT_POLICY          =  164,
        P_TIMEZONE_POLICY            =  165,
        P_WEBPRESENCE_POLICY         =  166,
        P_PHONENUMBERS_POLICY        =  168,
        P_VOICEMAIL_POLICY           =  169,
        P_PARTNER_OPTEDOUT           =  773,
        P_SERVICE_PROVIDER_INFO      =  800,
        P_REGISTRATION_TIMESTAMP     =  801,
        P_NR_OF_OTHER_INSTANCES      =  802,
        P_SKYPENAME                  =    4,
        P_FULLNAME                   =    5,
        P_BIRTHDAY                   =    7,
        P_GENDER                     =    8,
        P_LANGUAGES                  =    9,
        P_COUNTRY                    =   10,
        P_PROVINCE                   =   11,
        P_CITY                       =   12,
        P_PHONE_HOME                 =   13,
        P_PHONE_OFFICE               =   14,
        P_PHONE_MOBILE               =   15,
        P_EMAILS                     =   16,
        P_HOMEPAGE                   =   17,
        P_ABOUT                      =   18,
        P_PROFILE_TIMESTAMP          =   19,
        P_MOOD_TEXT                  =   26,
        P_TIMEZONE                   =   27,
        P_NROF_AUTHED_BUDDIES        =   28,
        P_AVAILABILITY               =   34,
        P_AVATAR_IMAGE               =   37,
        P_AVATAR_TIMESTAMP           =  182,
        P_MOOD_TIMESTAMP             =  183,
        P_RICH_MOOD_TEXT             =  205 
    }
    
    /* SktAccount class enums */
    
    /**  STATUS
     */
    public enum STATUS
    {
        LOGGED_OUT                 =    1, /*!<   */
        LOGGED_OUT_AND_PWD_SAVED   =    2, /*!< the account is logged out, but password is not needed for re-login */
        CONNECTING_TO_P2P          =    3, /*!< connecting to P2P network */
        CONNECTING_TO_SERVER       =    4, /*!< connecting to login server */
        LOGGING_IN                 =    5, /*!< waiting for response from server */
        INITIALIZING               =    6, /*!< response OK. initialising account-specific lib structures */
        LOGGED_IN                  =    7, /*!< alright, we're good to go! */
        LOGGING_OUT                =    8  /*!< Logout() has been called but not processed yet */
    }
    
    /**  Recognized values for the P_CBLSYNCSTATUS property. CBL stands for Central Buddy List. In principle,
      this property and its states can be ignored by most UI developers. However, it can help to optimize UI
      buildup and behaviour, particularly in case of limited resources (such as mobile devices). CBL is used to backup your contact list, contact groups, and profile information, and also used to synchronize
      this information with other Skype instances of your account (i.e. on another device). CBL sync can occur
      both during login and during normal operation. Note that CBL synchronization does not take place immediately
      after an Account property is changed. A delay between the first property change and CBL sync initiation
      enables the client to accumulate changes and do the synchronization in bulk. Clients with limited resources might want to wait for CBL_IN_SYNC status before generating their UI's
      contact list representation. Otherwise it might be forced to redraw the contact list multiple times,
      as new updates get retrieved from the server-side. Similarly, applications that modify an account's mood
      message might want to know when the P_MOOD_TEXT or P_RICH_MOOD_TEXT property is synchronized to the server.
      Note that this sync is only for CBL and other logged in instances of the same account - other contacts
      will receive the mood message update directly.
     */
    public enum CBLSYNCSTATUS
    {
        CBL_INITIALIZING           =    0, /*!< status is not clear (yet) */
        CBL_INITIAL_SYNC_PENDING   =    1, /*!< first sync with empty profile */
        CBL_SYNC_PENDING           =    2, /*!< Account properties are considered to be out of sync with CBL - attempt at synchronization is imminent. You might wish to wait with updating UI components that display the data that is about to change anyway. */
        CBL_SYNC_IN_PROGRESS       =    3, /*!< CBL synchronization is currently taking place. */
        CBL_IN_SYNC                =    4, /*!< Account properties are up-to-date. */
        CBL_SYNC_FAILED            =    5, /*!< CBL sync has. Another attempt will be made after several minutes. If a second attempt also fails, subsequent attempts at synchronization will be made at ever increasing intervals. */
        CBL_REMOTE_SYNC_PENDING    =    6  /*!< we have received a hint that there is a remote data change in CBL */
    }
    
    /**  Recognized values for the SktAccount.P_LOGOUTREASON. Note that this property should only be examined
      when SktAccount.P_STATUS is LOGGED_OUT or LOGGED_OUT_AND_PWD_SAVED. That is, you should not monitor changes
      to this property in SktAccount.OnChange callback, other than after already having checked that P_STATUS
      property has appropriate value. The reason for this is that the LOGOUTREASON does not get reset before
      the next login attempt. For example: if a user tried to log in with a wrong password, the LOGOUTREASON
      gets set to INCORRECT_PASSWORD. Now, if the user tries to log in again, and yet again submits an incorrect
      password, the value of the LOGOUTREASON does not change anymore, because it already is set to INCORRECT_PASSWORD.
      Consequently, SktAccount.OnChange will not fire in this case.
     */
    public enum LOGOUTREASON
    {
        LOGOUT_CALLED                =    1, /*!< manual logout (or unknown reason from previous session) */
        HTTPS_PROXY_AUTH_FAILED      =    2, /*!< sync errors at login/registration */
        SOCKS_PROXY_AUTH_FAILED      =    3, /*!< sync errors at login/registration */
        P2P_CONNECT_FAILED           =    4, /*!< sync errors at login/registration */
        SERVER_CONNECT_FAILED        =    5, /*!< sync errors at login/registration */
        SERVER_OVERLOADED            =    6, /*!< sync errors at login/registration */
        DB_IN_USE                    =    7, /*!< sync errors at login/registration */
        INVALID_SKYPENAME            =    8, /*!< sync errors at registration */
        INVALID_EMAIL                =    9, /*!< sync errors at registration */
        UNACCEPTABLE_PASSWORD        =   10, /*!< sync errors at registration */
        SKYPENAME_TAKEN              =   11, /*!< sync errors at registration */
        REJECTED_AS_UNDERAGE         =   12, /*!< sync errors at registration */
        NO_SUCH_IDENTITY             =   13, /*!< sync errors at login */
        INCORRECT_PASSWORD           =   14, /*!< sync errors at login */
        TOO_MANY_LOGIN_ATTEMPTS      =   15, /*!< sync errors at login */
        PASSWORD_HAS_CHANGED         =   16, /*!< async errors (can happen anytime while logged in) */
        PERIODIC_UIC_UPDATE_FAILED   =   17, /*!< async errors (can happen anytime while logged in) */
        DB_DISK_FULL                 =   18, /*!< async errors (can happen anytime while logged in) */
        DB_IO_ERROR                  =   19, /*!< async errors (can happen anytime while logged in) */
        DB_CORRUPT                   =   20, /*!< async errors (can happen anytime while logged in) */
        DB_FAILURE                   =   21, /*!< deprecated (superceded by more detailed DB_* errors) */
        INVALID_APP_ID               =   22, /*!< platform sdk */
        APP_ID_FAILURE               =   23, /*!< platform sdk */
        UNSUPPORTED_VERSION          =   24, /*!< forced upgrade/discontinuation */
        ATO_BLOCKED                  =   25, /*!< ATO (Account TakeOver) detected, account blocked */
        REMOTE_LOGOUT                =   26  /*!< logout from another instance */
    }
    
    /**  Recognized values for the P_PWDCHANGESTATUS property that provides information on whether a password
      change succeeded or failed, giving detailed failure reason. After successful return from the Change Password
      method, clients should monitor the P_PWDCHANGESTATUS property changes. @li PWD_CHANGING - consider displaying
      an "in progress" indicator and continue polling @li PWD_OK - consider displaying an updated indicator
      and stop polling @li PWD_OK_BUT_CHANGE_SUGGESTED - consider displaying an updated indicator, along with
      a recommendation to change again to a stronger password.
     */
    public enum PWDCHANGESTATUS
    {
        PWD_OK                        =    0, /*!< Password change succeeded.   */
        PWD_CHANGING                  =    1, /*!< Password change is in progress.   */
        PWD_INVALID_OLD_PASSWORD      =    2, /*!< Old password was incorrect.   */
        PWD_SERVER_CONNECT_FAILED     =    3, /*!< Failed to verify password because of no connection to server.   */
        PWD_OK_BUT_CHANGE_SUGGESTED   =    4, /*!< Password was set but server didn't like it much.   */
        PWD_MUST_DIFFER_FROM_OLD      =    5, /*!< New password was exactly the same as old one.   */
        PWD_INVALID_NEW_PWD           =    6, /*!< The new password was unacceptable. (too short, too simple, etc.)   */
        PWD_MUST_LOG_IN_TO_CHANGE     =    7  /*!< Account was currently not logged in.   */
    }
    
    /**  The list of possible values of Account class COMMITSTATUS property. Note that this property and its values
      have nothing to do with (automatic) CBL synchronization. Rather, the COMMITSTATUS reflects commit status
      to account's server side properties initiated with calls to Account class SetServersideIntProperty and
      Account class SetServersideStrProperty methods. After those methods, your client UI may want to wait
      until the COMMITSTATUS becomes COMMITTING_TO_SERVER followed by COMMITTED and inform the user if the
      value becomes COMMIT_FAILED. SetServerside<type>Property methods are used for writing privacy policy
      related and call forwarding related Account properties to the server. Unlike CBL synchronization, those
      updates are executed immediately.
     */
    public enum COMMITSTATUS
    {
        COMMITTED              =    1, /*!< No pending updates to the server.   */
        COMMITTING_TO_SERVER   =    2, /*!< Update to the server in progress.   */
        COMMIT_FAILED          =    3  /*!< Server update has failed.   */
    }
    
    /**  Recognized values for the P_CHAT_POLICY property that controls whether non-authorized users can initiate
      text chat with the currently logged in account. Note that since this set of values is associated with
      a server-side property, you must set that property using SktAccount.SetServersideIntProperty
     */
    public enum CHATPOLICY
    {
        EVERYONE_CAN_ADD                =    0, /*!< Unauthorized contacts can initiate text chat.   */
        BUDDIES_OR_AUTHORIZED_CAN_ADD   =    2  /*!< Only authorized contacts can initiate chat (default policy).   */
    }
    
    /**  Recognized values for the P_SKYPECALLPOLICY property that controls acceptance of incoming Skype calls.
      Note that since this set of values is associated with a server-side property, you must set that property
      using SktAccount.SetServersideIntPropertyserver-side.
     */
    public enum SKYPECALLPOLICY
    {
        EVERYONE_CAN_CALL                =    0, /*!< Skype calls accepted from unauthorized contacts. */
        BUDDIES_OR_AUTHORIZED_CAN_CALL   =    2  /*!< Skype calls not accepted from unauthorized contacts. */
    }
    
    /**  Recognized values for the P_PSTNCALLPOLICY property that controls whether (and from whom) this account
      accepts incoming PSTN calls. Note that since this set of values is associated with a server-side property,
      you must set that property using SktAccount.SetServersideIntProperty
     */
    public enum PSTNCALLPOLICY
    {
        ALL_NUMBERS_CAN_CALL         =    0, /*!< All incoming PSTN calls are accepted. */
        DISCLOSED_NUMBERS_CAN_CALL   =    1, /*!< Only PSTN calls that report caller ID are accepted. */
        BUDDY_NUMBERS_CAN_CALL       =    2  /*!< Only calls from PSTN numbers found in local contact list are accepted. */
    }
    
    /**  Recognized values for the P_AVATAR_POLICY property that controls whether remote contacts can view local
      account's avatar image. Note that since this set of values is associated with a server-side property,
      you must set that property using SktAccount.SetServersideIntPropertyserver-side. Note that setting account's AVATAR_POLICY to BUDDIES_OR_AUTHORIZED_CAN_SEE does not guarantee that remote
      users will be able to immediately retrieve the avatar picture via corresponding Contact object. Avatar
      changes propagate between clients only when direct sessions between clients are established. Direct sessions
      are established during live sessions or whilst online contacts are engaged in chat.
     */
    public enum AVATARPOLICY
    {
        BUDDIES_OR_AUTHORIZED_CAN_SEE   =    0, /*!< Only authorized remote users can see this user's avatar image */
        EVERYONE_CAN_SEE                =    2  /*!< Everyone can see this user's avatar image, once the contact/account avatar property has been synchronized during a direct session. The avatar image may also become viewable on some Skype Web-based services. */
    }
    
    /**  Recognized values for the P_BUDDYCOUNT_POLICY property that controls whether the number of this user's
      authorized contacts is visible to other users, either through SktAccount.GetPropNrofAuthedBuddies or
      SktContact.GetPropNrofAuthedBuddies when those instances reference this user. Note that since this set
      of values is associated with a server-side property, you must set that property using SktAccount.SetServersideIntProperty,
      like this: Sktaccount->SetServersideIntProperty(Account.P_BUDDYCOUNT_POLICY, SktAccount.DISCLOSE_TO_AUTHORIZED);
      Sktaccount->SetServersideIntProperty(Account.P_BUDDYCOUNT_POLICY, SktAccount.DISCLOSE_TO_NOONE );
     */
    public enum BUDDYCOUNTPOLICY
    {
        DISCLOSE_TO_AUTHORIZED   =    0, /*!< Authorized remote users can retrieve the number of this user's authorized contacts (Contact::P_NROF_AUTHED_BUDDIES) */
        DISCLOSE_TO_NOONE        =    1  /*!< No remote user - regardless their authorization status - can retrieve the number of this user's authorized contacts. Account::GetPropNrofAuthedBuddies and Contact::GetPropNrofAuthedBuddies will always return 0 */
    }
    
    /**  Recognized values for the P_TIMEZONEPOLICY property that sets the rules for timezone offset so remote
      clients can determine your local time. Note that since this set of values is associated with a server-side
      property, you must set that property using SktAccount.SetServersideIntPropertyserver-side.
     */
    public enum TIMEZONEPOLICY
    {
        TZ_AUTOMATIC     =    0, /*!< Account's timezone setting is determined automatically.   */
        TZ_MANUAL        =    1, /*!< Account's timezone setting is set manually.   */
        TZ_UNDISCLOSED   =    2  /*!< Remote users will have no idea what your local time is.   */
    }
    
    /**  Recognized values for the P_WEBPRESENCEPOLICY property that controls whether your online status (presence)
      can be seen using the "Skype buttons" ( http://www.skype.com/share/buttons/ ) embedded in web pages.
      Note that since this set of values is associated with a server-side property, you must set that property
      using SktAccount.SetServersideIntPropertyserver-side.
     */
    public enum WEBPRESENCEPOLICY
    {
        WEBPRESENCE_DISABLED   =    0, /*!< Disable displaying online status on web for this account. */
        WEBPRESENCE_ENABLED    =    1  /*!< Enable displaying online status on web for this account. */
    }
    
    /**  Recognized values for the P_PHONENUMBERSPOLICY property that controls whether unauthorized remote users
      can see associated phone numbers in their UI (for reference, see the different phone number tabs in Windows
      desktop Client contact view). Note that since this set of values is associated with a server-side property,
      you must set that property using SktAccount.SetServersideIntProperty
     */
    public enum PHONENUMBERSPOLICY
    {
        PHONENUMBERS_VISIBLE_FOR_BUDDIES    =    0, /*!< Only authorized contacts can see the phone numbers. */
        PHONENUMBERS_VISIBLE_FOR_EVERYONE   =    1  /*!< Everyone can see the phone numbers. */
    }
    
    /**  Recognized values for the P_VOICEMAILPOLICY property that controls acceptance of incoming voicemail messages.
      Note that since this set of values is associated with a server-side property, you must set that property
      using SktAccount.SetServersideIntPropertyserver-side.
     */
    public enum VOICEMAILPOLICY
    {
        VOICEMAIL_ENABLED    =    0, /*!< Incoming voicemails enabled. */
        VOICEMAIL_DISABLED   =    1  /*!< Incoming voicemails disabled. */
    }
    
    /**  Account capabability statuses are possible values of Contact class CAPABILITY enumerator, when that enumerator
      is used in context of account. Compared to Contact class CAPABILITYSTATUS enums, Account class CAPABILITYSTATUS
      has additional items for subscription expiration warnings.
     */
    public enum CAPABILITYSTATUS
    {
        NO_CAPABILITY           =    0, /*!< Capability is not supported by the currently logged in SkypeKit client. */
        CAPABILITY_EXISTS       =    1, /*!< Capability is supported by the currently logged in SkypeKit client.   */
        FIRST_EXPIRY_WARNING    =    2, /*!< Support for this capability ends this month (within 30 days)   */
        SECOND_EXPIRY_WARNING   =    3, /*!< Support for this capability ends this week (within 7 days)    */
        FINAL_EXPIRY_WARNING    =    4  /*!< Support for this capability ends today   */
    }
    
    /* SktAccount class methods */
    
    /** 
        @param [out] status Current value of this account's P_STATUS property
        @param [out] progress This argument returns 0. 
     */
    public void GetStatusWithProgress (out SktAccount.STATUS status, out uint progress)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.GetStatusWithProgress");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 1, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktAccount.GetStatusWithProgress");
        status = (SktAccount.STATUS)args[0];
        progress = (uint)args[1];
    }
    
    /**  Login an auto-login enabled account (P_STATUS is LOGGED_OUT_AND_PWD_SAVED) and optionally set the availability,
      for example login in as SktContact.DO_NOT_DISTURB. To find out whether there is an auto-login enabled
      account available, you can use SktSkype.GetDefaultAccountName to retrieve the skypename of that account.
      You can then get an Account instance for login by invoking SktSkype.GetAccount. If no accounts with stored
      login credentials are available (GetDefaultAccountName returns an empty string), then you will have to prompt the user for account name and password and then use LoginWithPassword. Account
      name field in the UI can be pre-populated with strings retrieved with SktSkype.GetExistingAccounts
        @param [in] setAvailabilityTo - force this account's initial online status to the specified SktContact.AVAILABILITY value. Default value is SktContact.AVAILABILITY.UNKNOWN
     */
    public void Login (SktContact.AVAILABILITY setAvailabilityTo)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.Login");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 5, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)setAvailabilityTo);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.Login");
    }
    
    /**  Login in an account by specifying its password. To retrieve an account instance for login, invoke SktSkype.GetAccount.
     
        @param [in] password - Password string (plaintext) for this account, which should be pre-validated Skt(Skype.ValidatePassword)
     
        @param [in] savePwd - @li true: Saves the password, ensuring that auto-login is enabled. @li false (default): Does not save
      the password, and so the user might not be able to effect auto-login until they explicitly invoke SktAccount.SetPasswordSaved(true).
      Default value is false
        @param [in] saveDataLocally - For internal use only. Default value is true
     */
    public void LoginWithPassword (
        String  password,
        Boolean savePwd,
        Boolean saveDataLocally)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.LoginWithPassword");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 6, OID);
        skypeRef.encoder.AddStringParam(1, password);
        skypeRef.encoder.AddBoolParam(2, savePwd);
        skypeRef.encoder.AddBoolParam(3, saveDataLocally);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.LoginWithPassword");
    }
    
    /**  This command can be used to create a new Skype account, based on the Account object. When successful,
      this command will also log in with the newly created account. If the new account registration was not
      successful, Account status property will change to LOGGED_OUT. A common reason for registration failures
      is that the an account with that name already exists. In that case, Account LOGOUT_REASON will be set
      to SKYPENAME_TAKEN. Also, Account SUGGESTED_SKYPENAME property will be set to a list of similar but still
      available skypenames that could be used instead. The property will contain up to 5 semicolon-separated
      alternative skypenames. In if no suggested skypenames were available, then this property will contain
      an empty string. NB! You should pre-validate your P_SKYPENAME value and any email string Skt(Skype.ValidateProfileString)
      prior to invoking this method.
        @param [in] password - Password string (plaintext) for this account, which should be pre-validated Skt(Skype.ValidatePassword)
     
        @param [in] savePwd - @li true: Saves the password and enables auto-login. @li false (default): Does not save the password,
      and the user needs to be prompted for password on the next login attempt. Default value is false
        @param [in] saveDataLocally - For internal use only. Default value is true
        @param [in] email - An email address for retrieving lost passwords and receiving news and information from Skype. Default value is ""
        @param [in] allowSpam - enable/disable news and information from Skype being sent to account's e-mail. Default value is false
     */
    public void Register (
        String  password,
        Boolean savePwd,
        Boolean saveDataLocally,
        String  email,
        Boolean allowSpam)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.Register");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 7, OID);
        skypeRef.encoder.AddStringParam(1, password);
        skypeRef.encoder.AddBoolParam(2, savePwd);
        skypeRef.encoder.AddBoolParam(3, saveDataLocally);
        skypeRef.encoder.AddStringParam(4, email);
        skypeRef.encoder.AddBoolParam(5, allowSpam);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.Register");
    }
    
    /**  Logs out current account. Note that calling this on client application exit is optional.
        @param [in] clearSavedPwd - @li true: Clears any saved password use with auto-login and so disables auto-login until you explicitly
      invoke SktAccount.SetPasswordSaved(true). @li false (default): Does not clear any saved password and
      so does not affect existing auto-login behavior. Default value is false
     */
    public void Logout (Boolean clearSavedPwd)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.Logout");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 8, OID);
        skypeRef.encoder.AddBoolParam(1, clearSavedPwd);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.Logout");
    }
    
    /**  Changes this account's password. Returns false if the change failed. NB! You should pre-validate your
      password strings Skt(Skype.ValidatePassword) and ensure that they are different prior to invoking this
      method.
        @param [in] oldPassword - "Current password string (plaintext) for this account
        @param [in] newPassword - New password string (plaintext) for this account
        @param [in] savePwd - @li true: Saves the new password and enables auto-login. @li false (default): Clears any existing saved
      password and so the user cannot effect auto-login until they explicitly invoke SktAccount.SetPasswordSaved(true)
      Default value is false
     */
    public void ChangePassword (
        String  oldPassword,
        String  newPassword,
        Boolean savePwd)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.ChangePassword");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 11, OID);
        skypeRef.encoder.AddStringParam(1, oldPassword);
        skypeRef.encoder.AddStringParam(2, newPassword);
        skypeRef.encoder.AddBoolParam(3, savePwd);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.ChangePassword");
    }
    
    /**  save or clear credentials for auto-login whilst already logged in
        @param [in] savePwd
     */
    public void SetPasswordSaved (Boolean savePwd)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetPasswordSaved");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 25, OID);
        skypeRef.encoder.AddBoolParam(1, savePwd);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetPasswordSaved");
    }
    
    /**  Setter for integer (and enum) server-side properties. For a list of writeable server-side properties,
      see the detailed description of the Account class.
        @param [in] propKey
        @param [in] value
     */
    public void SetServersideIntProperty (int propKey, uint value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetServersideIntProperty");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 12, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddUintParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetServersideIntProperty");
    }
    
    /**  Setter for String server-side properties. For a list of writeable server-side properties, see the detailed
      description of the Account class.
        @param [in] propKey
        @param [in] value
     */
    public void SetServersideStrProperty (int propKey, String value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetServersideStrProperty");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 13, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddStringParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetServersideStrProperty");
    }
    
    /**  Cancels an attempt to commit a server-side P_XXX_POLICY or the P_OFFLINE_CALLFORWARD server-side property.
      Invoking this cancellation only makes sense whilst the P_COMMITTSTATUS is in COMMITTING_TO_SERVER state.
     
     */
    public void CancelServerCommit ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.CancelServerCommit");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 15, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.CancelServerCommit");
    }
    
    /**  Setter for integer properties. For a list of writeable account profile properties, see the detailed description
      of the Account class.
        @param [in] propKey
        @param [in] value
     */
    public void SetIntProperty (int propKey, uint value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetIntProperty");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 16, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddUintParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetIntProperty");
    }
    
    /**  Setter for String properties. For a list of writeable account profile properties, see the detailed description
      of the Account class. NB! You should pre-validate your about and mood message strings Skt(Skype.ValidateProfileString)
      prior to invoking this method.
        @param [in] propKey
        @param [in] value
     */
    public void SetStrProperty (int propKey, String value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetStrProperty");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 17, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddStringParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetStrProperty");
    }
    
    /**  Setter for BLOB properties, such as its avatar image. For a list of writeable account profile properties,
      see the detailed description of the Account class. NB! You should pre-validate your avatar image Skt(Skype.ValidateAvatar)
      prior to invoking this method.
        @param [in] propKey
        @param [in] value
     */
    public void SetBinProperty (int propKey, byte[] value)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetBinProperty");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 18, OID);
        skypeRef.encoder.AddPropkeyParam(1, propKey);
        skypeRef.encoder.AddBinaryParam(2, value);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetBinProperty");
    }
    
    /**  Sets online status of the currently logged in account to one of the values from Contact class AVAILABILITY
      enumerator.
        @param [in] availability - only subset of all contact availabilities allowed
     */
    public void SetAvailability (SktContact.AVAILABILITY availability)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetAvailability");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 19, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)availability);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetAvailability");
    }
    
    /**  Transitions the availability of this account's associated user, who is assumed to be logged in.
        @param [in] standby - @li true: Saves the user's current availability, then sets it to SktCONTACT.AVAILABILITY.OFFLINE @li
      false: Reconnects the user and restores their previous availability
     */
    public void SetStandby (Boolean standby)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.SetStandby");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 10, OID);
        skypeRef.encoder.AddBoolParam(1, standby);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.SetStandby");
    }
    
    /**  Returns state of a given account capability. Takes Contact class CAPABILITY property as input argument
      and returns its state and expiration timestamp where appropriate. For example (C++ wrapper, with other
      wrappers the syntax may vary but the idea is the same) SktMyAccount.GetCapabilityStatus(Contact.CAPABILITY_SKYPEOUT,
      Cap, T); will return SktAccount.CAPABILITY_EXISTS if local account has SkypeOut enabled.
        @param [out] status
        @param [out] expiryTimestamp
        @param [in] capability
     */
    public void GetCapabilityStatus (
        out SktAccount.CAPABILITYSTATUS status,
        out DateTime               expiryTimestamp,
        SktContact.CAPABILITY      capability)
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.GetCapabilityStatus");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 21, OID);
        skypeRef.encoder.AddEnumParam(1, (uint)capability);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1}, {2, 2} };
        object[] args = new object[2];
        args[0] = 0;
        args[1] = 0;
        skypeRef.decoder.DecodeMethodResponseArguments(2, ref args, new uint[2]{0,0}, ref tagMap, "SktAccount.GetCapabilityStatus");
        status = (SktAccount.CAPABILITYSTATUS)args[0];
        expiryTimestamp = (DateTime)args[1];
    }
    
    /**  Response is empty when called with an inactive or invalid account
        @returns skypenameHash
     */
    public String GetSkypenameHash ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.GetSkypenameHash");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 22, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktAccount.GetSkypenameHash");
        return (String)args[0];
    }
    
    /**  returns verified-by-Skype e-mail for this account if exists and verifiable
        @returns email
     */
    public String GetVerifiedEmail ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.GetVerifiedEmail");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 2, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktAccount.GetVerifiedEmail");
        return (String)args[0];
    }
    
    /**  returns verified-by-Skype company for this account if exists and verifiable
        @returns company
     */
    public String GetVerifiedCompany ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.GetVerifiedCompany");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 3, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        Dictionary<uint, uint> tagMap = new Dictionary<uint, uint> { {1, 1} };
        object[] args = new object[1];
        args[0] = "";
        skypeRef.decoder.DecodeMethodResponseArguments(1, ref args, new uint[1]{0}, ref tagMap, "SktAccount.GetVerifiedCompany");
        return (String)args[0];
    }
    
    /**  Deletes all account data stored locally. Does not remove any account data from the server!
     */
    public void Delete ()
    {
        if (skypeRef.logging) skypeRef.Log("Executing Account.Delete");
        uint RequestId = skypeRef.encoder.AddMethodHeader(ClassId, 24, OID);
        skypeRef.transport.SubmitMethodRequest (RequestId);
        skypeRef.decoder.DecodeMethodResponseWithNoArguments("SktAccount.Delete");
    }
    
    internal override void DispatchEvent (uint eventId)
    {
        skypeRef.Error("Event dispatcher fired for Account - the wrapper has no events for this class.");
    }
}

/*! \class SktEvents
  \brief
  This class manages events and property updates for all the other classes. It should not be 
  instantiated directly. The sole instance of this class - events field of your SktSkype object, 
  can be used to assign custom callbacks to events and property updates. Description of class 
  events and corresponding argument structs can be found under documentation of each individual 
  class - that has any events - under the "Detailed Description" section of that class.
  
  <b>NB!</b> In order to prevent the entire content of this class from hopelessly cluttering up 
  the main class index in the reference manual, documentation of all these classes has been excluded.  
 */

public class SktEvents : SktEventsBase
{
    public SktEvents (Form form, SktSkype skype) : base(form, skype) {}
    
    
    public class OnParticipantConvoIdArgs : EventArgs
    {
        public SktParticipant sender;
        public SktConversation value;
        public OnParticipantConvoIdArgs(SktParticipant sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantConvoIdHandler OnParticipantConvoId;    
    public delegate void OnParticipantConvoIdHandler (SktParticipant sender, OnParticipantConvoIdArgs e);
    
    internal void OnParticipantConvoIdInNewThread(object o)
    {
        OnParticipantConvoIdArgs e = (OnParticipantConvoIdArgs)o;
        OnParticipantConvoId(e.sender, e);
    }
    
    internal void FireOnParticipantConvoId(SktParticipant sender, SktConversation value)
    {
        if (OnParticipantConvoId == null) return; // Event not assigned    
        OnParticipantConvoIdArgs args = new OnParticipantConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantIdentityArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantIdentityArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantIdentityHandler OnParticipantIdentity;    
    public delegate void OnParticipantIdentityHandler (SktParticipant sender, OnParticipantIdentityArgs e);
    
    internal void OnParticipantIdentityInNewThread(object o)
    {
        OnParticipantIdentityArgs e = (OnParticipantIdentityArgs)o;
        OnParticipantIdentity(e.sender, e);
    }
    
    internal void FireOnParticipantIdentity(SktParticipant sender, String value)
    {
        if (OnParticipantIdentity == null) return; // Event not assigned    
        OnParticipantIdentityArgs args = new OnParticipantIdentityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantIdentityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantIdentity, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantRankArgs : EventArgs
    {
        public SktParticipant sender;
        public SktParticipant.RANK value;
        public OnParticipantRankArgs(SktParticipant sender, SktParticipant.RANK newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantRankHandler OnParticipantRank;    
    public delegate void OnParticipantRankHandler (SktParticipant sender, OnParticipantRankArgs e);
    
    internal void OnParticipantRankInNewThread(object o)
    {
        OnParticipantRankArgs e = (OnParticipantRankArgs)o;
        OnParticipantRank(e.sender, e);
    }
    
    internal void FireOnParticipantRank(SktParticipant sender, SktParticipant.RANK value)
    {
        if (OnParticipantRank == null) return; // Event not assigned    
        OnParticipantRankArgs args = new OnParticipantRankArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantRankInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantRank, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantRequestedRankArgs : EventArgs
    {
        public SktParticipant sender;
        public SktParticipant.RANK value;
        public OnParticipantRequestedRankArgs(SktParticipant sender, SktParticipant.RANK newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantRequestedRankHandler OnParticipantRequestedRank;    
    public delegate void OnParticipantRequestedRankHandler (SktParticipant sender, OnParticipantRequestedRankArgs e);
    
    internal void OnParticipantRequestedRankInNewThread(object o)
    {
        OnParticipantRequestedRankArgs e = (OnParticipantRequestedRankArgs)o;
        OnParticipantRequestedRank(e.sender, e);
    }
    
    internal void FireOnParticipantRequestedRank(SktParticipant sender, SktParticipant.RANK value)
    {
        if (OnParticipantRequestedRank == null) return; // Event not assigned    
        OnParticipantRequestedRankArgs args = new OnParticipantRequestedRankArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantRequestedRankInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantRequestedRank, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantTextStatusArgs : EventArgs
    {
        public SktParticipant sender;
        public SktParticipant.TEXT_STATUS value;
        public OnParticipantTextStatusArgs(SktParticipant sender, SktParticipant.TEXT_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantTextStatusHandler OnParticipantTextStatus;    
    public delegate void OnParticipantTextStatusHandler (SktParticipant sender, OnParticipantTextStatusArgs e);
    
    internal void OnParticipantTextStatusInNewThread(object o)
    {
        OnParticipantTextStatusArgs e = (OnParticipantTextStatusArgs)o;
        OnParticipantTextStatus(e.sender, e);
    }
    
    internal void FireOnParticipantTextStatus(SktParticipant sender, SktParticipant.TEXT_STATUS value)
    {
        if (OnParticipantTextStatus == null) return; // Event not assigned    
        OnParticipantTextStatusArgs args = new OnParticipantTextStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantTextStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantTextStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantVoiceStatusArgs : EventArgs
    {
        public SktParticipant sender;
        public SktParticipant.VOICE_STATUS value;
        public OnParticipantVoiceStatusArgs(SktParticipant sender, SktParticipant.VOICE_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantVoiceStatusHandler OnParticipantVoiceStatus;    
    public delegate void OnParticipantVoiceStatusHandler (SktParticipant sender, OnParticipantVoiceStatusArgs e);
    
    internal void OnParticipantVoiceStatusInNewThread(object o)
    {
        OnParticipantVoiceStatusArgs e = (OnParticipantVoiceStatusArgs)o;
        OnParticipantVoiceStatus(e.sender, e);
    }
    
    internal void FireOnParticipantVoiceStatus(SktParticipant sender, SktParticipant.VOICE_STATUS value)
    {
        if (OnParticipantVoiceStatus == null) return; // Event not assigned    
        OnParticipantVoiceStatusArgs args = new OnParticipantVoiceStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantVoiceStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantVoiceStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantVideoStatusArgs : EventArgs
    {
        public SktParticipant sender;
        public SktParticipant.VIDEO_STATUS value;
        public OnParticipantVideoStatusArgs(SktParticipant sender, SktParticipant.VIDEO_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantVideoStatusHandler OnParticipantVideoStatus;    
    public delegate void OnParticipantVideoStatusHandler (SktParticipant sender, OnParticipantVideoStatusArgs e);
    
    internal void OnParticipantVideoStatusInNewThread(object o)
    {
        OnParticipantVideoStatusArgs e = (OnParticipantVideoStatusArgs)o;
        OnParticipantVideoStatus(e.sender, e);
    }
    
    internal void FireOnParticipantVideoStatus(SktParticipant sender, SktParticipant.VIDEO_STATUS value)
    {
        if (OnParticipantVideoStatus == null) return; // Event not assigned    
        OnParticipantVideoStatusArgs args = new OnParticipantVideoStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantVideoStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantVideoStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLiveIdentityArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantLiveIdentityArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLiveIdentityHandler OnParticipantLiveIdentity;    
    public delegate void OnParticipantLiveIdentityHandler (SktParticipant sender, OnParticipantLiveIdentityArgs e);
    
    internal void OnParticipantLiveIdentityInNewThread(object o)
    {
        OnParticipantLiveIdentityArgs e = (OnParticipantLiveIdentityArgs)o;
        OnParticipantLiveIdentity(e.sender, e);
    }
    
    internal void FireOnParticipantLiveIdentity(SktParticipant sender, String value)
    {
        if (OnParticipantLiveIdentity == null) return; // Event not assigned    
        OnParticipantLiveIdentityArgs args = new OnParticipantLiveIdentityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLiveIdentityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLiveIdentity, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLivePriceForMeArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantLivePriceForMeArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLivePriceForMeHandler OnParticipantLivePriceForMe;    
    public delegate void OnParticipantLivePriceForMeHandler (SktParticipant sender, OnParticipantLivePriceForMeArgs e);
    
    internal void OnParticipantLivePriceForMeInNewThread(object o)
    {
        OnParticipantLivePriceForMeArgs e = (OnParticipantLivePriceForMeArgs)o;
        OnParticipantLivePriceForMe(e.sender, e);
    }
    
    internal void FireOnParticipantLivePriceForMe(SktParticipant sender, String value)
    {
        if (OnParticipantLivePriceForMe == null) return; // Event not assigned    
        OnParticipantLivePriceForMeArgs args = new OnParticipantLivePriceForMeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLivePriceForMeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLivePriceForMe, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLiveFwdIdentitiesArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantLiveFwdIdentitiesArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLiveFwdIdentitiesHandler OnParticipantLiveFwdIdentities;    
    public delegate void OnParticipantLiveFwdIdentitiesHandler (SktParticipant sender, OnParticipantLiveFwdIdentitiesArgs e);
    
    internal void OnParticipantLiveFwdIdentitiesInNewThread(object o)
    {
        OnParticipantLiveFwdIdentitiesArgs e = (OnParticipantLiveFwdIdentitiesArgs)o;
        OnParticipantLiveFwdIdentities(e.sender, e);
    }
    
    internal void FireOnParticipantLiveFwdIdentities(SktParticipant sender, String value)
    {
        if (OnParticipantLiveFwdIdentities == null) return; // Event not assigned    
        OnParticipantLiveFwdIdentitiesArgs args = new OnParticipantLiveFwdIdentitiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLiveFwdIdentitiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLiveFwdIdentities, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLiveStartTimestampArgs : EventArgs
    {
        public SktParticipant sender;
        public DateTime value;
        public OnParticipantLiveStartTimestampArgs(SktParticipant sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLiveStartTimestampHandler OnParticipantLiveStartTimestamp;    
    public delegate void OnParticipantLiveStartTimestampHandler (SktParticipant sender, OnParticipantLiveStartTimestampArgs e);
    
    internal void OnParticipantLiveStartTimestampInNewThread(object o)
    {
        OnParticipantLiveStartTimestampArgs e = (OnParticipantLiveStartTimestampArgs)o;
        OnParticipantLiveStartTimestamp(e.sender, e);
    }
    
    internal void FireOnParticipantLiveStartTimestamp(SktParticipant sender, DateTime value)
    {
        if (OnParticipantLiveStartTimestamp == null) return; // Event not assigned    
        OnParticipantLiveStartTimestampArgs args = new OnParticipantLiveStartTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLiveStartTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLiveStartTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantSoundLevelArgs : EventArgs
    {
        public SktParticipant sender;
        public uint value;
        public OnParticipantSoundLevelArgs(SktParticipant sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantSoundLevelHandler OnParticipantSoundLevel;    
    public delegate void OnParticipantSoundLevelHandler (SktParticipant sender, OnParticipantSoundLevelArgs e);
    
    internal void OnParticipantSoundLevelInNewThread(object o)
    {
        OnParticipantSoundLevelArgs e = (OnParticipantSoundLevelArgs)o;
        OnParticipantSoundLevel(e.sender, e);
    }
    
    internal void FireOnParticipantSoundLevel(SktParticipant sender, uint value)
    {
        if (OnParticipantSoundLevel == null) return; // Event not assigned    
        OnParticipantSoundLevelArgs args = new OnParticipantSoundLevelArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantSoundLevelInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantSoundLevel, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantDebuginfoArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantDebuginfoArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantDebuginfoHandler OnParticipantDebuginfo;    
    public delegate void OnParticipantDebuginfoHandler (SktParticipant sender, OnParticipantDebuginfoArgs e);
    
    internal void OnParticipantDebuginfoInNewThread(object o)
    {
        OnParticipantDebuginfoArgs e = (OnParticipantDebuginfoArgs)o;
        OnParticipantDebuginfo(e.sender, e);
    }
    
    internal void FireOnParticipantDebuginfo(SktParticipant sender, String value)
    {
        if (OnParticipantDebuginfo == null) return; // Event not assigned    
        OnParticipantDebuginfoArgs args = new OnParticipantDebuginfoArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantDebuginfoInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantDebuginfo, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLastVoiceErrorArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantLastVoiceErrorArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLastVoiceErrorHandler OnParticipantLastVoiceError;    
    public delegate void OnParticipantLastVoiceErrorHandler (SktParticipant sender, OnParticipantLastVoiceErrorArgs e);
    
    internal void OnParticipantLastVoiceErrorInNewThread(object o)
    {
        OnParticipantLastVoiceErrorArgs e = (OnParticipantLastVoiceErrorArgs)o;
        OnParticipantLastVoiceError(e.sender, e);
    }
    
    internal void FireOnParticipantLastVoiceError(SktParticipant sender, String value)
    {
        if (OnParticipantLastVoiceError == null) return; // Event not assigned    
        OnParticipantLastVoiceErrorArgs args = new OnParticipantLastVoiceErrorArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLastVoiceErrorInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLastVoiceError, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantQualityProblemsArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantQualityProblemsArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantQualityProblemsHandler OnParticipantQualityProblems;    
    public delegate void OnParticipantQualityProblemsHandler (SktParticipant sender, OnParticipantQualityProblemsArgs e);
    
    internal void OnParticipantQualityProblemsInNewThread(object o)
    {
        OnParticipantQualityProblemsArgs e = (OnParticipantQualityProblemsArgs)o;
        OnParticipantQualityProblems(e.sender, e);
    }
    
    internal void FireOnParticipantQualityProblems(SktParticipant sender, String value)
    {
        if (OnParticipantQualityProblems == null) return; // Event not assigned    
        OnParticipantQualityProblemsArgs args = new OnParticipantQualityProblemsArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantQualityProblemsInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantQualityProblems, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLiveTypeArgs : EventArgs
    {
        public SktParticipant sender;
        public SktSkype.IDENTITYTYPE value;
        public OnParticipantLiveTypeArgs(SktParticipant sender, SktSkype.IDENTITYTYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLiveTypeHandler OnParticipantLiveType;    
    public delegate void OnParticipantLiveTypeHandler (SktParticipant sender, OnParticipantLiveTypeArgs e);
    
    internal void OnParticipantLiveTypeInNewThread(object o)
    {
        OnParticipantLiveTypeArgs e = (OnParticipantLiveTypeArgs)o;
        OnParticipantLiveType(e.sender, e);
    }
    
    internal void FireOnParticipantLiveType(SktParticipant sender, SktSkype.IDENTITYTYPE value)
    {
        if (OnParticipantLiveType == null) return; // Event not assigned    
        OnParticipantLiveTypeArgs args = new OnParticipantLiveTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLiveTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLiveType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLiveCountryArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantLiveCountryArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLiveCountryHandler OnParticipantLiveCountry;    
    public delegate void OnParticipantLiveCountryHandler (SktParticipant sender, OnParticipantLiveCountryArgs e);
    
    internal void OnParticipantLiveCountryInNewThread(object o)
    {
        OnParticipantLiveCountryArgs e = (OnParticipantLiveCountryArgs)o;
        OnParticipantLiveCountry(e.sender, e);
    }
    
    internal void FireOnParticipantLiveCountry(SktParticipant sender, String value)
    {
        if (OnParticipantLiveCountry == null) return; // Event not assigned    
        OnParticipantLiveCountryArgs args = new OnParticipantLiveCountryArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLiveCountryInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLiveCountry, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantTransferredByArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantTransferredByArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantTransferredByHandler OnParticipantTransferredBy;    
    public delegate void OnParticipantTransferredByHandler (SktParticipant sender, OnParticipantTransferredByArgs e);
    
    internal void OnParticipantTransferredByInNewThread(object o)
    {
        OnParticipantTransferredByArgs e = (OnParticipantTransferredByArgs)o;
        OnParticipantTransferredBy(e.sender, e);
    }
    
    internal void FireOnParticipantTransferredBy(SktParticipant sender, String value)
    {
        if (OnParticipantTransferredBy == null) return; // Event not assigned    
        OnParticipantTransferredByArgs args = new OnParticipantTransferredByArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantTransferredByInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantTransferredBy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantTransferredToArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantTransferredToArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantTransferredToHandler OnParticipantTransferredTo;    
    public delegate void OnParticipantTransferredToHandler (SktParticipant sender, OnParticipantTransferredToArgs e);
    
    internal void OnParticipantTransferredToInNewThread(object o)
    {
        OnParticipantTransferredToArgs e = (OnParticipantTransferredToArgs)o;
        OnParticipantTransferredTo(e.sender, e);
    }
    
    internal void FireOnParticipantTransferredTo(SktParticipant sender, String value)
    {
        if (OnParticipantTransferredTo == null) return; // Event not assigned    
        OnParticipantTransferredToArgs args = new OnParticipantTransferredToArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantTransferredToInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantTransferredTo, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantAdderArgs : EventArgs
    {
        public SktParticipant sender;
        public String value;
        public OnParticipantAdderArgs(SktParticipant sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantAdderHandler OnParticipantAdder;    
    public delegate void OnParticipantAdderHandler (SktParticipant sender, OnParticipantAdderArgs e);
    
    internal void OnParticipantAdderInNewThread(object o)
    {
        OnParticipantAdderArgs e = (OnParticipantAdderArgs)o;
        OnParticipantAdder(e.sender, e);
    }
    
    internal void FireOnParticipantAdder(SktParticipant sender, String value)
    {
        if (OnParticipantAdder == null) return; // Event not assigned    
        OnParticipantAdderArgs args = new OnParticipantAdderArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantAdderInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantAdder, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnParticipantLastLeavereasonArgs : EventArgs
    {
        public SktParticipant sender;
        public SktSkype.LEAVE_REASON value;
        public OnParticipantLastLeavereasonArgs(SktParticipant sender, SktSkype.LEAVE_REASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnParticipantLastLeavereasonHandler OnParticipantLastLeavereason;    
    public delegate void OnParticipantLastLeavereasonHandler (SktParticipant sender, OnParticipantLastLeavereasonArgs e);
    
    internal void OnParticipantLastLeavereasonInNewThread(object o)
    {
        OnParticipantLastLeavereasonArgs e = (OnParticipantLastLeavereasonArgs)o;
        OnParticipantLastLeavereason(e.sender, e);
    }
    
    internal void FireOnParticipantLastLeavereason(SktParticipant sender, SktSkype.LEAVE_REASON value)
    {
        if (OnParticipantLastLeavereason == null) return; // Event not assigned    
        OnParticipantLastLeavereasonArgs args = new OnParticipantLastLeavereasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnParticipantLastLeavereasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnParticipantLastLeavereason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    public event OnParticipantIncomingDTMFHandler OnParticipantIncomingDTMF;
    
    public delegate void OnParticipantIncomingDTMFHandler (SktParticipant sender, OnParticipantIncomingDTMFArgs e);
    
    public class OnParticipantIncomingDTMFArgs : EventArgs
    {
        public SktParticipant senderobj;
        public SktParticipant.DTMF dtmf;
        public OnParticipantIncomingDTMFArgs () {}
    }
    
    internal void OnParticipantIncomingDTMFInNewThread(object e)
    {
        OnParticipantIncomingDTMFArgs args = (OnParticipantIncomingDTMFArgs)e;
        OnParticipantIncomingDTMF(args.senderobj, args);
    }
    
    internal void FireOnParticipantIncomingDTMF(SktParticipant sender, OnParticipantIncomingDTMFArgs e)
    {
        if (OnParticipantIncomingDTMF == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnParticipantIncomingDTMFInNewThread); return; }
        gui.BeginInvoke(OnParticipantIncomingDTMF, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnParticipantIncomingDTMF (SktParticipant sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnParticipantIncomingDTMF");
        OnParticipantIncomingDTMFArgs args = new OnParticipantIncomingDTMFArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.dtmf = (SktParticipant.DTMF)skypeRef.decoder.DecodeUint();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnParticipantIncomingDTMF", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnParticipantIncomingDTMF(sender, args);
    }
    
    public event OnParticipantLiveSessionVideosChangedHandler OnParticipantLiveSessionVideosChanged;
    
    public delegate void OnParticipantLiveSessionVideosChangedHandler (SktParticipant sender, OnParticipantLiveSessionVideosChangedArgs e);
    
    public class OnParticipantLiveSessionVideosChangedArgs : EventArgs
    {
        public SktParticipant senderobj;
        public OnParticipantLiveSessionVideosChangedArgs () {}
    }
    
    internal void OnParticipantLiveSessionVideosChangedInNewThread(object e)
    {
        OnParticipantLiveSessionVideosChangedArgs args = (OnParticipantLiveSessionVideosChangedArgs)e;
        OnParticipantLiveSessionVideosChanged(args.senderobj, args);
    }
    
    internal void FireOnParticipantLiveSessionVideosChanged(SktParticipant sender, OnParticipantLiveSessionVideosChangedArgs e)
    {
        if (OnParticipantLiveSessionVideosChanged == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnParticipantLiveSessionVideosChangedInNewThread); return; }
        gui.BeginInvoke(OnParticipantLiveSessionVideosChanged, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnParticipantLiveSessionVideosChanged (SktParticipant sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnParticipantLiveSessionVideosChanged");
        OnParticipantLiveSessionVideosChangedArgs args = new OnParticipantLiveSessionVideosChangedArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnParticipantLiveSessionVideosChanged", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnParticipantLiveSessionVideosChanged(sender, args);
    }
    
    public event OnSkypeNewCustomContactGroupHandler OnSkypeNewCustomContactGroup;
    
    public delegate void OnSkypeNewCustomContactGroupHandler (SktSkype sender, OnSkypeNewCustomContactGroupArgs e);
    
    public class OnSkypeNewCustomContactGroupArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktContactGroup group;
        public OnSkypeNewCustomContactGroupArgs () {}
    }
    
    internal void OnSkypeNewCustomContactGroupInNewThread(object e)
    {
        OnSkypeNewCustomContactGroupArgs args = (OnSkypeNewCustomContactGroupArgs)e;
        OnSkypeNewCustomContactGroup(args.senderobj, args);
    }
    
    internal void FireOnSkypeNewCustomContactGroup(SktSkype sender, OnSkypeNewCustomContactGroupArgs e)
    {
        if (OnSkypeNewCustomContactGroup == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeNewCustomContactGroupInNewThread); return; }
        gui.BeginInvoke(OnSkypeNewCustomContactGroup, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeNewCustomContactGroup (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeNewCustomContactGroup");
        OnSkypeNewCustomContactGroupArgs args = new OnSkypeNewCustomContactGroupArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.group = (SktContactGroup)skypeRef.decoder.DecodeObject(10); // SktContactGroup class ID = 10
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeNewCustomContactGroup", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeNewCustomContactGroup(sender, args);
    }
    
    public event OnSkypeContactOnlineAppearanceHandler OnSkypeContactOnlineAppearance;
    
    public delegate void OnSkypeContactOnlineAppearanceHandler (SktSkype sender, OnSkypeContactOnlineAppearanceArgs e);
    
    public class OnSkypeContactOnlineAppearanceArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktContact contact;
        public OnSkypeContactOnlineAppearanceArgs () {}
    }
    
    internal void OnSkypeContactOnlineAppearanceInNewThread(object e)
    {
        OnSkypeContactOnlineAppearanceArgs args = (OnSkypeContactOnlineAppearanceArgs)e;
        OnSkypeContactOnlineAppearance(args.senderobj, args);
    }
    
    internal void FireOnSkypeContactOnlineAppearance(SktSkype sender, OnSkypeContactOnlineAppearanceArgs e)
    {
        if (OnSkypeContactOnlineAppearance == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeContactOnlineAppearanceInNewThread); return; }
        gui.BeginInvoke(OnSkypeContactOnlineAppearance, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeContactOnlineAppearance (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeContactOnlineAppearance");
        OnSkypeContactOnlineAppearanceArgs args = new OnSkypeContactOnlineAppearanceArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.contact = (SktContact)skypeRef.decoder.DecodeObject(2); // SktContact class ID = 2
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeContactOnlineAppearance", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeContactOnlineAppearance(sender, args);
    }
    
    public event OnSkypeContactGoneOfflineHandler OnSkypeContactGoneOffline;
    
    public delegate void OnSkypeContactGoneOfflineHandler (SktSkype sender, OnSkypeContactGoneOfflineArgs e);
    
    public class OnSkypeContactGoneOfflineArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktContact contact;
        public OnSkypeContactGoneOfflineArgs () {}
    }
    
    internal void OnSkypeContactGoneOfflineInNewThread(object e)
    {
        OnSkypeContactGoneOfflineArgs args = (OnSkypeContactGoneOfflineArgs)e;
        OnSkypeContactGoneOffline(args.senderobj, args);
    }
    
    internal void FireOnSkypeContactGoneOffline(SktSkype sender, OnSkypeContactGoneOfflineArgs e)
    {
        if (OnSkypeContactGoneOffline == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeContactGoneOfflineInNewThread); return; }
        gui.BeginInvoke(OnSkypeContactGoneOffline, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeContactGoneOffline (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeContactGoneOffline");
        OnSkypeContactGoneOfflineArgs args = new OnSkypeContactGoneOfflineArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.contact = (SktContact)skypeRef.decoder.DecodeObject(2); // SktContact class ID = 2
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeContactGoneOffline", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeContactGoneOffline(sender, args);
    }
    
    public event OnSkypeConversationListChangeHandler OnSkypeConversationListChange;
    
    public delegate void OnSkypeConversationListChangeHandler (SktSkype sender, OnSkypeConversationListChangeArgs e);
    
    public class OnSkypeConversationListChangeArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktConversation conversation;
        public SktConversation.LIST_TYPE type;
        public Boolean added;
        public OnSkypeConversationListChangeArgs () {}
    }
    
    internal void OnSkypeConversationListChangeInNewThread(object e)
    {
        OnSkypeConversationListChangeArgs args = (OnSkypeConversationListChangeArgs)e;
        OnSkypeConversationListChange(args.senderobj, args);
    }
    
    internal void FireOnSkypeConversationListChange(SktSkype sender, OnSkypeConversationListChangeArgs e)
    {
        if (OnSkypeConversationListChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeConversationListChangeInNewThread); return; }
        gui.BeginInvoke(OnSkypeConversationListChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeConversationListChange (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeConversationListChange");
        OnSkypeConversationListChangeArgs args = new OnSkypeConversationListChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.conversation = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
                    break;
                case 2:
                    args.type = (SktConversation.LIST_TYPE)skypeRef.decoder.DecodeUint();
                    break;
                case 3:
                    args.added = (typeTag == 'T');
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeConversationListChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeConversationListChange(sender, args);
    }
    
    public event OnSkypeMessageHandler OnSkypeMessage;
    
    public delegate void OnSkypeMessageHandler (SktSkype sender, OnSkypeMessageArgs e);
    
    public class OnSkypeMessageArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktMessage message;
        public Boolean changesInboxTimestamp;
        public SktMessage supersedesHistoryMessage;
        public SktConversation conversation;
        public OnSkypeMessageArgs () {}
    }
    
    internal void OnSkypeMessageInNewThread(object e)
    {
        OnSkypeMessageArgs args = (OnSkypeMessageArgs)e;
        OnSkypeMessage(args.senderobj, args);
    }
    
    internal void FireOnSkypeMessage(SktSkype sender, OnSkypeMessageArgs e)
    {
        if (OnSkypeMessage == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeMessageInNewThread); return; }
        gui.BeginInvoke(OnSkypeMessage, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeMessage (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeMessage");
        OnSkypeMessageArgs args = new OnSkypeMessageArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.message = (SktMessage)skypeRef.decoder.DecodeObject(9); // SktMessage class ID = 9
                    break;
                case 2:
                    args.changesInboxTimestamp = (typeTag == 'T');
                    break;
                case 3:
                    args.supersedesHistoryMessage = (SktMessage)skypeRef.decoder.DecodeObject(9); // SktMessage class ID = 9
                    break;
                case 4:
                    args.conversation = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeMessage", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeMessage(sender, args);
    }
    
    public event OnSkypeAvailableVideoDeviceListChangeHandler OnSkypeAvailableVideoDeviceListChange;
    
    public delegate void OnSkypeAvailableVideoDeviceListChangeHandler (SktSkype sender, OnSkypeAvailableVideoDeviceListChangeArgs e);
    
    public class OnSkypeAvailableVideoDeviceListChangeArgs : EventArgs
    {
        public SktSkype senderobj;
        public OnSkypeAvailableVideoDeviceListChangeArgs () {}
    }
    
    internal void OnSkypeAvailableVideoDeviceListChangeInNewThread(object e)
    {
        OnSkypeAvailableVideoDeviceListChangeArgs args = (OnSkypeAvailableVideoDeviceListChangeArgs)e;
        OnSkypeAvailableVideoDeviceListChange(args.senderobj, args);
    }
    
    internal void FireOnSkypeAvailableVideoDeviceListChange(SktSkype sender, OnSkypeAvailableVideoDeviceListChangeArgs e)
    {
        if (OnSkypeAvailableVideoDeviceListChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeAvailableVideoDeviceListChangeInNewThread); return; }
        gui.BeginInvoke(OnSkypeAvailableVideoDeviceListChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeAvailableVideoDeviceListChange (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeAvailableVideoDeviceListChange");
        OnSkypeAvailableVideoDeviceListChangeArgs args = new OnSkypeAvailableVideoDeviceListChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeAvailableVideoDeviceListChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeAvailableVideoDeviceListChange(sender, args);
    }
    
    public event OnSkypeH264ActivatedHandler OnSkypeH264Activated;
    
    public delegate void OnSkypeH264ActivatedHandler (SktSkype sender, OnSkypeH264ActivatedArgs e);
    
    public class OnSkypeH264ActivatedArgs : EventArgs
    {
        public SktSkype senderobj;
        public OnSkypeH264ActivatedArgs () {}
    }
    
    internal void OnSkypeH264ActivatedInNewThread(object e)
    {
        OnSkypeH264ActivatedArgs args = (OnSkypeH264ActivatedArgs)e;
        OnSkypeH264Activated(args.senderobj, args);
    }
    
    internal void FireOnSkypeH264Activated(SktSkype sender, OnSkypeH264ActivatedArgs e)
    {
        if (OnSkypeH264Activated == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeH264ActivatedInNewThread); return; }
        gui.BeginInvoke(OnSkypeH264Activated, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeH264Activated (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeH264Activated");
        OnSkypeH264ActivatedArgs args = new OnSkypeH264ActivatedArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeH264Activated", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeH264Activated(sender, args);
    }
    
    public event OnSkypeQualityTestResultHandler OnSkypeQualityTestResult;
    
    public delegate void OnSkypeQualityTestResultHandler (SktSkype sender, OnSkypeQualityTestResultArgs e);
    
    public class OnSkypeQualityTestResultArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktSkype.QUALITYTESTTYPE testType;
        public SktSkype.QUALITYTESTRESULT testResult;
        public String withUser;
        public String details;
        public String xmlDetails;
        public OnSkypeQualityTestResultArgs () {}
    }
    
    internal void OnSkypeQualityTestResultInNewThread(object e)
    {
        OnSkypeQualityTestResultArgs args = (OnSkypeQualityTestResultArgs)e;
        OnSkypeQualityTestResult(args.senderobj, args);
    }
    
    internal void FireOnSkypeQualityTestResult(SktSkype sender, OnSkypeQualityTestResultArgs e)
    {
        if (OnSkypeQualityTestResult == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeQualityTestResultInNewThread); return; }
        gui.BeginInvoke(OnSkypeQualityTestResult, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeQualityTestResult (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeQualityTestResult");
        OnSkypeQualityTestResultArgs args = new OnSkypeQualityTestResultArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 0:
                    args.testType = (SktSkype.QUALITYTESTTYPE)skypeRef.decoder.DecodeUint();
                    break;
                case 1:
                    args.testResult = (SktSkype.QUALITYTESTRESULT)skypeRef.decoder.DecodeUint();
                    break;
                case 2:
                    args.withUser = skypeRef.decoder.DecodeString();
                    break;
                case 3:
                    args.details = skypeRef.decoder.DecodeString();
                    break;
                case 4:
                    args.xmlDetails = skypeRef.decoder.DecodeXML();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeQualityTestResult", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeQualityTestResult(sender, args);
    }
    
    public event OnSkypeAvailableDeviceListChangeHandler OnSkypeAvailableDeviceListChange;
    
    public delegate void OnSkypeAvailableDeviceListChangeHandler (SktSkype sender, OnSkypeAvailableDeviceListChangeArgs e);
    
    public class OnSkypeAvailableDeviceListChangeArgs : EventArgs
    {
        public SktSkype senderobj;
        public OnSkypeAvailableDeviceListChangeArgs () {}
    }
    
    internal void OnSkypeAvailableDeviceListChangeInNewThread(object e)
    {
        OnSkypeAvailableDeviceListChangeArgs args = (OnSkypeAvailableDeviceListChangeArgs)e;
        OnSkypeAvailableDeviceListChange(args.senderobj, args);
    }
    
    internal void FireOnSkypeAvailableDeviceListChange(SktSkype sender, OnSkypeAvailableDeviceListChangeArgs e)
    {
        if (OnSkypeAvailableDeviceListChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeAvailableDeviceListChangeInNewThread); return; }
        gui.BeginInvoke(OnSkypeAvailableDeviceListChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeAvailableDeviceListChange (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeAvailableDeviceListChange");
        OnSkypeAvailableDeviceListChangeArgs args = new OnSkypeAvailableDeviceListChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeAvailableDeviceListChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeAvailableDeviceListChange(sender, args);
    }
    
    public event OnSkypeNrgLevelsChangeHandler OnSkypeNrgLevelsChange;
    
    public delegate void OnSkypeNrgLevelsChangeHandler (SktSkype sender, OnSkypeNrgLevelsChangeArgs e);
    
    public class OnSkypeNrgLevelsChangeArgs : EventArgs
    {
        public SktSkype senderobj;
        public OnSkypeNrgLevelsChangeArgs () {}
    }
    
    internal void OnSkypeNrgLevelsChangeInNewThread(object e)
    {
        OnSkypeNrgLevelsChangeArgs args = (OnSkypeNrgLevelsChangeArgs)e;
        OnSkypeNrgLevelsChange(args.senderobj, args);
    }
    
    internal void FireOnSkypeNrgLevelsChange(SktSkype sender, OnSkypeNrgLevelsChangeArgs e)
    {
        if (OnSkypeNrgLevelsChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeNrgLevelsChangeInNewThread); return; }
        gui.BeginInvoke(OnSkypeNrgLevelsChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeNrgLevelsChange (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeNrgLevelsChange");
        OnSkypeNrgLevelsChangeArgs args = new OnSkypeNrgLevelsChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeNrgLevelsChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeNrgLevelsChange(sender, args);
    }
    
    public event OnSkypeProxyAuthFailureHandler OnSkypeProxyAuthFailure;
    
    public delegate void OnSkypeProxyAuthFailureHandler (SktSkype sender, OnSkypeProxyAuthFailureArgs e);
    
    public class OnSkypeProxyAuthFailureArgs : EventArgs
    {
        public SktSkype senderobj;
        public SktSkype.PROXYTYPE type;
        public OnSkypeProxyAuthFailureArgs () {}
    }
    
    internal void OnSkypeProxyAuthFailureInNewThread(object e)
    {
        OnSkypeProxyAuthFailureArgs args = (OnSkypeProxyAuthFailureArgs)e;
        OnSkypeProxyAuthFailure(args.senderobj, args);
    }
    
    internal void FireOnSkypeProxyAuthFailure(SktSkype sender, OnSkypeProxyAuthFailureArgs e)
    {
        if (OnSkypeProxyAuthFailure == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeProxyAuthFailureInNewThread); return; }
        gui.BeginInvoke(OnSkypeProxyAuthFailure, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeProxyAuthFailure (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeProxyAuthFailure");
        OnSkypeProxyAuthFailureArgs args = new OnSkypeProxyAuthFailureArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.type = (SktSkype.PROXYTYPE)skypeRef.decoder.DecodeUint();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeProxyAuthFailure", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeProxyAuthFailure(sender, args);
    }
    
    public event OnSkypeApp2AppDatagramHandler OnSkypeApp2AppDatagram;
    
    public delegate void OnSkypeApp2AppDatagramHandler (SktSkype sender, OnSkypeApp2AppDatagramArgs e);
    
    public class OnSkypeApp2AppDatagramArgs : EventArgs
    {
        public SktSkype senderobj;
        public String appname;
        public String stream;
        public byte[] data;
        public OnSkypeApp2AppDatagramArgs () {}
    }
    
    internal void OnSkypeApp2AppDatagramInNewThread(object e)
    {
        OnSkypeApp2AppDatagramArgs args = (OnSkypeApp2AppDatagramArgs)e;
        OnSkypeApp2AppDatagram(args.senderobj, args);
    }
    
    internal void FireOnSkypeApp2AppDatagram(SktSkype sender, OnSkypeApp2AppDatagramArgs e)
    {
        if (OnSkypeApp2AppDatagram == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeApp2AppDatagramInNewThread); return; }
        gui.BeginInvoke(OnSkypeApp2AppDatagram, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeApp2AppDatagram (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeApp2AppDatagram");
        OnSkypeApp2AppDatagramArgs args = new OnSkypeApp2AppDatagramArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.appname = skypeRef.decoder.DecodeString();
                    break;
                case 2:
                    args.stream = skypeRef.decoder.DecodeString();
                    break;
                case 3:
                    args.data = skypeRef.decoder.DecodeBinary();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeApp2AppDatagram", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeApp2AppDatagram(sender, args);
    }
    
    public event OnSkypeApp2AppStreamListChangeHandler OnSkypeApp2AppStreamListChange;
    
    public delegate void OnSkypeApp2AppStreamListChangeHandler (SktSkype sender, OnSkypeApp2AppStreamListChangeArgs e);
    
    public class OnSkypeApp2AppStreamListChangeArgs : EventArgs
    {
        public SktSkype senderobj;
        public String appname;
        public SktSkype.APP2APP_STREAMS listType;
        public List<String> streams;
        public List<uint> receivedSizes;
        public OnSkypeApp2AppStreamListChangeArgs () {}
    }
    
    internal void OnSkypeApp2AppStreamListChangeInNewThread(object e)
    {
        OnSkypeApp2AppStreamListChangeArgs args = (OnSkypeApp2AppStreamListChangeArgs)e;
        OnSkypeApp2AppStreamListChange(args.senderobj, args);
    }
    
    internal void FireOnSkypeApp2AppStreamListChange(SktSkype sender, OnSkypeApp2AppStreamListChangeArgs e)
    {
        if (OnSkypeApp2AppStreamListChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnSkypeApp2AppStreamListChangeInNewThread); return; }
        gui.BeginInvoke(OnSkypeApp2AppStreamListChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnSkypeApp2AppStreamListChange (SktSkype sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnSkypeApp2AppStreamListChange");
        OnSkypeApp2AppStreamListChangeArgs args = new OnSkypeApp2AppStreamListChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.appname = skypeRef.decoder.DecodeString();
                    break;
                case 2:
                    args.listType = (SktSkype.APP2APP_STREAMS)skypeRef.decoder.DecodeUint();
                    break;
                case 3:
                    args.streams = skypeRef.decoder.DecodeStringList();
                    break;
                case 4:
                    args.receivedSizes = skypeRef.decoder.DecodeUintList();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnSkypeApp2AppStreamListChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnSkypeApp2AppStreamListChange(sender, args);
    }
    
    
    public class OnContactGroupTypeArgs : EventArgs
    {
        public SktContactGroup sender;
        public SktContactGroup.TYPE value;
        public OnContactGroupTypeArgs(SktContactGroup sender, SktContactGroup.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGroupTypeHandler OnContactGroupType;    
    public delegate void OnContactGroupTypeHandler (SktContactGroup sender, OnContactGroupTypeArgs e);
    
    internal void OnContactGroupTypeInNewThread(object o)
    {
        OnContactGroupTypeArgs e = (OnContactGroupTypeArgs)o;
        OnContactGroupType(e.sender, e);
    }
    
    internal void FireOnContactGroupType(SktContactGroup sender, SktContactGroup.TYPE value)
    {
        if (OnContactGroupType == null) return; // Event not assigned    
        OnContactGroupTypeArgs args = new OnContactGroupTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGroupTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGroupType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGroupCustomGroupIdArgs : EventArgs
    {
        public SktContactGroup sender;
        public uint value;
        public OnContactGroupCustomGroupIdArgs(SktContactGroup sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGroupCustomGroupIdHandler OnContactGroupCustomGroupId;    
    public delegate void OnContactGroupCustomGroupIdHandler (SktContactGroup sender, OnContactGroupCustomGroupIdArgs e);
    
    internal void OnContactGroupCustomGroupIdInNewThread(object o)
    {
        OnContactGroupCustomGroupIdArgs e = (OnContactGroupCustomGroupIdArgs)o;
        OnContactGroupCustomGroupId(e.sender, e);
    }
    
    internal void FireOnContactGroupCustomGroupId(SktContactGroup sender, uint value)
    {
        if (OnContactGroupCustomGroupId == null) return; // Event not assigned    
        OnContactGroupCustomGroupIdArgs args = new OnContactGroupCustomGroupIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGroupCustomGroupIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGroupCustomGroupId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGroupGivenDisplaynameArgs : EventArgs
    {
        public SktContactGroup sender;
        public String value;
        public OnContactGroupGivenDisplaynameArgs(SktContactGroup sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGroupGivenDisplaynameHandler OnContactGroupGivenDisplayname;    
    public delegate void OnContactGroupGivenDisplaynameHandler (SktContactGroup sender, OnContactGroupGivenDisplaynameArgs e);
    
    internal void OnContactGroupGivenDisplaynameInNewThread(object o)
    {
        OnContactGroupGivenDisplaynameArgs e = (OnContactGroupGivenDisplaynameArgs)o;
        OnContactGroupGivenDisplayname(e.sender, e);
    }
    
    internal void FireOnContactGroupGivenDisplayname(SktContactGroup sender, String value)
    {
        if (OnContactGroupGivenDisplayname == null) return; // Event not assigned    
        OnContactGroupGivenDisplaynameArgs args = new OnContactGroupGivenDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGroupGivenDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGroupGivenDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGroupNrofcontactsArgs : EventArgs
    {
        public SktContactGroup sender;
        public uint value;
        public OnContactGroupNrofcontactsArgs(SktContactGroup sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGroupNrofcontactsHandler OnContactGroupNrofcontacts;    
    public delegate void OnContactGroupNrofcontactsHandler (SktContactGroup sender, OnContactGroupNrofcontactsArgs e);
    
    internal void OnContactGroupNrofcontactsInNewThread(object o)
    {
        OnContactGroupNrofcontactsArgs e = (OnContactGroupNrofcontactsArgs)o;
        OnContactGroupNrofcontacts(e.sender, e);
    }
    
    internal void FireOnContactGroupNrofcontacts(SktContactGroup sender, uint value)
    {
        if (OnContactGroupNrofcontacts == null) return; // Event not assigned    
        OnContactGroupNrofcontactsArgs args = new OnContactGroupNrofcontactsArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGroupNrofcontactsInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGroupNrofcontacts, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGroupNrofcontactsOnlineArgs : EventArgs
    {
        public SktContactGroup sender;
        public uint value;
        public OnContactGroupNrofcontactsOnlineArgs(SktContactGroup sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGroupNrofcontactsOnlineHandler OnContactGroupNrofcontactsOnline;    
    public delegate void OnContactGroupNrofcontactsOnlineHandler (SktContactGroup sender, OnContactGroupNrofcontactsOnlineArgs e);
    
    internal void OnContactGroupNrofcontactsOnlineInNewThread(object o)
    {
        OnContactGroupNrofcontactsOnlineArgs e = (OnContactGroupNrofcontactsOnlineArgs)o;
        OnContactGroupNrofcontactsOnline(e.sender, e);
    }
    
    internal void FireOnContactGroupNrofcontactsOnline(SktContactGroup sender, uint value)
    {
        if (OnContactGroupNrofcontactsOnline == null) return; // Event not assigned    
        OnContactGroupNrofcontactsOnlineArgs args = new OnContactGroupNrofcontactsOnlineArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGroupNrofcontactsOnlineInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGroupNrofcontactsOnline, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    public event OnContactGroupChangeConversationHandler OnContactGroupChangeConversation;
    
    public delegate void OnContactGroupChangeConversationHandler (SktContactGroup sender, OnContactGroupChangeConversationArgs e);
    
    public class OnContactGroupChangeConversationArgs : EventArgs
    {
        public SktContactGroup senderobj;
        public SktConversation conversation;
        public OnContactGroupChangeConversationArgs () {}
    }
    
    internal void OnContactGroupChangeConversationInNewThread(object e)
    {
        OnContactGroupChangeConversationArgs args = (OnContactGroupChangeConversationArgs)e;
        OnContactGroupChangeConversation(args.senderobj, args);
    }
    
    internal void FireOnContactGroupChangeConversation(SktContactGroup sender, OnContactGroupChangeConversationArgs e)
    {
        if (OnContactGroupChangeConversation == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnContactGroupChangeConversationInNewThread); return; }
        gui.BeginInvoke(OnContactGroupChangeConversation, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnContactGroupChangeConversation (SktContactGroup sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnContactGroupChangeConversation");
        OnContactGroupChangeConversationArgs args = new OnContactGroupChangeConversationArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.conversation = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnContactGroupChangeConversation", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnContactGroupChangeConversation(sender, args);
    }
    
    public event OnContactGroupChangeHandler OnContactGroupChange;
    
    public delegate void OnContactGroupChangeHandler (SktContactGroup sender, OnContactGroupChangeArgs e);
    
    public class OnContactGroupChangeArgs : EventArgs
    {
        public SktContactGroup senderobj;
        public SktContact contact;
        public OnContactGroupChangeArgs () {}
    }
    
    internal void OnContactGroupChangeInNewThread(object e)
    {
        OnContactGroupChangeArgs args = (OnContactGroupChangeArgs)e;
        OnContactGroupChange(args.senderobj, args);
    }
    
    internal void FireOnContactGroupChange(SktContactGroup sender, OnContactGroupChangeArgs e)
    {
        if (OnContactGroupChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnContactGroupChangeInNewThread); return; }
        gui.BeginInvoke(OnContactGroupChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnContactGroupChange (SktContactGroup sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnContactGroupChange");
        OnContactGroupChangeArgs args = new OnContactGroupChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.contact = (SktContact)skypeRef.decoder.DecodeObject(2); // SktContact class ID = 2
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnContactGroupChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnContactGroupChange(sender, args);
    }
    
    
    public class OnVideoStatusArgs : EventArgs
    {
        public SktVideo sender;
        public SktVideo.STATUS value;
        public OnVideoStatusArgs(SktVideo sender, SktVideo.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoStatusHandler OnVideoStatus;    
    public delegate void OnVideoStatusHandler (SktVideo sender, OnVideoStatusArgs e);
    
    internal void OnVideoStatusInNewThread(object o)
    {
        OnVideoStatusArgs e = (OnVideoStatusArgs)o;
        OnVideoStatus(e.sender, e);
    }
    
    internal void FireOnVideoStatus(SktVideo sender, SktVideo.STATUS value)
    {
        if (OnVideoStatus == null) return; // Event not assigned    
        OnVideoStatusArgs args = new OnVideoStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoErrorArgs : EventArgs
    {
        public SktVideo sender;
        public String value;
        public OnVideoErrorArgs(SktVideo sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoErrorHandler OnVideoError;    
    public delegate void OnVideoErrorHandler (SktVideo sender, OnVideoErrorArgs e);
    
    internal void OnVideoErrorInNewThread(object o)
    {
        OnVideoErrorArgs e = (OnVideoErrorArgs)o;
        OnVideoError(e.sender, e);
    }
    
    internal void FireOnVideoError(SktVideo sender, String value)
    {
        if (OnVideoError == null) return; // Event not assigned    
        OnVideoErrorArgs args = new OnVideoErrorArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoErrorInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoError, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoDebuginfoArgs : EventArgs
    {
        public SktVideo sender;
        public String value;
        public OnVideoDebuginfoArgs(SktVideo sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoDebuginfoHandler OnVideoDebuginfo;    
    public delegate void OnVideoDebuginfoHandler (SktVideo sender, OnVideoDebuginfoArgs e);
    
    internal void OnVideoDebuginfoInNewThread(object o)
    {
        OnVideoDebuginfoArgs e = (OnVideoDebuginfoArgs)o;
        OnVideoDebuginfo(e.sender, e);
    }
    
    internal void FireOnVideoDebuginfo(SktVideo sender, String value)
    {
        if (OnVideoDebuginfo == null) return; // Event not assigned    
        OnVideoDebuginfoArgs args = new OnVideoDebuginfoArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoDebuginfoInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoDebuginfo, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoDimensionsArgs : EventArgs
    {
        public SktVideo sender;
        public String value;
        public OnVideoDimensionsArgs(SktVideo sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoDimensionsHandler OnVideoDimensions;    
    public delegate void OnVideoDimensionsHandler (SktVideo sender, OnVideoDimensionsArgs e);
    
    internal void OnVideoDimensionsInNewThread(object o)
    {
        OnVideoDimensionsArgs e = (OnVideoDimensionsArgs)o;
        OnVideoDimensions(e.sender, e);
    }
    
    internal void FireOnVideoDimensions(SktVideo sender, String value)
    {
        if (OnVideoDimensions == null) return; // Event not assigned    
        OnVideoDimensionsArgs args = new OnVideoDimensionsArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoDimensionsInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoDimensions, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoMediaTypeArgs : EventArgs
    {
        public SktVideo sender;
        public SktVideo.MEDIATYPE value;
        public OnVideoMediaTypeArgs(SktVideo sender, SktVideo.MEDIATYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoMediaTypeHandler OnVideoMediaType;    
    public delegate void OnVideoMediaTypeHandler (SktVideo sender, OnVideoMediaTypeArgs e);
    
    internal void OnVideoMediaTypeInNewThread(object o)
    {
        OnVideoMediaTypeArgs e = (OnVideoMediaTypeArgs)o;
        OnVideoMediaType(e.sender, e);
    }
    
    internal void FireOnVideoMediaType(SktVideo sender, SktVideo.MEDIATYPE value)
    {
        if (OnVideoMediaType == null) return; // Event not assigned    
        OnVideoMediaTypeArgs args = new OnVideoMediaTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoMediaTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoMediaType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoConvoIdArgs : EventArgs
    {
        public SktVideo sender;
        public SktConversation value;
        public OnVideoConvoIdArgs(SktVideo sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoConvoIdHandler OnVideoConvoId;    
    public delegate void OnVideoConvoIdHandler (SktVideo sender, OnVideoConvoIdArgs e);
    
    internal void OnVideoConvoIdInNewThread(object o)
    {
        OnVideoConvoIdArgs e = (OnVideoConvoIdArgs)o;
        OnVideoConvoId(e.sender, e);
    }
    
    internal void FireOnVideoConvoId(SktVideo sender, SktConversation value)
    {
        if (OnVideoConvoId == null) return; // Event not assigned    
        OnVideoConvoIdArgs args = new OnVideoConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVideoDevicePathArgs : EventArgs
    {
        public SktVideo sender;
        public String value;
        public OnVideoDevicePathArgs(SktVideo sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVideoDevicePathHandler OnVideoDevicePath;    
    public delegate void OnVideoDevicePathHandler (SktVideo sender, OnVideoDevicePathArgs e);
    
    internal void OnVideoDevicePathInNewThread(object o)
    {
        OnVideoDevicePathArgs e = (OnVideoDevicePathArgs)o;
        OnVideoDevicePath(e.sender, e);
    }
    
    internal void FireOnVideoDevicePath(SktVideo sender, String value)
    {
        if (OnVideoDevicePath == null) return; // Event not assigned    
        OnVideoDevicePathArgs args = new OnVideoDevicePathArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVideoDevicePathInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVideoDevicePath, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageConvoIdArgs : EventArgs
    {
        public SktMessage sender;
        public SktConversation value;
        public OnMessageConvoIdArgs(SktMessage sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageConvoIdHandler OnMessageConvoId;    
    public delegate void OnMessageConvoIdHandler (SktMessage sender, OnMessageConvoIdArgs e);
    
    internal void OnMessageConvoIdInNewThread(object o)
    {
        OnMessageConvoIdArgs e = (OnMessageConvoIdArgs)o;
        OnMessageConvoId(e.sender, e);
    }
    
    internal void FireOnMessageConvoId(SktMessage sender, SktConversation value)
    {
        if (OnMessageConvoId == null) return; // Event not assigned    
        OnMessageConvoIdArgs args = new OnMessageConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageConvoGuidArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageConvoGuidArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageConvoGuidHandler OnMessageConvoGuid;    
    public delegate void OnMessageConvoGuidHandler (SktMessage sender, OnMessageConvoGuidArgs e);
    
    internal void OnMessageConvoGuidInNewThread(object o)
    {
        OnMessageConvoGuidArgs e = (OnMessageConvoGuidArgs)o;
        OnMessageConvoGuid(e.sender, e);
    }
    
    internal void FireOnMessageConvoGuid(SktMessage sender, String value)
    {
        if (OnMessageConvoGuid == null) return; // Event not assigned    
        OnMessageConvoGuidArgs args = new OnMessageConvoGuidArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageConvoGuidInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageConvoGuid, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageAuthorArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageAuthorArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageAuthorHandler OnMessageAuthor;    
    public delegate void OnMessageAuthorHandler (SktMessage sender, OnMessageAuthorArgs e);
    
    internal void OnMessageAuthorInNewThread(object o)
    {
        OnMessageAuthorArgs e = (OnMessageAuthorArgs)o;
        OnMessageAuthor(e.sender, e);
    }
    
    internal void FireOnMessageAuthor(SktMessage sender, String value)
    {
        if (OnMessageAuthor == null) return; // Event not assigned    
        OnMessageAuthorArgs args = new OnMessageAuthorArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageAuthorInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageAuthor, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageAuthorDisplaynameArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageAuthorDisplaynameArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageAuthorDisplaynameHandler OnMessageAuthorDisplayname;    
    public delegate void OnMessageAuthorDisplaynameHandler (SktMessage sender, OnMessageAuthorDisplaynameArgs e);
    
    internal void OnMessageAuthorDisplaynameInNewThread(object o)
    {
        OnMessageAuthorDisplaynameArgs e = (OnMessageAuthorDisplaynameArgs)o;
        OnMessageAuthorDisplayname(e.sender, e);
    }
    
    internal void FireOnMessageAuthorDisplayname(SktMessage sender, String value)
    {
        if (OnMessageAuthorDisplayname == null) return; // Event not assigned    
        OnMessageAuthorDisplaynameArgs args = new OnMessageAuthorDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageAuthorDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageAuthorDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageGuidArgs : EventArgs
    {
        public SktMessage sender;
        public byte[] value;
        public OnMessageGuidArgs(SktMessage sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageGuidHandler OnMessageGuid;    
    public delegate void OnMessageGuidHandler (SktMessage sender, OnMessageGuidArgs e);
    
    internal void OnMessageGuidInNewThread(object o)
    {
        OnMessageGuidArgs e = (OnMessageGuidArgs)o;
        OnMessageGuid(e.sender, e);
    }
    
    internal void FireOnMessageGuid(SktMessage sender, byte[] value)
    {
        if (OnMessageGuid == null) return; // Event not assigned    
        OnMessageGuidArgs args = new OnMessageGuidArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageGuidInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageGuid, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageOriginallyMeantForArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageOriginallyMeantForArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageOriginallyMeantForHandler OnMessageOriginallyMeantFor;    
    public delegate void OnMessageOriginallyMeantForHandler (SktMessage sender, OnMessageOriginallyMeantForArgs e);
    
    internal void OnMessageOriginallyMeantForInNewThread(object o)
    {
        OnMessageOriginallyMeantForArgs e = (OnMessageOriginallyMeantForArgs)o;
        OnMessageOriginallyMeantFor(e.sender, e);
    }
    
    internal void FireOnMessageOriginallyMeantFor(SktMessage sender, String value)
    {
        if (OnMessageOriginallyMeantFor == null) return; // Event not assigned    
        OnMessageOriginallyMeantForArgs args = new OnMessageOriginallyMeantForArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageOriginallyMeantForInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageOriginallyMeantFor, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageTimestampArgs : EventArgs
    {
        public SktMessage sender;
        public DateTime value;
        public OnMessageTimestampArgs(SktMessage sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageTimestampHandler OnMessageTimestamp;    
    public delegate void OnMessageTimestampHandler (SktMessage sender, OnMessageTimestampArgs e);
    
    internal void OnMessageTimestampInNewThread(object o)
    {
        OnMessageTimestampArgs e = (OnMessageTimestampArgs)o;
        OnMessageTimestamp(e.sender, e);
    }
    
    internal void FireOnMessageTimestamp(SktMessage sender, DateTime value)
    {
        if (OnMessageTimestamp == null) return; // Event not assigned    
        OnMessageTimestampArgs args = new OnMessageTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageTypeArgs : EventArgs
    {
        public SktMessage sender;
        public SktMessage.TYPE value;
        public OnMessageTypeArgs(SktMessage sender, SktMessage.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageTypeHandler OnMessageType;    
    public delegate void OnMessageTypeHandler (SktMessage sender, OnMessageTypeArgs e);
    
    internal void OnMessageTypeInNewThread(object o)
    {
        OnMessageTypeArgs e = (OnMessageTypeArgs)o;
        OnMessageType(e.sender, e);
    }
    
    internal void FireOnMessageType(SktMessage sender, SktMessage.TYPE value)
    {
        if (OnMessageType == null) return; // Event not assigned    
        OnMessageTypeArgs args = new OnMessageTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageSendingStatusArgs : EventArgs
    {
        public SktMessage sender;
        public SktMessage.SENDING_STATUS value;
        public OnMessageSendingStatusArgs(SktMessage sender, SktMessage.SENDING_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageSendingStatusHandler OnMessageSendingStatus;    
    public delegate void OnMessageSendingStatusHandler (SktMessage sender, OnMessageSendingStatusArgs e);
    
    internal void OnMessageSendingStatusInNewThread(object o)
    {
        OnMessageSendingStatusArgs e = (OnMessageSendingStatusArgs)o;
        OnMessageSendingStatus(e.sender, e);
    }
    
    internal void FireOnMessageSendingStatus(SktMessage sender, SktMessage.SENDING_STATUS value)
    {
        if (OnMessageSendingStatus == null) return; // Event not assigned    
        OnMessageSendingStatusArgs args = new OnMessageSendingStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageSendingStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageSendingStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageConsumptionStatusArgs : EventArgs
    {
        public SktMessage sender;
        public SktMessage.CONSUMPTION_STATUS value;
        public OnMessageConsumptionStatusArgs(SktMessage sender, SktMessage.CONSUMPTION_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageConsumptionStatusHandler OnMessageConsumptionStatus;    
    public delegate void OnMessageConsumptionStatusHandler (SktMessage sender, OnMessageConsumptionStatusArgs e);
    
    internal void OnMessageConsumptionStatusInNewThread(object o)
    {
        OnMessageConsumptionStatusArgs e = (OnMessageConsumptionStatusArgs)o;
        OnMessageConsumptionStatus(e.sender, e);
    }
    
    internal void FireOnMessageConsumptionStatus(SktMessage sender, SktMessage.CONSUMPTION_STATUS value)
    {
        if (OnMessageConsumptionStatus == null) return; // Event not assigned    
        OnMessageConsumptionStatusArgs args = new OnMessageConsumptionStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageConsumptionStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageConsumptionStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageEditedByArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageEditedByArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageEditedByHandler OnMessageEditedBy;    
    public delegate void OnMessageEditedByHandler (SktMessage sender, OnMessageEditedByArgs e);
    
    internal void OnMessageEditedByInNewThread(object o)
    {
        OnMessageEditedByArgs e = (OnMessageEditedByArgs)o;
        OnMessageEditedBy(e.sender, e);
    }
    
    internal void FireOnMessageEditedBy(SktMessage sender, String value)
    {
        if (OnMessageEditedBy == null) return; // Event not assigned    
        OnMessageEditedByArgs args = new OnMessageEditedByArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageEditedByInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageEditedBy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageEditTimestampArgs : EventArgs
    {
        public SktMessage sender;
        public DateTime value;
        public OnMessageEditTimestampArgs(SktMessage sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageEditTimestampHandler OnMessageEditTimestamp;    
    public delegate void OnMessageEditTimestampHandler (SktMessage sender, OnMessageEditTimestampArgs e);
    
    internal void OnMessageEditTimestampInNewThread(object o)
    {
        OnMessageEditTimestampArgs e = (OnMessageEditTimestampArgs)o;
        OnMessageEditTimestamp(e.sender, e);
    }
    
    internal void FireOnMessageEditTimestamp(SktMessage sender, DateTime value)
    {
        if (OnMessageEditTimestamp == null) return; // Event not assigned    
        OnMessageEditTimestampArgs args = new OnMessageEditTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageEditTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageEditTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageParamKeyArgs : EventArgs
    {
        public SktMessage sender;
        public uint value;
        public OnMessageParamKeyArgs(SktMessage sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageParamKeyHandler OnMessageParamKey;    
    public delegate void OnMessageParamKeyHandler (SktMessage sender, OnMessageParamKeyArgs e);
    
    internal void OnMessageParamKeyInNewThread(object o)
    {
        OnMessageParamKeyArgs e = (OnMessageParamKeyArgs)o;
        OnMessageParamKey(e.sender, e);
    }
    
    internal void FireOnMessageParamKey(SktMessage sender, uint value)
    {
        if (OnMessageParamKey == null) return; // Event not assigned    
        OnMessageParamKeyArgs args = new OnMessageParamKeyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageParamKeyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageParamKey, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageParamValueArgs : EventArgs
    {
        public SktMessage sender;
        public uint value;
        public OnMessageParamValueArgs(SktMessage sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageParamValueHandler OnMessageParamValue;    
    public delegate void OnMessageParamValueHandler (SktMessage sender, OnMessageParamValueArgs e);
    
    internal void OnMessageParamValueInNewThread(object o)
    {
        OnMessageParamValueArgs e = (OnMessageParamValueArgs)o;
        OnMessageParamValue(e.sender, e);
    }
    
    internal void FireOnMessageParamValue(SktMessage sender, uint value)
    {
        if (OnMessageParamValue == null) return; // Event not assigned    
        OnMessageParamValueArgs args = new OnMessageParamValueArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageParamValueInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageParamValue, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageBodyXmlArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageBodyXmlArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageBodyXmlHandler OnMessageBodyXml;    
    public delegate void OnMessageBodyXmlHandler (SktMessage sender, OnMessageBodyXmlArgs e);
    
    internal void OnMessageBodyXmlInNewThread(object o)
    {
        OnMessageBodyXmlArgs e = (OnMessageBodyXmlArgs)o;
        OnMessageBodyXml(e.sender, e);
    }
    
    internal void FireOnMessageBodyXml(SktMessage sender, String value)
    {
        if (OnMessageBodyXml == null) return; // Event not assigned    
        OnMessageBodyXmlArgs args = new OnMessageBodyXmlArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageBodyXmlInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageBodyXml, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageIdentitiesArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageIdentitiesArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageIdentitiesHandler OnMessageIdentities;    
    public delegate void OnMessageIdentitiesHandler (SktMessage sender, OnMessageIdentitiesArgs e);
    
    internal void OnMessageIdentitiesInNewThread(object o)
    {
        OnMessageIdentitiesArgs e = (OnMessageIdentitiesArgs)o;
        OnMessageIdentities(e.sender, e);
    }
    
    internal void FireOnMessageIdentities(SktMessage sender, String value)
    {
        if (OnMessageIdentities == null) return; // Event not assigned    
        OnMessageIdentitiesArgs args = new OnMessageIdentitiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageIdentitiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageIdentities, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageReasonArgs : EventArgs
    {
        public SktMessage sender;
        public String value;
        public OnMessageReasonArgs(SktMessage sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageReasonHandler OnMessageReason;    
    public delegate void OnMessageReasonHandler (SktMessage sender, OnMessageReasonArgs e);
    
    internal void OnMessageReasonInNewThread(object o)
    {
        OnMessageReasonArgs e = (OnMessageReasonArgs)o;
        OnMessageReason(e.sender, e);
    }
    
    internal void FireOnMessageReason(SktMessage sender, String value)
    {
        if (OnMessageReason == null) return; // Event not assigned    
        OnMessageReasonArgs args = new OnMessageReasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageReasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageReason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageLeavereasonArgs : EventArgs
    {
        public SktMessage sender;
        public SktSkype.LEAVE_REASON value;
        public OnMessageLeavereasonArgs(SktMessage sender, SktSkype.LEAVE_REASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageLeavereasonHandler OnMessageLeavereason;    
    public delegate void OnMessageLeavereasonHandler (SktMessage sender, OnMessageLeavereasonArgs e);
    
    internal void OnMessageLeavereasonInNewThread(object o)
    {
        OnMessageLeavereasonArgs e = (OnMessageLeavereasonArgs)o;
        OnMessageLeavereason(e.sender, e);
    }
    
    internal void FireOnMessageLeavereason(SktMessage sender, SktSkype.LEAVE_REASON value)
    {
        if (OnMessageLeavereason == null) return; // Event not assigned    
        OnMessageLeavereasonArgs args = new OnMessageLeavereasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageLeavereasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageLeavereason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnMessageParticipantCountArgs : EventArgs
    {
        public SktMessage sender;
        public uint value;
        public OnMessageParticipantCountArgs(SktMessage sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnMessageParticipantCountHandler OnMessageParticipantCount;    
    public delegate void OnMessageParticipantCountHandler (SktMessage sender, OnMessageParticipantCountArgs e);
    
    internal void OnMessageParticipantCountInNewThread(object o)
    {
        OnMessageParticipantCountArgs e = (OnMessageParticipantCountArgs)o;
        OnMessageParticipantCount(e.sender, e);
    }
    
    internal void FireOnMessageParticipantCount(SktMessage sender, uint value)
    {
        if (OnMessageParticipantCount == null) return; // Event not assigned    
        OnMessageParticipantCountArgs args = new OnMessageParticipantCountArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnMessageParticipantCountInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnMessageParticipantCount, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailTypeArgs : EventArgs
    {
        public SktVoicemail sender;
        public SktVoicemail.TYPE value;
        public OnVoicemailTypeArgs(SktVoicemail sender, SktVoicemail.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailTypeHandler OnVoicemailType;    
    public delegate void OnVoicemailTypeHandler (SktVoicemail sender, OnVoicemailTypeArgs e);
    
    internal void OnVoicemailTypeInNewThread(object o)
    {
        OnVoicemailTypeArgs e = (OnVoicemailTypeArgs)o;
        OnVoicemailType(e.sender, e);
    }
    
    internal void FireOnVoicemailType(SktVoicemail sender, SktVoicemail.TYPE value)
    {
        if (OnVoicemailType == null) return; // Event not assigned    
        OnVoicemailTypeArgs args = new OnVoicemailTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailPartnerHandleArgs : EventArgs
    {
        public SktVoicemail sender;
        public String value;
        public OnVoicemailPartnerHandleArgs(SktVoicemail sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailPartnerHandleHandler OnVoicemailPartnerHandle;    
    public delegate void OnVoicemailPartnerHandleHandler (SktVoicemail sender, OnVoicemailPartnerHandleArgs e);
    
    internal void OnVoicemailPartnerHandleInNewThread(object o)
    {
        OnVoicemailPartnerHandleArgs e = (OnVoicemailPartnerHandleArgs)o;
        OnVoicemailPartnerHandle(e.sender, e);
    }
    
    internal void FireOnVoicemailPartnerHandle(SktVoicemail sender, String value)
    {
        if (OnVoicemailPartnerHandle == null) return; // Event not assigned    
        OnVoicemailPartnerHandleArgs args = new OnVoicemailPartnerHandleArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailPartnerHandleInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailPartnerHandle, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailPartnerDispnameArgs : EventArgs
    {
        public SktVoicemail sender;
        public String value;
        public OnVoicemailPartnerDispnameArgs(SktVoicemail sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailPartnerDispnameHandler OnVoicemailPartnerDispname;    
    public delegate void OnVoicemailPartnerDispnameHandler (SktVoicemail sender, OnVoicemailPartnerDispnameArgs e);
    
    internal void OnVoicemailPartnerDispnameInNewThread(object o)
    {
        OnVoicemailPartnerDispnameArgs e = (OnVoicemailPartnerDispnameArgs)o;
        OnVoicemailPartnerDispname(e.sender, e);
    }
    
    internal void FireOnVoicemailPartnerDispname(SktVoicemail sender, String value)
    {
        if (OnVoicemailPartnerDispname == null) return; // Event not assigned    
        OnVoicemailPartnerDispnameArgs args = new OnVoicemailPartnerDispnameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailPartnerDispnameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailPartnerDispname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailStatusArgs : EventArgs
    {
        public SktVoicemail sender;
        public SktVoicemail.STATUS value;
        public OnVoicemailStatusArgs(SktVoicemail sender, SktVoicemail.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailStatusHandler OnVoicemailStatus;    
    public delegate void OnVoicemailStatusHandler (SktVoicemail sender, OnVoicemailStatusArgs e);
    
    internal void OnVoicemailStatusInNewThread(object o)
    {
        OnVoicemailStatusArgs e = (OnVoicemailStatusArgs)o;
        OnVoicemailStatus(e.sender, e);
    }
    
    internal void FireOnVoicemailStatus(SktVoicemail sender, SktVoicemail.STATUS value)
    {
        if (OnVoicemailStatus == null) return; // Event not assigned    
        OnVoicemailStatusArgs args = new OnVoicemailStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailFailurereasonArgs : EventArgs
    {
        public SktVoicemail sender;
        public SktVoicemail.FAILUREREASON value;
        public OnVoicemailFailurereasonArgs(SktVoicemail sender, SktVoicemail.FAILUREREASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailFailurereasonHandler OnVoicemailFailurereason;    
    public delegate void OnVoicemailFailurereasonHandler (SktVoicemail sender, OnVoicemailFailurereasonArgs e);
    
    internal void OnVoicemailFailurereasonInNewThread(object o)
    {
        OnVoicemailFailurereasonArgs e = (OnVoicemailFailurereasonArgs)o;
        OnVoicemailFailurereason(e.sender, e);
    }
    
    internal void FireOnVoicemailFailurereason(SktVoicemail sender, SktVoicemail.FAILUREREASON value)
    {
        if (OnVoicemailFailurereason == null) return; // Event not assigned    
        OnVoicemailFailurereasonArgs args = new OnVoicemailFailurereasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailFailurereasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailFailurereason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailSubjectArgs : EventArgs
    {
        public SktVoicemail sender;
        public String value;
        public OnVoicemailSubjectArgs(SktVoicemail sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailSubjectHandler OnVoicemailSubject;    
    public delegate void OnVoicemailSubjectHandler (SktVoicemail sender, OnVoicemailSubjectArgs e);
    
    internal void OnVoicemailSubjectInNewThread(object o)
    {
        OnVoicemailSubjectArgs e = (OnVoicemailSubjectArgs)o;
        OnVoicemailSubject(e.sender, e);
    }
    
    internal void FireOnVoicemailSubject(SktVoicemail sender, String value)
    {
        if (OnVoicemailSubject == null) return; // Event not assigned    
        OnVoicemailSubjectArgs args = new OnVoicemailSubjectArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailSubjectInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailSubject, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailTimestampArgs : EventArgs
    {
        public SktVoicemail sender;
        public DateTime value;
        public OnVoicemailTimestampArgs(SktVoicemail sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailTimestampHandler OnVoicemailTimestamp;    
    public delegate void OnVoicemailTimestampHandler (SktVoicemail sender, OnVoicemailTimestampArgs e);
    
    internal void OnVoicemailTimestampInNewThread(object o)
    {
        OnVoicemailTimestampArgs e = (OnVoicemailTimestampArgs)o;
        OnVoicemailTimestamp(e.sender, e);
    }
    
    internal void FireOnVoicemailTimestamp(SktVoicemail sender, DateTime value)
    {
        if (OnVoicemailTimestamp == null) return; // Event not assigned    
        OnVoicemailTimestampArgs args = new OnVoicemailTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailDurationArgs : EventArgs
    {
        public SktVoicemail sender;
        public uint value;
        public OnVoicemailDurationArgs(SktVoicemail sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailDurationHandler OnVoicemailDuration;    
    public delegate void OnVoicemailDurationHandler (SktVoicemail sender, OnVoicemailDurationArgs e);
    
    internal void OnVoicemailDurationInNewThread(object o)
    {
        OnVoicemailDurationArgs e = (OnVoicemailDurationArgs)o;
        OnVoicemailDuration(e.sender, e);
    }
    
    internal void FireOnVoicemailDuration(SktVoicemail sender, uint value)
    {
        if (OnVoicemailDuration == null) return; // Event not assigned    
        OnVoicemailDurationArgs args = new OnVoicemailDurationArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailDurationInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailDuration, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailAllowedDurationArgs : EventArgs
    {
        public SktVoicemail sender;
        public uint value;
        public OnVoicemailAllowedDurationArgs(SktVoicemail sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailAllowedDurationHandler OnVoicemailAllowedDuration;    
    public delegate void OnVoicemailAllowedDurationHandler (SktVoicemail sender, OnVoicemailAllowedDurationArgs e);
    
    internal void OnVoicemailAllowedDurationInNewThread(object o)
    {
        OnVoicemailAllowedDurationArgs e = (OnVoicemailAllowedDurationArgs)o;
        OnVoicemailAllowedDuration(e.sender, e);
    }
    
    internal void FireOnVoicemailAllowedDuration(SktVoicemail sender, uint value)
    {
        if (OnVoicemailAllowedDuration == null) return; // Event not assigned    
        OnVoicemailAllowedDurationArgs args = new OnVoicemailAllowedDurationArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailAllowedDurationInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailAllowedDuration, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailPlaybackProgressArgs : EventArgs
    {
        public SktVoicemail sender;
        public uint value;
        public OnVoicemailPlaybackProgressArgs(SktVoicemail sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailPlaybackProgressHandler OnVoicemailPlaybackProgress;    
    public delegate void OnVoicemailPlaybackProgressHandler (SktVoicemail sender, OnVoicemailPlaybackProgressArgs e);
    
    internal void OnVoicemailPlaybackProgressInNewThread(object o)
    {
        OnVoicemailPlaybackProgressArgs e = (OnVoicemailPlaybackProgressArgs)o;
        OnVoicemailPlaybackProgress(e.sender, e);
    }
    
    internal void FireOnVoicemailPlaybackProgress(SktVoicemail sender, uint value)
    {
        if (OnVoicemailPlaybackProgress == null) return; // Event not assigned    
        OnVoicemailPlaybackProgressArgs args = new OnVoicemailPlaybackProgressArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailPlaybackProgressInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailPlaybackProgress, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailConvoIdArgs : EventArgs
    {
        public SktVoicemail sender;
        public SktConversation value;
        public OnVoicemailConvoIdArgs(SktVoicemail sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailConvoIdHandler OnVoicemailConvoId;    
    public delegate void OnVoicemailConvoIdHandler (SktVoicemail sender, OnVoicemailConvoIdArgs e);
    
    internal void OnVoicemailConvoIdInNewThread(object o)
    {
        OnVoicemailConvoIdArgs e = (OnVoicemailConvoIdArgs)o;
        OnVoicemailConvoId(e.sender, e);
    }
    
    internal void FireOnVoicemailConvoId(SktVoicemail sender, SktConversation value)
    {
        if (OnVoicemailConvoId == null) return; // Event not assigned    
        OnVoicemailConvoIdArgs args = new OnVoicemailConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnVoicemailChatmsgGuidArgs : EventArgs
    {
        public SktVoicemail sender;
        public byte[] value;
        public OnVoicemailChatmsgGuidArgs(SktVoicemail sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnVoicemailChatmsgGuidHandler OnVoicemailChatmsgGuid;    
    public delegate void OnVoicemailChatmsgGuidHandler (SktVoicemail sender, OnVoicemailChatmsgGuidArgs e);
    
    internal void OnVoicemailChatmsgGuidInNewThread(object o)
    {
        OnVoicemailChatmsgGuidArgs e = (OnVoicemailChatmsgGuidArgs)o;
        OnVoicemailChatmsgGuid(e.sender, e);
    }
    
    internal void FireOnVoicemailChatmsgGuid(SktVoicemail sender, byte[] value)
    {
        if (OnVoicemailChatmsgGuid == null) return; // Event not assigned    
        OnVoicemailChatmsgGuidArgs args = new OnVoicemailChatmsgGuidArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnVoicemailChatmsgGuidInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnVoicemailChatmsgGuid, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferTypeArgs : EventArgs
    {
        public SktTransfer sender;
        public SktTransfer.TYPE value;
        public OnTransferTypeArgs(SktTransfer sender, SktTransfer.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferTypeHandler OnTransferType;    
    public delegate void OnTransferTypeHandler (SktTransfer sender, OnTransferTypeArgs e);
    
    internal void OnTransferTypeInNewThread(object o)
    {
        OnTransferTypeArgs e = (OnTransferTypeArgs)o;
        OnTransferType(e.sender, e);
    }
    
    internal void FireOnTransferType(SktTransfer sender, SktTransfer.TYPE value)
    {
        if (OnTransferType == null) return; // Event not assigned    
        OnTransferTypeArgs args = new OnTransferTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferPartnerHandleArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferPartnerHandleArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferPartnerHandleHandler OnTransferPartnerHandle;    
    public delegate void OnTransferPartnerHandleHandler (SktTransfer sender, OnTransferPartnerHandleArgs e);
    
    internal void OnTransferPartnerHandleInNewThread(object o)
    {
        OnTransferPartnerHandleArgs e = (OnTransferPartnerHandleArgs)o;
        OnTransferPartnerHandle(e.sender, e);
    }
    
    internal void FireOnTransferPartnerHandle(SktTransfer sender, String value)
    {
        if (OnTransferPartnerHandle == null) return; // Event not assigned    
        OnTransferPartnerHandleArgs args = new OnTransferPartnerHandleArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferPartnerHandleInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferPartnerHandle, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferPartnerDispnameArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferPartnerDispnameArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferPartnerDispnameHandler OnTransferPartnerDispname;    
    public delegate void OnTransferPartnerDispnameHandler (SktTransfer sender, OnTransferPartnerDispnameArgs e);
    
    internal void OnTransferPartnerDispnameInNewThread(object o)
    {
        OnTransferPartnerDispnameArgs e = (OnTransferPartnerDispnameArgs)o;
        OnTransferPartnerDispname(e.sender, e);
    }
    
    internal void FireOnTransferPartnerDispname(SktTransfer sender, String value)
    {
        if (OnTransferPartnerDispname == null) return; // Event not assigned    
        OnTransferPartnerDispnameArgs args = new OnTransferPartnerDispnameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferPartnerDispnameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferPartnerDispname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferStatusArgs : EventArgs
    {
        public SktTransfer sender;
        public SktTransfer.STATUS value;
        public OnTransferStatusArgs(SktTransfer sender, SktTransfer.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferStatusHandler OnTransferStatus;    
    public delegate void OnTransferStatusHandler (SktTransfer sender, OnTransferStatusArgs e);
    
    internal void OnTransferStatusInNewThread(object o)
    {
        OnTransferStatusArgs e = (OnTransferStatusArgs)o;
        OnTransferStatus(e.sender, e);
    }
    
    internal void FireOnTransferStatus(SktTransfer sender, SktTransfer.STATUS value)
    {
        if (OnTransferStatus == null) return; // Event not assigned    
        OnTransferStatusArgs args = new OnTransferStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferFailurereasonArgs : EventArgs
    {
        public SktTransfer sender;
        public SktTransfer.FAILUREREASON value;
        public OnTransferFailurereasonArgs(SktTransfer sender, SktTransfer.FAILUREREASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferFailurereasonHandler OnTransferFailurereason;    
    public delegate void OnTransferFailurereasonHandler (SktTransfer sender, OnTransferFailurereasonArgs e);
    
    internal void OnTransferFailurereasonInNewThread(object o)
    {
        OnTransferFailurereasonArgs e = (OnTransferFailurereasonArgs)o;
        OnTransferFailurereason(e.sender, e);
    }
    
    internal void FireOnTransferFailurereason(SktTransfer sender, SktTransfer.FAILUREREASON value)
    {
        if (OnTransferFailurereason == null) return; // Event not assigned    
        OnTransferFailurereasonArgs args = new OnTransferFailurereasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferFailurereasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferFailurereason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferStarttimeArgs : EventArgs
    {
        public SktTransfer sender;
        public DateTime value;
        public OnTransferStarttimeArgs(SktTransfer sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferStarttimeHandler OnTransferStarttime;    
    public delegate void OnTransferStarttimeHandler (SktTransfer sender, OnTransferStarttimeArgs e);
    
    internal void OnTransferStarttimeInNewThread(object o)
    {
        OnTransferStarttimeArgs e = (OnTransferStarttimeArgs)o;
        OnTransferStarttime(e.sender, e);
    }
    
    internal void FireOnTransferStarttime(SktTransfer sender, DateTime value)
    {
        if (OnTransferStarttime == null) return; // Event not assigned    
        OnTransferStarttimeArgs args = new OnTransferStarttimeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferStarttimeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferStarttime, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferFinishtimeArgs : EventArgs
    {
        public SktTransfer sender;
        public DateTime value;
        public OnTransferFinishtimeArgs(SktTransfer sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferFinishtimeHandler OnTransferFinishtime;    
    public delegate void OnTransferFinishtimeHandler (SktTransfer sender, OnTransferFinishtimeArgs e);
    
    internal void OnTransferFinishtimeInNewThread(object o)
    {
        OnTransferFinishtimeArgs e = (OnTransferFinishtimeArgs)o;
        OnTransferFinishtime(e.sender, e);
    }
    
    internal void FireOnTransferFinishtime(SktTransfer sender, DateTime value)
    {
        if (OnTransferFinishtime == null) return; // Event not assigned    
        OnTransferFinishtimeArgs args = new OnTransferFinishtimeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferFinishtimeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferFinishtime, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferFilepathArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferFilepathArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferFilepathHandler OnTransferFilepath;    
    public delegate void OnTransferFilepathHandler (SktTransfer sender, OnTransferFilepathArgs e);
    
    internal void OnTransferFilepathInNewThread(object o)
    {
        OnTransferFilepathArgs e = (OnTransferFilepathArgs)o;
        OnTransferFilepath(e.sender, e);
    }
    
    internal void FireOnTransferFilepath(SktTransfer sender, String value)
    {
        if (OnTransferFilepath == null) return; // Event not assigned    
        OnTransferFilepathArgs args = new OnTransferFilepathArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferFilepathInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferFilepath, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferFilenameArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferFilenameArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferFilenameHandler OnTransferFilename;    
    public delegate void OnTransferFilenameHandler (SktTransfer sender, OnTransferFilenameArgs e);
    
    internal void OnTransferFilenameInNewThread(object o)
    {
        OnTransferFilenameArgs e = (OnTransferFilenameArgs)o;
        OnTransferFilename(e.sender, e);
    }
    
    internal void FireOnTransferFilename(SktTransfer sender, String value)
    {
        if (OnTransferFilename == null) return; // Event not assigned    
        OnTransferFilenameArgs args = new OnTransferFilenameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferFilenameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferFilename, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferFilesizeArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferFilesizeArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferFilesizeHandler OnTransferFilesize;    
    public delegate void OnTransferFilesizeHandler (SktTransfer sender, OnTransferFilesizeArgs e);
    
    internal void OnTransferFilesizeInNewThread(object o)
    {
        OnTransferFilesizeArgs e = (OnTransferFilesizeArgs)o;
        OnTransferFilesize(e.sender, e);
    }
    
    internal void FireOnTransferFilesize(SktTransfer sender, String value)
    {
        if (OnTransferFilesize == null) return; // Event not assigned    
        OnTransferFilesizeArgs args = new OnTransferFilesizeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferFilesizeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferFilesize, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferBytestransferredArgs : EventArgs
    {
        public SktTransfer sender;
        public String value;
        public OnTransferBytestransferredArgs(SktTransfer sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferBytestransferredHandler OnTransferBytestransferred;    
    public delegate void OnTransferBytestransferredHandler (SktTransfer sender, OnTransferBytestransferredArgs e);
    
    internal void OnTransferBytestransferredInNewThread(object o)
    {
        OnTransferBytestransferredArgs e = (OnTransferBytestransferredArgs)o;
        OnTransferBytestransferred(e.sender, e);
    }
    
    internal void FireOnTransferBytestransferred(SktTransfer sender, String value)
    {
        if (OnTransferBytestransferred == null) return; // Event not assigned    
        OnTransferBytestransferredArgs args = new OnTransferBytestransferredArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferBytestransferredInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferBytestransferred, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferBytespersecondArgs : EventArgs
    {
        public SktTransfer sender;
        public uint value;
        public OnTransferBytespersecondArgs(SktTransfer sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferBytespersecondHandler OnTransferBytespersecond;    
    public delegate void OnTransferBytespersecondHandler (SktTransfer sender, OnTransferBytespersecondArgs e);
    
    internal void OnTransferBytespersecondInNewThread(object o)
    {
        OnTransferBytespersecondArgs e = (OnTransferBytespersecondArgs)o;
        OnTransferBytespersecond(e.sender, e);
    }
    
    internal void FireOnTransferBytespersecond(SktTransfer sender, uint value)
    {
        if (OnTransferBytespersecond == null) return; // Event not assigned    
        OnTransferBytespersecondArgs args = new OnTransferBytespersecondArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferBytespersecondInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferBytespersecond, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferChatmsgGuidArgs : EventArgs
    {
        public SktTransfer sender;
        public byte[] value;
        public OnTransferChatmsgGuidArgs(SktTransfer sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferChatmsgGuidHandler OnTransferChatmsgGuid;    
    public delegate void OnTransferChatmsgGuidHandler (SktTransfer sender, OnTransferChatmsgGuidArgs e);
    
    internal void OnTransferChatmsgGuidInNewThread(object o)
    {
        OnTransferChatmsgGuidArgs e = (OnTransferChatmsgGuidArgs)o;
        OnTransferChatmsgGuid(e.sender, e);
    }
    
    internal void FireOnTransferChatmsgGuid(SktTransfer sender, byte[] value)
    {
        if (OnTransferChatmsgGuid == null) return; // Event not assigned    
        OnTransferChatmsgGuidArgs args = new OnTransferChatmsgGuidArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferChatmsgGuidInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferChatmsgGuid, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferChatmsgIndexArgs : EventArgs
    {
        public SktTransfer sender;
        public uint value;
        public OnTransferChatmsgIndexArgs(SktTransfer sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferChatmsgIndexHandler OnTransferChatmsgIndex;    
    public delegate void OnTransferChatmsgIndexHandler (SktTransfer sender, OnTransferChatmsgIndexArgs e);
    
    internal void OnTransferChatmsgIndexInNewThread(object o)
    {
        OnTransferChatmsgIndexArgs e = (OnTransferChatmsgIndexArgs)o;
        OnTransferChatmsgIndex(e.sender, e);
    }
    
    internal void FireOnTransferChatmsgIndex(SktTransfer sender, uint value)
    {
        if (OnTransferChatmsgIndex == null) return; // Event not assigned    
        OnTransferChatmsgIndexArgs args = new OnTransferChatmsgIndexArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferChatmsgIndexInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferChatmsgIndex, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnTransferConvoIdArgs : EventArgs
    {
        public SktTransfer sender;
        public SktConversation value;
        public OnTransferConvoIdArgs(SktTransfer sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnTransferConvoIdHandler OnTransferConvoId;    
    public delegate void OnTransferConvoIdHandler (SktTransfer sender, OnTransferConvoIdArgs e);
    
    internal void OnTransferConvoIdInNewThread(object o)
    {
        OnTransferConvoIdArgs e = (OnTransferConvoIdArgs)o;
        OnTransferConvoId(e.sender, e);
    }
    
    internal void FireOnTransferConvoId(SktTransfer sender, SktConversation value)
    {
        if (OnTransferConvoId == null) return; // Event not assigned    
        OnTransferConvoIdArgs args = new OnTransferConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnTransferConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnTransferConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactTypeArgs : EventArgs
    {
        public SktContact sender;
        public SktContact.TYPE value;
        public OnContactTypeArgs(SktContact sender, SktContact.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactTypeHandler OnContactType;    
    public delegate void OnContactTypeHandler (SktContact sender, OnContactTypeArgs e);
    
    internal void OnContactTypeInNewThread(object o)
    {
        OnContactTypeArgs e = (OnContactTypeArgs)o;
        OnContactType(e.sender, e);
    }
    
    internal void FireOnContactType(SktContact sender, SktContact.TYPE value)
    {
        if (OnContactType == null) return; // Event not assigned    
        OnContactTypeArgs args = new OnContactTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactSkypenameArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactSkypenameArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactSkypenameHandler OnContactSkypename;    
    public delegate void OnContactSkypenameHandler (SktContact sender, OnContactSkypenameArgs e);
    
    internal void OnContactSkypenameInNewThread(object o)
    {
        OnContactSkypenameArgs e = (OnContactSkypenameArgs)o;
        OnContactSkypename(e.sender, e);
    }
    
    internal void FireOnContactSkypename(SktContact sender, String value)
    {
        if (OnContactSkypename == null) return; // Event not assigned    
        OnContactSkypenameArgs args = new OnContactSkypenameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactSkypenameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactSkypename, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactPstnnumberArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactPstnnumberArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactPstnnumberHandler OnContactPstnnumber;    
    public delegate void OnContactPstnnumberHandler (SktContact sender, OnContactPstnnumberArgs e);
    
    internal void OnContactPstnnumberInNewThread(object o)
    {
        OnContactPstnnumberArgs e = (OnContactPstnnumberArgs)o;
        OnContactPstnnumber(e.sender, e);
    }
    
    internal void FireOnContactPstnnumber(SktContact sender, String value)
    {
        if (OnContactPstnnumber == null) return; // Event not assigned    
        OnContactPstnnumberArgs args = new OnContactPstnnumberArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactPstnnumberInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactPstnnumber, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactFullnameArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactFullnameArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactFullnameHandler OnContactFullname;    
    public delegate void OnContactFullnameHandler (SktContact sender, OnContactFullnameArgs e);
    
    internal void OnContactFullnameInNewThread(object o)
    {
        OnContactFullnameArgs e = (OnContactFullnameArgs)o;
        OnContactFullname(e.sender, e);
    }
    
    internal void FireOnContactFullname(SktContact sender, String value)
    {
        if (OnContactFullname == null) return; // Event not assigned    
        OnContactFullnameArgs args = new OnContactFullnameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactFullnameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactFullname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactBirthdayArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactBirthdayArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactBirthdayHandler OnContactBirthday;    
    public delegate void OnContactBirthdayHandler (SktContact sender, OnContactBirthdayArgs e);
    
    internal void OnContactBirthdayInNewThread(object o)
    {
        OnContactBirthdayArgs e = (OnContactBirthdayArgs)o;
        OnContactBirthday(e.sender, e);
    }
    
    internal void FireOnContactBirthday(SktContact sender, uint value)
    {
        if (OnContactBirthday == null) return; // Event not assigned    
        OnContactBirthdayArgs args = new OnContactBirthdayArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactBirthdayInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactBirthday, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGenderArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactGenderArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGenderHandler OnContactGender;    
    public delegate void OnContactGenderHandler (SktContact sender, OnContactGenderArgs e);
    
    internal void OnContactGenderInNewThread(object o)
    {
        OnContactGenderArgs e = (OnContactGenderArgs)o;
        OnContactGender(e.sender, e);
    }
    
    internal void FireOnContactGender(SktContact sender, uint value)
    {
        if (OnContactGender == null) return; // Event not assigned    
        OnContactGenderArgs args = new OnContactGenderArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGenderInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGender, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactLanguagesArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactLanguagesArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactLanguagesHandler OnContactLanguages;    
    public delegate void OnContactLanguagesHandler (SktContact sender, OnContactLanguagesArgs e);
    
    internal void OnContactLanguagesInNewThread(object o)
    {
        OnContactLanguagesArgs e = (OnContactLanguagesArgs)o;
        OnContactLanguages(e.sender, e);
    }
    
    internal void FireOnContactLanguages(SktContact sender, String value)
    {
        if (OnContactLanguages == null) return; // Event not assigned    
        OnContactLanguagesArgs args = new OnContactLanguagesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactLanguagesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactLanguages, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactCountryArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactCountryArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactCountryHandler OnContactCountry;    
    public delegate void OnContactCountryHandler (SktContact sender, OnContactCountryArgs e);
    
    internal void OnContactCountryInNewThread(object o)
    {
        OnContactCountryArgs e = (OnContactCountryArgs)o;
        OnContactCountry(e.sender, e);
    }
    
    internal void FireOnContactCountry(SktContact sender, String value)
    {
        if (OnContactCountry == null) return; // Event not assigned    
        OnContactCountryArgs args = new OnContactCountryArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactCountryInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactCountry, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactProvinceArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactProvinceArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactProvinceHandler OnContactProvince;    
    public delegate void OnContactProvinceHandler (SktContact sender, OnContactProvinceArgs e);
    
    internal void OnContactProvinceInNewThread(object o)
    {
        OnContactProvinceArgs e = (OnContactProvinceArgs)o;
        OnContactProvince(e.sender, e);
    }
    
    internal void FireOnContactProvince(SktContact sender, String value)
    {
        if (OnContactProvince == null) return; // Event not assigned    
        OnContactProvinceArgs args = new OnContactProvinceArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactProvinceInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactProvince, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactCityArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactCityArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactCityHandler OnContactCity;    
    public delegate void OnContactCityHandler (SktContact sender, OnContactCityArgs e);
    
    internal void OnContactCityInNewThread(object o)
    {
        OnContactCityArgs e = (OnContactCityArgs)o;
        OnContactCity(e.sender, e);
    }
    
    internal void FireOnContactCity(SktContact sender, String value)
    {
        if (OnContactCity == null) return; // Event not assigned    
        OnContactCityArgs args = new OnContactCityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactCityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactCity, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactPhoneHomeArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactPhoneHomeArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactPhoneHomeHandler OnContactPhoneHome;    
    public delegate void OnContactPhoneHomeHandler (SktContact sender, OnContactPhoneHomeArgs e);
    
    internal void OnContactPhoneHomeInNewThread(object o)
    {
        OnContactPhoneHomeArgs e = (OnContactPhoneHomeArgs)o;
        OnContactPhoneHome(e.sender, e);
    }
    
    internal void FireOnContactPhoneHome(SktContact sender, String value)
    {
        if (OnContactPhoneHome == null) return; // Event not assigned    
        OnContactPhoneHomeArgs args = new OnContactPhoneHomeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactPhoneHomeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactPhoneHome, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactPhoneOfficeArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactPhoneOfficeArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactPhoneOfficeHandler OnContactPhoneOffice;    
    public delegate void OnContactPhoneOfficeHandler (SktContact sender, OnContactPhoneOfficeArgs e);
    
    internal void OnContactPhoneOfficeInNewThread(object o)
    {
        OnContactPhoneOfficeArgs e = (OnContactPhoneOfficeArgs)o;
        OnContactPhoneOffice(e.sender, e);
    }
    
    internal void FireOnContactPhoneOffice(SktContact sender, String value)
    {
        if (OnContactPhoneOffice == null) return; // Event not assigned    
        OnContactPhoneOfficeArgs args = new OnContactPhoneOfficeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactPhoneOfficeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactPhoneOffice, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactPhoneMobileArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactPhoneMobileArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactPhoneMobileHandler OnContactPhoneMobile;    
    public delegate void OnContactPhoneMobileHandler (SktContact sender, OnContactPhoneMobileArgs e);
    
    internal void OnContactPhoneMobileInNewThread(object o)
    {
        OnContactPhoneMobileArgs e = (OnContactPhoneMobileArgs)o;
        OnContactPhoneMobile(e.sender, e);
    }
    
    internal void FireOnContactPhoneMobile(SktContact sender, String value)
    {
        if (OnContactPhoneMobile == null) return; // Event not assigned    
        OnContactPhoneMobileArgs args = new OnContactPhoneMobileArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactPhoneMobileInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactPhoneMobile, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactEmailsArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactEmailsArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactEmailsHandler OnContactEmails;    
    public delegate void OnContactEmailsHandler (SktContact sender, OnContactEmailsArgs e);
    
    internal void OnContactEmailsInNewThread(object o)
    {
        OnContactEmailsArgs e = (OnContactEmailsArgs)o;
        OnContactEmails(e.sender, e);
    }
    
    internal void FireOnContactEmails(SktContact sender, String value)
    {
        if (OnContactEmails == null) return; // Event not assigned    
        OnContactEmailsArgs args = new OnContactEmailsArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactEmailsInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactEmails, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactHomepageArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactHomepageArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactHomepageHandler OnContactHomepage;    
    public delegate void OnContactHomepageHandler (SktContact sender, OnContactHomepageArgs e);
    
    internal void OnContactHomepageInNewThread(object o)
    {
        OnContactHomepageArgs e = (OnContactHomepageArgs)o;
        OnContactHomepage(e.sender, e);
    }
    
    internal void FireOnContactHomepage(SktContact sender, String value)
    {
        if (OnContactHomepage == null) return; // Event not assigned    
        OnContactHomepageArgs args = new OnContactHomepageArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactHomepageInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactHomepage, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAboutArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAboutArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAboutHandler OnContactAbout;    
    public delegate void OnContactAboutHandler (SktContact sender, OnContactAboutArgs e);
    
    internal void OnContactAboutInNewThread(object o)
    {
        OnContactAboutArgs e = (OnContactAboutArgs)o;
        OnContactAbout(e.sender, e);
    }
    
    internal void FireOnContactAbout(SktContact sender, String value)
    {
        if (OnContactAbout == null) return; // Event not assigned    
        OnContactAboutArgs args = new OnContactAboutArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAboutInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAbout, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAvatarImageArgs : EventArgs
    {
        public SktContact sender;
        public byte[] value;
        public OnContactAvatarImageArgs(SktContact sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAvatarImageHandler OnContactAvatarImage;    
    public delegate void OnContactAvatarImageHandler (SktContact sender, OnContactAvatarImageArgs e);
    
    internal void OnContactAvatarImageInNewThread(object o)
    {
        OnContactAvatarImageArgs e = (OnContactAvatarImageArgs)o;
        OnContactAvatarImage(e.sender, e);
    }
    
    internal void FireOnContactAvatarImage(SktContact sender, byte[] value)
    {
        if (OnContactAvatarImage == null) return; // Event not assigned    
        OnContactAvatarImageArgs args = new OnContactAvatarImageArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAvatarImageInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAvatarImage, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactMoodTextArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactMoodTextArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactMoodTextHandler OnContactMoodText;    
    public delegate void OnContactMoodTextHandler (SktContact sender, OnContactMoodTextArgs e);
    
    internal void OnContactMoodTextInNewThread(object o)
    {
        OnContactMoodTextArgs e = (OnContactMoodTextArgs)o;
        OnContactMoodText(e.sender, e);
    }
    
    internal void FireOnContactMoodText(SktContact sender, String value)
    {
        if (OnContactMoodText == null) return; // Event not assigned    
        OnContactMoodTextArgs args = new OnContactMoodTextArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactMoodTextInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactMoodText, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactRichMoodTextArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactRichMoodTextArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactRichMoodTextHandler OnContactRichMoodText;    
    public delegate void OnContactRichMoodTextHandler (SktContact sender, OnContactRichMoodTextArgs e);
    
    internal void OnContactRichMoodTextInNewThread(object o)
    {
        OnContactRichMoodTextArgs e = (OnContactRichMoodTextArgs)o;
        OnContactRichMoodText(e.sender, e);
    }
    
    internal void FireOnContactRichMoodText(SktContact sender, String value)
    {
        if (OnContactRichMoodText == null) return; // Event not assigned    
        OnContactRichMoodTextArgs args = new OnContactRichMoodTextArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactRichMoodTextInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactRichMoodText, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactTimezoneArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactTimezoneArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactTimezoneHandler OnContactTimezone;    
    public delegate void OnContactTimezoneHandler (SktContact sender, OnContactTimezoneArgs e);
    
    internal void OnContactTimezoneInNewThread(object o)
    {
        OnContactTimezoneArgs e = (OnContactTimezoneArgs)o;
        OnContactTimezone(e.sender, e);
    }
    
    internal void FireOnContactTimezone(SktContact sender, uint value)
    {
        if (OnContactTimezone == null) return; // Event not assigned    
        OnContactTimezoneArgs args = new OnContactTimezoneArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactTimezoneInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactTimezone, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactCapabilitiesArgs : EventArgs
    {
        public SktContact sender;
        public byte[] value;
        public OnContactCapabilitiesArgs(SktContact sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactCapabilitiesHandler OnContactCapabilities;    
    public delegate void OnContactCapabilitiesHandler (SktContact sender, OnContactCapabilitiesArgs e);
    
    internal void OnContactCapabilitiesInNewThread(object o)
    {
        OnContactCapabilitiesArgs e = (OnContactCapabilitiesArgs)o;
        OnContactCapabilities(e.sender, e);
    }
    
    internal void FireOnContactCapabilities(SktContact sender, byte[] value)
    {
        if (OnContactCapabilities == null) return; // Event not assigned    
        OnContactCapabilitiesArgs args = new OnContactCapabilitiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactCapabilitiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactCapabilities, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactProfileTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactProfileTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactProfileTimestampHandler OnContactProfileTimestamp;    
    public delegate void OnContactProfileTimestampHandler (SktContact sender, OnContactProfileTimestampArgs e);
    
    internal void OnContactProfileTimestampInNewThread(object o)
    {
        OnContactProfileTimestampArgs e = (OnContactProfileTimestampArgs)o;
        OnContactProfileTimestamp(e.sender, e);
    }
    
    internal void FireOnContactProfileTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactProfileTimestamp == null) return; // Event not assigned    
        OnContactProfileTimestampArgs args = new OnContactProfileTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactProfileTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactProfileTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactNrofAuthedBuddiesArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactNrofAuthedBuddiesArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactNrofAuthedBuddiesHandler OnContactNrofAuthedBuddies;    
    public delegate void OnContactNrofAuthedBuddiesHandler (SktContact sender, OnContactNrofAuthedBuddiesArgs e);
    
    internal void OnContactNrofAuthedBuddiesInNewThread(object o)
    {
        OnContactNrofAuthedBuddiesArgs e = (OnContactNrofAuthedBuddiesArgs)o;
        OnContactNrofAuthedBuddies(e.sender, e);
    }
    
    internal void FireOnContactNrofAuthedBuddies(SktContact sender, uint value)
    {
        if (OnContactNrofAuthedBuddies == null) return; // Event not assigned    
        OnContactNrofAuthedBuddiesArgs args = new OnContactNrofAuthedBuddiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactNrofAuthedBuddiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactNrofAuthedBuddies, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactIpcountryArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactIpcountryArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactIpcountryHandler OnContactIpcountry;    
    public delegate void OnContactIpcountryHandler (SktContact sender, OnContactIpcountryArgs e);
    
    internal void OnContactIpcountryInNewThread(object o)
    {
        OnContactIpcountryArgs e = (OnContactIpcountryArgs)o;
        OnContactIpcountry(e.sender, e);
    }
    
    internal void FireOnContactIpcountry(SktContact sender, String value)
    {
        if (OnContactIpcountry == null) return; // Event not assigned    
        OnContactIpcountryArgs args = new OnContactIpcountryArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactIpcountryInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactIpcountry, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAvatarTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactAvatarTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAvatarTimestampHandler OnContactAvatarTimestamp;    
    public delegate void OnContactAvatarTimestampHandler (SktContact sender, OnContactAvatarTimestampArgs e);
    
    internal void OnContactAvatarTimestampInNewThread(object o)
    {
        OnContactAvatarTimestampArgs e = (OnContactAvatarTimestampArgs)o;
        OnContactAvatarTimestamp(e.sender, e);
    }
    
    internal void FireOnContactAvatarTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactAvatarTimestamp == null) return; // Event not assigned    
        OnContactAvatarTimestampArgs args = new OnContactAvatarTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAvatarTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAvatarTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactMoodTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactMoodTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactMoodTimestampHandler OnContactMoodTimestamp;    
    public delegate void OnContactMoodTimestampHandler (SktContact sender, OnContactMoodTimestampArgs e);
    
    internal void OnContactMoodTimestampInNewThread(object o)
    {
        OnContactMoodTimestampArgs e = (OnContactMoodTimestampArgs)o;
        OnContactMoodTimestamp(e.sender, e);
    }
    
    internal void FireOnContactMoodTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactMoodTimestamp == null) return; // Event not assigned    
        OnContactMoodTimestampArgs args = new OnContactMoodTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactMoodTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactMoodTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactReceivedAuthrequestArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactReceivedAuthrequestArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactReceivedAuthrequestHandler OnContactReceivedAuthrequest;    
    public delegate void OnContactReceivedAuthrequestHandler (SktContact sender, OnContactReceivedAuthrequestArgs e);
    
    internal void OnContactReceivedAuthrequestInNewThread(object o)
    {
        OnContactReceivedAuthrequestArgs e = (OnContactReceivedAuthrequestArgs)o;
        OnContactReceivedAuthrequest(e.sender, e);
    }
    
    internal void FireOnContactReceivedAuthrequest(SktContact sender, String value)
    {
        if (OnContactReceivedAuthrequest == null) return; // Event not assigned    
        OnContactReceivedAuthrequestArgs args = new OnContactReceivedAuthrequestArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactReceivedAuthrequestInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactReceivedAuthrequest, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAuthreqTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactAuthreqTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAuthreqTimestampHandler OnContactAuthreqTimestamp;    
    public delegate void OnContactAuthreqTimestampHandler (SktContact sender, OnContactAuthreqTimestampArgs e);
    
    internal void OnContactAuthreqTimestampInNewThread(object o)
    {
        OnContactAuthreqTimestampArgs e = (OnContactAuthreqTimestampArgs)o;
        OnContactAuthreqTimestamp(e.sender, e);
    }
    
    internal void FireOnContactAuthreqTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactAuthreqTimestamp == null) return; // Event not assigned    
        OnContactAuthreqTimestampArgs args = new OnContactAuthreqTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAuthreqTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAuthreqTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactLastonlineTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactLastonlineTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactLastonlineTimestampHandler OnContactLastonlineTimestamp;    
    public delegate void OnContactLastonlineTimestampHandler (SktContact sender, OnContactLastonlineTimestampArgs e);
    
    internal void OnContactLastonlineTimestampInNewThread(object o)
    {
        OnContactLastonlineTimestampArgs e = (OnContactLastonlineTimestampArgs)o;
        OnContactLastonlineTimestamp(e.sender, e);
    }
    
    internal void FireOnContactLastonlineTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactLastonlineTimestamp == null) return; // Event not assigned    
        OnContactLastonlineTimestampArgs args = new OnContactLastonlineTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactLastonlineTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactLastonlineTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAvailabilityArgs : EventArgs
    {
        public SktContact sender;
        public SktContact.AVAILABILITY value;
        public OnContactAvailabilityArgs(SktContact sender, SktContact.AVAILABILITY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAvailabilityHandler OnContactAvailability;    
    public delegate void OnContactAvailabilityHandler (SktContact sender, OnContactAvailabilityArgs e);
    
    internal void OnContactAvailabilityInNewThread(object o)
    {
        OnContactAvailabilityArgs e = (OnContactAvailabilityArgs)o;
        OnContactAvailability(e.sender, e);
    }
    
    internal void FireOnContactAvailability(SktContact sender, SktContact.AVAILABILITY value)
    {
        if (OnContactAvailability == null) return; // Event not assigned    
        OnContactAvailabilityArgs args = new OnContactAvailabilityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAvailabilityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAvailability, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactDisplaynameArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactDisplaynameArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactDisplaynameHandler OnContactDisplayname;    
    public delegate void OnContactDisplaynameHandler (SktContact sender, OnContactDisplaynameArgs e);
    
    internal void OnContactDisplaynameInNewThread(object o)
    {
        OnContactDisplaynameArgs e = (OnContactDisplaynameArgs)o;
        OnContactDisplayname(e.sender, e);
    }
    
    internal void FireOnContactDisplayname(SktContact sender, String value)
    {
        if (OnContactDisplayname == null) return; // Event not assigned    
        OnContactDisplaynameArgs args = new OnContactDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactRefreshingArgs : EventArgs
    {
        public SktContact sender;
        public Boolean value;
        public OnContactRefreshingArgs(SktContact sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactRefreshingHandler OnContactRefreshing;    
    public delegate void OnContactRefreshingHandler (SktContact sender, OnContactRefreshingArgs e);
    
    internal void OnContactRefreshingInNewThread(object o)
    {
        OnContactRefreshingArgs e = (OnContactRefreshingArgs)o;
        OnContactRefreshing(e.sender, e);
    }
    
    internal void FireOnContactRefreshing(SktContact sender, Boolean value)
    {
        if (OnContactRefreshing == null) return; // Event not assigned    
        OnContactRefreshingArgs args = new OnContactRefreshingArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactRefreshingInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactRefreshing, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGivenAuthlevelArgs : EventArgs
    {
        public SktContact sender;
        public SktContact.AUTHLEVEL value;
        public OnContactGivenAuthlevelArgs(SktContact sender, SktContact.AUTHLEVEL newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGivenAuthlevelHandler OnContactGivenAuthlevel;    
    public delegate void OnContactGivenAuthlevelHandler (SktContact sender, OnContactGivenAuthlevelArgs e);
    
    internal void OnContactGivenAuthlevelInNewThread(object o)
    {
        OnContactGivenAuthlevelArgs e = (OnContactGivenAuthlevelArgs)o;
        OnContactGivenAuthlevel(e.sender, e);
    }
    
    internal void FireOnContactGivenAuthlevel(SktContact sender, SktContact.AUTHLEVEL value)
    {
        if (OnContactGivenAuthlevel == null) return; // Event not assigned    
        OnContactGivenAuthlevelArgs args = new OnContactGivenAuthlevelArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGivenAuthlevelInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGivenAuthlevel, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactGivenDisplaynameArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactGivenDisplaynameArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactGivenDisplaynameHandler OnContactGivenDisplayname;    
    public delegate void OnContactGivenDisplaynameHandler (SktContact sender, OnContactGivenDisplaynameArgs e);
    
    internal void OnContactGivenDisplaynameInNewThread(object o)
    {
        OnContactGivenDisplaynameArgs e = (OnContactGivenDisplaynameArgs)o;
        OnContactGivenDisplayname(e.sender, e);
    }
    
    internal void FireOnContactGivenDisplayname(SktContact sender, String value)
    {
        if (OnContactGivenDisplayname == null) return; // Event not assigned    
        OnContactGivenDisplaynameArgs args = new OnContactGivenDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactGivenDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactGivenDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedCommentArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedCommentArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedCommentHandler OnContactAssignedComment;    
    public delegate void OnContactAssignedCommentHandler (SktContact sender, OnContactAssignedCommentArgs e);
    
    internal void OnContactAssignedCommentInNewThread(object o)
    {
        OnContactAssignedCommentArgs e = (OnContactAssignedCommentArgs)o;
        OnContactAssignedComment(e.sender, e);
    }
    
    internal void FireOnContactAssignedComment(SktContact sender, String value)
    {
        if (OnContactAssignedComment == null) return; // Event not assigned    
        OnContactAssignedCommentArgs args = new OnContactAssignedCommentArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedCommentInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedComment, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactLastusedTimestampArgs : EventArgs
    {
        public SktContact sender;
        public DateTime value;
        public OnContactLastusedTimestampArgs(SktContact sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactLastusedTimestampHandler OnContactLastusedTimestamp;    
    public delegate void OnContactLastusedTimestampHandler (SktContact sender, OnContactLastusedTimestampArgs e);
    
    internal void OnContactLastusedTimestampInNewThread(object o)
    {
        OnContactLastusedTimestampArgs e = (OnContactLastusedTimestampArgs)o;
        OnContactLastusedTimestamp(e.sender, e);
    }
    
    internal void FireOnContactLastusedTimestamp(SktContact sender, DateTime value)
    {
        if (OnContactLastusedTimestamp == null) return; // Event not assigned    
        OnContactLastusedTimestampArgs args = new OnContactLastusedTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactLastusedTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactLastusedTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAuthrequestCountArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactAuthrequestCountArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAuthrequestCountHandler OnContactAuthrequestCount;    
    public delegate void OnContactAuthrequestCountHandler (SktContact sender, OnContactAuthrequestCountArgs e);
    
    internal void OnContactAuthrequestCountInNewThread(object o)
    {
        OnContactAuthrequestCountArgs e = (OnContactAuthrequestCountArgs)o;
        OnContactAuthrequestCount(e.sender, e);
    }
    
    internal void FireOnContactAuthrequestCount(SktContact sender, uint value)
    {
        if (OnContactAuthrequestCount == null) return; // Event not assigned    
        OnContactAuthrequestCountArgs args = new OnContactAuthrequestCountArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAuthrequestCountInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAuthrequestCount, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone1Args : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone1Args(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone1Handler OnContactAssignedPhone1;    
    public delegate void OnContactAssignedPhone1Handler (SktContact sender, OnContactAssignedPhone1Args e);
    
    internal void OnContactAssignedPhone1InNewThread(object o)
    {
        OnContactAssignedPhone1Args e = (OnContactAssignedPhone1Args)o;
        OnContactAssignedPhone1(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone1(SktContact sender, String value)
    {
        if (OnContactAssignedPhone1 == null) return; // Event not assigned    
        OnContactAssignedPhone1Args args = new OnContactAssignedPhone1Args(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone1InNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone1, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone1LabelArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone1LabelArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone1LabelHandler OnContactAssignedPhone1Label;    
    public delegate void OnContactAssignedPhone1LabelHandler (SktContact sender, OnContactAssignedPhone1LabelArgs e);
    
    internal void OnContactAssignedPhone1LabelInNewThread(object o)
    {
        OnContactAssignedPhone1LabelArgs e = (OnContactAssignedPhone1LabelArgs)o;
        OnContactAssignedPhone1Label(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone1Label(SktContact sender, String value)
    {
        if (OnContactAssignedPhone1Label == null) return; // Event not assigned    
        OnContactAssignedPhone1LabelArgs args = new OnContactAssignedPhone1LabelArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone1LabelInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone1Label, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone2Args : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone2Args(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone2Handler OnContactAssignedPhone2;    
    public delegate void OnContactAssignedPhone2Handler (SktContact sender, OnContactAssignedPhone2Args e);
    
    internal void OnContactAssignedPhone2InNewThread(object o)
    {
        OnContactAssignedPhone2Args e = (OnContactAssignedPhone2Args)o;
        OnContactAssignedPhone2(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone2(SktContact sender, String value)
    {
        if (OnContactAssignedPhone2 == null) return; // Event not assigned    
        OnContactAssignedPhone2Args args = new OnContactAssignedPhone2Args(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone2InNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone2, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone2LabelArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone2LabelArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone2LabelHandler OnContactAssignedPhone2Label;    
    public delegate void OnContactAssignedPhone2LabelHandler (SktContact sender, OnContactAssignedPhone2LabelArgs e);
    
    internal void OnContactAssignedPhone2LabelInNewThread(object o)
    {
        OnContactAssignedPhone2LabelArgs e = (OnContactAssignedPhone2LabelArgs)o;
        OnContactAssignedPhone2Label(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone2Label(SktContact sender, String value)
    {
        if (OnContactAssignedPhone2Label == null) return; // Event not assigned    
        OnContactAssignedPhone2LabelArgs args = new OnContactAssignedPhone2LabelArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone2LabelInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone2Label, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone3Args : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone3Args(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone3Handler OnContactAssignedPhone3;    
    public delegate void OnContactAssignedPhone3Handler (SktContact sender, OnContactAssignedPhone3Args e);
    
    internal void OnContactAssignedPhone3InNewThread(object o)
    {
        OnContactAssignedPhone3Args e = (OnContactAssignedPhone3Args)o;
        OnContactAssignedPhone3(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone3(SktContact sender, String value)
    {
        if (OnContactAssignedPhone3 == null) return; // Event not assigned    
        OnContactAssignedPhone3Args args = new OnContactAssignedPhone3Args(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone3InNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone3, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactAssignedPhone3LabelArgs : EventArgs
    {
        public SktContact sender;
        public String value;
        public OnContactAssignedPhone3LabelArgs(SktContact sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactAssignedPhone3LabelHandler OnContactAssignedPhone3Label;    
    public delegate void OnContactAssignedPhone3LabelHandler (SktContact sender, OnContactAssignedPhone3LabelArgs e);
    
    internal void OnContactAssignedPhone3LabelInNewThread(object o)
    {
        OnContactAssignedPhone3LabelArgs e = (OnContactAssignedPhone3LabelArgs)o;
        OnContactAssignedPhone3Label(e.sender, e);
    }
    
    internal void FireOnContactAssignedPhone3Label(SktContact sender, String value)
    {
        if (OnContactAssignedPhone3Label == null) return; // Event not assigned    
        OnContactAssignedPhone3LabelArgs args = new OnContactAssignedPhone3LabelArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactAssignedPhone3LabelInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactAssignedPhone3Label, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnContactPopularityOrdArgs : EventArgs
    {
        public SktContact sender;
        public uint value;
        public OnContactPopularityOrdArgs(SktContact sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactPopularityOrdHandler OnContactPopularityOrd;    
    public delegate void OnContactPopularityOrdHandler (SktContact sender, OnContactPopularityOrdArgs e);
    
    internal void OnContactPopularityOrdInNewThread(object o)
    {
        OnContactPopularityOrdArgs e = (OnContactPopularityOrdArgs)o;
        OnContactPopularityOrd(e.sender, e);
    }
    
    internal void FireOnContactPopularityOrd(SktContact sender, uint value)
    {
        if (OnContactPopularityOrd == null) return; // Event not assigned    
        OnContactPopularityOrdArgs args = new OnContactPopularityOrdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactPopularityOrdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactPopularityOrd, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationIdentityArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationIdentityArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationIdentityHandler OnConversationIdentity;    
    public delegate void OnConversationIdentityHandler (SktConversation sender, OnConversationIdentityArgs e);
    
    internal void OnConversationIdentityInNewThread(object o)
    {
        OnConversationIdentityArgs e = (OnConversationIdentityArgs)o;
        OnConversationIdentity(e.sender, e);
    }
    
    internal void FireOnConversationIdentity(SktConversation sender, String value)
    {
        if (OnConversationIdentity == null) return; // Event not assigned    
        OnConversationIdentityArgs args = new OnConversationIdentityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationIdentityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationIdentity, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationTypeArgs : EventArgs
    {
        public SktConversation sender;
        public SktConversation.TYPE value;
        public OnConversationTypeArgs(SktConversation sender, SktConversation.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationTypeHandler OnConversationType;    
    public delegate void OnConversationTypeHandler (SktConversation sender, OnConversationTypeArgs e);
    
    internal void OnConversationTypeInNewThread(object o)
    {
        OnConversationTypeArgs e = (OnConversationTypeArgs)o;
        OnConversationType(e.sender, e);
    }
    
    internal void FireOnConversationType(SktConversation sender, SktConversation.TYPE value)
    {
        if (OnConversationType == null) return; // Event not assigned    
        OnConversationTypeArgs args = new OnConversationTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationLiveHostArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationLiveHostArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationLiveHostHandler OnConversationLiveHost;    
    public delegate void OnConversationLiveHostHandler (SktConversation sender, OnConversationLiveHostArgs e);
    
    internal void OnConversationLiveHostInNewThread(object o)
    {
        OnConversationLiveHostArgs e = (OnConversationLiveHostArgs)o;
        OnConversationLiveHost(e.sender, e);
    }
    
    internal void FireOnConversationLiveHost(SktConversation sender, String value)
    {
        if (OnConversationLiveHost == null) return; // Event not assigned    
        OnConversationLiveHostArgs args = new OnConversationLiveHostArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationLiveHostInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationLiveHost, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationLiveStartTimestampArgs : EventArgs
    {
        public SktConversation sender;
        public DateTime value;
        public OnConversationLiveStartTimestampArgs(SktConversation sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationLiveStartTimestampHandler OnConversationLiveStartTimestamp;    
    public delegate void OnConversationLiveStartTimestampHandler (SktConversation sender, OnConversationLiveStartTimestampArgs e);
    
    internal void OnConversationLiveStartTimestampInNewThread(object o)
    {
        OnConversationLiveStartTimestampArgs e = (OnConversationLiveStartTimestampArgs)o;
        OnConversationLiveStartTimestamp(e.sender, e);
    }
    
    internal void FireOnConversationLiveStartTimestamp(SktConversation sender, DateTime value)
    {
        if (OnConversationLiveStartTimestamp == null) return; // Event not assigned    
        OnConversationLiveStartTimestampArgs args = new OnConversationLiveStartTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationLiveStartTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationLiveStartTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationLiveIsMutedArgs : EventArgs
    {
        public SktConversation sender;
        public Boolean value;
        public OnConversationLiveIsMutedArgs(SktConversation sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationLiveIsMutedHandler OnConversationLiveIsMuted;    
    public delegate void OnConversationLiveIsMutedHandler (SktConversation sender, OnConversationLiveIsMutedArgs e);
    
    internal void OnConversationLiveIsMutedInNewThread(object o)
    {
        OnConversationLiveIsMutedArgs e = (OnConversationLiveIsMutedArgs)o;
        OnConversationLiveIsMuted(e.sender, e);
    }
    
    internal void FireOnConversationLiveIsMuted(SktConversation sender, Boolean value)
    {
        if (OnConversationLiveIsMuted == null) return; // Event not assigned    
        OnConversationLiveIsMutedArgs args = new OnConversationLiveIsMutedArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationLiveIsMutedInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationLiveIsMuted, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationAlertStringArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationAlertStringArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationAlertStringHandler OnConversationAlertString;    
    public delegate void OnConversationAlertStringHandler (SktConversation sender, OnConversationAlertStringArgs e);
    
    internal void OnConversationAlertStringInNewThread(object o)
    {
        OnConversationAlertStringArgs e = (OnConversationAlertStringArgs)o;
        OnConversationAlertString(e.sender, e);
    }
    
    internal void FireOnConversationAlertString(SktConversation sender, String value)
    {
        if (OnConversationAlertString == null) return; // Event not assigned    
        OnConversationAlertStringArgs args = new OnConversationAlertStringArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationAlertStringInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationAlertString, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationIsBookmarkedArgs : EventArgs
    {
        public SktConversation sender;
        public Boolean value;
        public OnConversationIsBookmarkedArgs(SktConversation sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationIsBookmarkedHandler OnConversationIsBookmarked;    
    public delegate void OnConversationIsBookmarkedHandler (SktConversation sender, OnConversationIsBookmarkedArgs e);
    
    internal void OnConversationIsBookmarkedInNewThread(object o)
    {
        OnConversationIsBookmarkedArgs e = (OnConversationIsBookmarkedArgs)o;
        OnConversationIsBookmarked(e.sender, e);
    }
    
    internal void FireOnConversationIsBookmarked(SktConversation sender, Boolean value)
    {
        if (OnConversationIsBookmarked == null) return; // Event not assigned    
        OnConversationIsBookmarkedArgs args = new OnConversationIsBookmarkedArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationIsBookmarkedInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationIsBookmarked, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationGivenDisplaynameArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationGivenDisplaynameArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationGivenDisplaynameHandler OnConversationGivenDisplayname;    
    public delegate void OnConversationGivenDisplaynameHandler (SktConversation sender, OnConversationGivenDisplaynameArgs e);
    
    internal void OnConversationGivenDisplaynameInNewThread(object o)
    {
        OnConversationGivenDisplaynameArgs e = (OnConversationGivenDisplaynameArgs)o;
        OnConversationGivenDisplayname(e.sender, e);
    }
    
    internal void FireOnConversationGivenDisplayname(SktConversation sender, String value)
    {
        if (OnConversationGivenDisplayname == null) return; // Event not assigned    
        OnConversationGivenDisplaynameArgs args = new OnConversationGivenDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationGivenDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationGivenDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationDisplaynameArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationDisplaynameArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationDisplaynameHandler OnConversationDisplayname;    
    public delegate void OnConversationDisplaynameHandler (SktConversation sender, OnConversationDisplaynameArgs e);
    
    internal void OnConversationDisplaynameInNewThread(object o)
    {
        OnConversationDisplaynameArgs e = (OnConversationDisplaynameArgs)o;
        OnConversationDisplayname(e.sender, e);
    }
    
    internal void FireOnConversationDisplayname(SktConversation sender, String value)
    {
        if (OnConversationDisplayname == null) return; // Event not assigned    
        OnConversationDisplaynameArgs args = new OnConversationDisplaynameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationDisplaynameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationDisplayname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationLocalLivestatusArgs : EventArgs
    {
        public SktConversation sender;
        public SktConversation.LOCAL_LIVESTATUS value;
        public OnConversationLocalLivestatusArgs(SktConversation sender, SktConversation.LOCAL_LIVESTATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationLocalLivestatusHandler OnConversationLocalLivestatus;    
    public delegate void OnConversationLocalLivestatusHandler (SktConversation sender, OnConversationLocalLivestatusArgs e);
    
    internal void OnConversationLocalLivestatusInNewThread(object o)
    {
        OnConversationLocalLivestatusArgs e = (OnConversationLocalLivestatusArgs)o;
        OnConversationLocalLivestatus(e.sender, e);
    }
    
    internal void FireOnConversationLocalLivestatus(SktConversation sender, SktConversation.LOCAL_LIVESTATUS value)
    {
        if (OnConversationLocalLivestatus == null) return; // Event not assigned    
        OnConversationLocalLivestatusArgs args = new OnConversationLocalLivestatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationLocalLivestatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationLocalLivestatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationInboxTimestampArgs : EventArgs
    {
        public SktConversation sender;
        public DateTime value;
        public OnConversationInboxTimestampArgs(SktConversation sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationInboxTimestampHandler OnConversationInboxTimestamp;    
    public delegate void OnConversationInboxTimestampHandler (SktConversation sender, OnConversationInboxTimestampArgs e);
    
    internal void OnConversationInboxTimestampInNewThread(object o)
    {
        OnConversationInboxTimestampArgs e = (OnConversationInboxTimestampArgs)o;
        OnConversationInboxTimestamp(e.sender, e);
    }
    
    internal void FireOnConversationInboxTimestamp(SktConversation sender, DateTime value)
    {
        if (OnConversationInboxTimestamp == null) return; // Event not assigned    
        OnConversationInboxTimestampArgs args = new OnConversationInboxTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationInboxTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationInboxTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationInboxMessageIdArgs : EventArgs
    {
        public SktConversation sender;
        public SktMessage value;
        public OnConversationInboxMessageIdArgs(SktConversation sender, SktMessage newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationInboxMessageIdHandler OnConversationInboxMessageId;    
    public delegate void OnConversationInboxMessageIdHandler (SktConversation sender, OnConversationInboxMessageIdArgs e);
    
    internal void OnConversationInboxMessageIdInNewThread(object o)
    {
        OnConversationInboxMessageIdArgs e = (OnConversationInboxMessageIdArgs)o;
        OnConversationInboxMessageId(e.sender, e);
    }
    
    internal void FireOnConversationInboxMessageId(SktConversation sender, SktMessage value)
    {
        if (OnConversationInboxMessageId == null) return; // Event not assigned    
        OnConversationInboxMessageIdArgs args = new OnConversationInboxMessageIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationInboxMessageIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationInboxMessageId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationUnconsumedSuppressedMessagesArgs : EventArgs
    {
        public SktConversation sender;
        public uint value;
        public OnConversationUnconsumedSuppressedMessagesArgs(SktConversation sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationUnconsumedSuppressedMessagesHandler OnConversationUnconsumedSuppressedMessages;    
    public delegate void OnConversationUnconsumedSuppressedMessagesHandler (SktConversation sender, OnConversationUnconsumedSuppressedMessagesArgs e);
    
    internal void OnConversationUnconsumedSuppressedMessagesInNewThread(object o)
    {
        OnConversationUnconsumedSuppressedMessagesArgs e = (OnConversationUnconsumedSuppressedMessagesArgs)o;
        OnConversationUnconsumedSuppressedMessages(e.sender, e);
    }
    
    internal void FireOnConversationUnconsumedSuppressedMessages(SktConversation sender, uint value)
    {
        if (OnConversationUnconsumedSuppressedMessages == null) return; // Event not assigned    
        OnConversationUnconsumedSuppressedMessagesArgs args = new OnConversationUnconsumedSuppressedMessagesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationUnconsumedSuppressedMessagesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationUnconsumedSuppressedMessages, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationUnconsumedNormalMessagesArgs : EventArgs
    {
        public SktConversation sender;
        public uint value;
        public OnConversationUnconsumedNormalMessagesArgs(SktConversation sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationUnconsumedNormalMessagesHandler OnConversationUnconsumedNormalMessages;    
    public delegate void OnConversationUnconsumedNormalMessagesHandler (SktConversation sender, OnConversationUnconsumedNormalMessagesArgs e);
    
    internal void OnConversationUnconsumedNormalMessagesInNewThread(object o)
    {
        OnConversationUnconsumedNormalMessagesArgs e = (OnConversationUnconsumedNormalMessagesArgs)o;
        OnConversationUnconsumedNormalMessages(e.sender, e);
    }
    
    internal void FireOnConversationUnconsumedNormalMessages(SktConversation sender, uint value)
    {
        if (OnConversationUnconsumedNormalMessages == null) return; // Event not assigned    
        OnConversationUnconsumedNormalMessagesArgs args = new OnConversationUnconsumedNormalMessagesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationUnconsumedNormalMessagesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationUnconsumedNormalMessages, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationUnconsumedElevatedMessagesArgs : EventArgs
    {
        public SktConversation sender;
        public uint value;
        public OnConversationUnconsumedElevatedMessagesArgs(SktConversation sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationUnconsumedElevatedMessagesHandler OnConversationUnconsumedElevatedMessages;    
    public delegate void OnConversationUnconsumedElevatedMessagesHandler (SktConversation sender, OnConversationUnconsumedElevatedMessagesArgs e);
    
    internal void OnConversationUnconsumedElevatedMessagesInNewThread(object o)
    {
        OnConversationUnconsumedElevatedMessagesArgs e = (OnConversationUnconsumedElevatedMessagesArgs)o;
        OnConversationUnconsumedElevatedMessages(e.sender, e);
    }
    
    internal void FireOnConversationUnconsumedElevatedMessages(SktConversation sender, uint value)
    {
        if (OnConversationUnconsumedElevatedMessages == null) return; // Event not assigned    
        OnConversationUnconsumedElevatedMessagesArgs args = new OnConversationUnconsumedElevatedMessagesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationUnconsumedElevatedMessagesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationUnconsumedElevatedMessages, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationUnconsumedMessagesVoiceArgs : EventArgs
    {
        public SktConversation sender;
        public Boolean value;
        public OnConversationUnconsumedMessagesVoiceArgs(SktConversation sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationUnconsumedMessagesVoiceHandler OnConversationUnconsumedMessagesVoice;    
    public delegate void OnConversationUnconsumedMessagesVoiceHandler (SktConversation sender, OnConversationUnconsumedMessagesVoiceArgs e);
    
    internal void OnConversationUnconsumedMessagesVoiceInNewThread(object o)
    {
        OnConversationUnconsumedMessagesVoiceArgs e = (OnConversationUnconsumedMessagesVoiceArgs)o;
        OnConversationUnconsumedMessagesVoice(e.sender, e);
    }
    
    internal void FireOnConversationUnconsumedMessagesVoice(SktConversation sender, Boolean value)
    {
        if (OnConversationUnconsumedMessagesVoice == null) return; // Event not assigned    
        OnConversationUnconsumedMessagesVoiceArgs args = new OnConversationUnconsumedMessagesVoiceArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationUnconsumedMessagesVoiceInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationUnconsumedMessagesVoice, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationActiveVmIdArgs : EventArgs
    {
        public SktConversation sender;
        public SktVoicemail value;
        public OnConversationActiveVmIdArgs(SktConversation sender, SktVoicemail newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationActiveVmIdHandler OnConversationActiveVmId;    
    public delegate void OnConversationActiveVmIdHandler (SktConversation sender, OnConversationActiveVmIdArgs e);
    
    internal void OnConversationActiveVmIdInNewThread(object o)
    {
        OnConversationActiveVmIdArgs e = (OnConversationActiveVmIdArgs)o;
        OnConversationActiveVmId(e.sender, e);
    }
    
    internal void FireOnConversationActiveVmId(SktConversation sender, SktVoicemail value)
    {
        if (OnConversationActiveVmId == null) return; // Event not assigned    
        OnConversationActiveVmIdArgs args = new OnConversationActiveVmIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationActiveVmIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationActiveVmId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationConsumptionHorizonArgs : EventArgs
    {
        public SktConversation sender;
        public DateTime value;
        public OnConversationConsumptionHorizonArgs(SktConversation sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationConsumptionHorizonHandler OnConversationConsumptionHorizon;    
    public delegate void OnConversationConsumptionHorizonHandler (SktConversation sender, OnConversationConsumptionHorizonArgs e);
    
    internal void OnConversationConsumptionHorizonInNewThread(object o)
    {
        OnConversationConsumptionHorizonArgs e = (OnConversationConsumptionHorizonArgs)o;
        OnConversationConsumptionHorizon(e.sender, e);
    }
    
    internal void FireOnConversationConsumptionHorizon(SktConversation sender, DateTime value)
    {
        if (OnConversationConsumptionHorizon == null) return; // Event not assigned    
        OnConversationConsumptionHorizonArgs args = new OnConversationConsumptionHorizonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationConsumptionHorizonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationConsumptionHorizon, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationLastActivityTimestampArgs : EventArgs
    {
        public SktConversation sender;
        public DateTime value;
        public OnConversationLastActivityTimestampArgs(SktConversation sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationLastActivityTimestampHandler OnConversationLastActivityTimestamp;    
    public delegate void OnConversationLastActivityTimestampHandler (SktConversation sender, OnConversationLastActivityTimestampArgs e);
    
    internal void OnConversationLastActivityTimestampInNewThread(object o)
    {
        OnConversationLastActivityTimestampArgs e = (OnConversationLastActivityTimestampArgs)o;
        OnConversationLastActivityTimestamp(e.sender, e);
    }
    
    internal void FireOnConversationLastActivityTimestamp(SktConversation sender, DateTime value)
    {
        if (OnConversationLastActivityTimestamp == null) return; // Event not assigned    
        OnConversationLastActivityTimestampArgs args = new OnConversationLastActivityTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationLastActivityTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationLastActivityTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationSpawnedFromConvoIdArgs : EventArgs
    {
        public SktConversation sender;
        public SktConversation value;
        public OnConversationSpawnedFromConvoIdArgs(SktConversation sender, SktConversation newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationSpawnedFromConvoIdHandler OnConversationSpawnedFromConvoId;    
    public delegate void OnConversationSpawnedFromConvoIdHandler (SktConversation sender, OnConversationSpawnedFromConvoIdArgs e);
    
    internal void OnConversationSpawnedFromConvoIdInNewThread(object o)
    {
        OnConversationSpawnedFromConvoIdArgs e = (OnConversationSpawnedFromConvoIdArgs)o;
        OnConversationSpawnedFromConvoId(e.sender, e);
    }
    
    internal void FireOnConversationSpawnedFromConvoId(SktConversation sender, SktConversation value)
    {
        if (OnConversationSpawnedFromConvoId == null) return; // Event not assigned    
        OnConversationSpawnedFromConvoIdArgs args = new OnConversationSpawnedFromConvoIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationSpawnedFromConvoIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationSpawnedFromConvoId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationCreatorArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationCreatorArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationCreatorHandler OnConversationCreator;    
    public delegate void OnConversationCreatorHandler (SktConversation sender, OnConversationCreatorArgs e);
    
    internal void OnConversationCreatorInNewThread(object o)
    {
        OnConversationCreatorArgs e = (OnConversationCreatorArgs)o;
        OnConversationCreator(e.sender, e);
    }
    
    internal void FireOnConversationCreator(SktConversation sender, String value)
    {
        if (OnConversationCreator == null) return; // Event not assigned    
        OnConversationCreatorArgs args = new OnConversationCreatorArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationCreatorInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationCreator, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationCreationTimestampArgs : EventArgs
    {
        public SktConversation sender;
        public DateTime value;
        public OnConversationCreationTimestampArgs(SktConversation sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationCreationTimestampHandler OnConversationCreationTimestamp;    
    public delegate void OnConversationCreationTimestampHandler (SktConversation sender, OnConversationCreationTimestampArgs e);
    
    internal void OnConversationCreationTimestampInNewThread(object o)
    {
        OnConversationCreationTimestampArgs e = (OnConversationCreationTimestampArgs)o;
        OnConversationCreationTimestamp(e.sender, e);
    }
    
    internal void FireOnConversationCreationTimestamp(SktConversation sender, DateTime value)
    {
        if (OnConversationCreationTimestamp == null) return; // Event not assigned    
        OnConversationCreationTimestampArgs args = new OnConversationCreationTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationCreationTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationCreationTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationMyStatusArgs : EventArgs
    {
        public SktConversation sender;
        public SktConversation.MY_STATUS value;
        public OnConversationMyStatusArgs(SktConversation sender, SktConversation.MY_STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationMyStatusHandler OnConversationMyStatus;    
    public delegate void OnConversationMyStatusHandler (SktConversation sender, OnConversationMyStatusArgs e);
    
    internal void OnConversationMyStatusInNewThread(object o)
    {
        OnConversationMyStatusArgs e = (OnConversationMyStatusArgs)o;
        OnConversationMyStatus(e.sender, e);
    }
    
    internal void FireOnConversationMyStatus(SktConversation sender, SktConversation.MY_STATUS value)
    {
        if (OnConversationMyStatus == null) return; // Event not assigned    
        OnConversationMyStatusArgs args = new OnConversationMyStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationMyStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationMyStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationOptJoiningEnabledArgs : EventArgs
    {
        public SktConversation sender;
        public Boolean value;
        public OnConversationOptJoiningEnabledArgs(SktConversation sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationOptJoiningEnabledHandler OnConversationOptJoiningEnabled;    
    public delegate void OnConversationOptJoiningEnabledHandler (SktConversation sender, OnConversationOptJoiningEnabledArgs e);
    
    internal void OnConversationOptJoiningEnabledInNewThread(object o)
    {
        OnConversationOptJoiningEnabledArgs e = (OnConversationOptJoiningEnabledArgs)o;
        OnConversationOptJoiningEnabled(e.sender, e);
    }
    
    internal void FireOnConversationOptJoiningEnabled(SktConversation sender, Boolean value)
    {
        if (OnConversationOptJoiningEnabled == null) return; // Event not assigned    
        OnConversationOptJoiningEnabledArgs args = new OnConversationOptJoiningEnabledArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationOptJoiningEnabledInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationOptJoiningEnabled, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationOptEntryLevelRankArgs : EventArgs
    {
        public SktConversation sender;
        public SktParticipant.RANK value;
        public OnConversationOptEntryLevelRankArgs(SktConversation sender, SktParticipant.RANK newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationOptEntryLevelRankHandler OnConversationOptEntryLevelRank;    
    public delegate void OnConversationOptEntryLevelRankHandler (SktConversation sender, OnConversationOptEntryLevelRankArgs e);
    
    internal void OnConversationOptEntryLevelRankInNewThread(object o)
    {
        OnConversationOptEntryLevelRankArgs e = (OnConversationOptEntryLevelRankArgs)o;
        OnConversationOptEntryLevelRank(e.sender, e);
    }
    
    internal void FireOnConversationOptEntryLevelRank(SktConversation sender, SktParticipant.RANK value)
    {
        if (OnConversationOptEntryLevelRank == null) return; // Event not assigned    
        OnConversationOptEntryLevelRankArgs args = new OnConversationOptEntryLevelRankArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationOptEntryLevelRankInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationOptEntryLevelRank, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationOptDiscloseHistoryArgs : EventArgs
    {
        public SktConversation sender;
        public Boolean value;
        public OnConversationOptDiscloseHistoryArgs(SktConversation sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationOptDiscloseHistoryHandler OnConversationOptDiscloseHistory;    
    public delegate void OnConversationOptDiscloseHistoryHandler (SktConversation sender, OnConversationOptDiscloseHistoryArgs e);
    
    internal void OnConversationOptDiscloseHistoryInNewThread(object o)
    {
        OnConversationOptDiscloseHistoryArgs e = (OnConversationOptDiscloseHistoryArgs)o;
        OnConversationOptDiscloseHistory(e.sender, e);
    }
    
    internal void FireOnConversationOptDiscloseHistory(SktConversation sender, Boolean value)
    {
        if (OnConversationOptDiscloseHistory == null) return; // Event not assigned    
        OnConversationOptDiscloseHistoryArgs args = new OnConversationOptDiscloseHistoryArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationOptDiscloseHistoryInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationOptDiscloseHistory, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationOptAdminOnlyActivitiesArgs : EventArgs
    {
        public SktConversation sender;
        public SktConversation.ALLOWED_ACTIVITY value;
        public OnConversationOptAdminOnlyActivitiesArgs(SktConversation sender, SktConversation.ALLOWED_ACTIVITY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationOptAdminOnlyActivitiesHandler OnConversationOptAdminOnlyActivities;    
    public delegate void OnConversationOptAdminOnlyActivitiesHandler (SktConversation sender, OnConversationOptAdminOnlyActivitiesArgs e);
    
    internal void OnConversationOptAdminOnlyActivitiesInNewThread(object o)
    {
        OnConversationOptAdminOnlyActivitiesArgs e = (OnConversationOptAdminOnlyActivitiesArgs)o;
        OnConversationOptAdminOnlyActivities(e.sender, e);
    }
    
    internal void FireOnConversationOptAdminOnlyActivities(SktConversation sender, SktConversation.ALLOWED_ACTIVITY value)
    {
        if (OnConversationOptAdminOnlyActivities == null) return; // Event not assigned    
        OnConversationOptAdminOnlyActivitiesArgs args = new OnConversationOptAdminOnlyActivitiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationOptAdminOnlyActivitiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationOptAdminOnlyActivities, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationPasswordhintArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationPasswordhintArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationPasswordhintHandler OnConversationPasswordhint;    
    public delegate void OnConversationPasswordhintHandler (SktConversation sender, OnConversationPasswordhintArgs e);
    
    internal void OnConversationPasswordhintInNewThread(object o)
    {
        OnConversationPasswordhintArgs e = (OnConversationPasswordhintArgs)o;
        OnConversationPasswordhint(e.sender, e);
    }
    
    internal void FireOnConversationPasswordhint(SktConversation sender, String value)
    {
        if (OnConversationPasswordhint == null) return; // Event not assigned    
        OnConversationPasswordhintArgs args = new OnConversationPasswordhintArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationPasswordhintInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationPasswordhint, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationMetaNameArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationMetaNameArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationMetaNameHandler OnConversationMetaName;    
    public delegate void OnConversationMetaNameHandler (SktConversation sender, OnConversationMetaNameArgs e);
    
    internal void OnConversationMetaNameInNewThread(object o)
    {
        OnConversationMetaNameArgs e = (OnConversationMetaNameArgs)o;
        OnConversationMetaName(e.sender, e);
    }
    
    internal void FireOnConversationMetaName(SktConversation sender, String value)
    {
        if (OnConversationMetaName == null) return; // Event not assigned    
        OnConversationMetaNameArgs args = new OnConversationMetaNameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationMetaNameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationMetaName, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationMetaTopicArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationMetaTopicArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationMetaTopicHandler OnConversationMetaTopic;    
    public delegate void OnConversationMetaTopicHandler (SktConversation sender, OnConversationMetaTopicArgs e);
    
    internal void OnConversationMetaTopicInNewThread(object o)
    {
        OnConversationMetaTopicArgs e = (OnConversationMetaTopicArgs)o;
        OnConversationMetaTopic(e.sender, e);
    }
    
    internal void FireOnConversationMetaTopic(SktConversation sender, String value)
    {
        if (OnConversationMetaTopic == null) return; // Event not assigned    
        OnConversationMetaTopicArgs args = new OnConversationMetaTopicArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationMetaTopicInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationMetaTopic, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationMetaGuidelinesArgs : EventArgs
    {
        public SktConversation sender;
        public String value;
        public OnConversationMetaGuidelinesArgs(SktConversation sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationMetaGuidelinesHandler OnConversationMetaGuidelines;    
    public delegate void OnConversationMetaGuidelinesHandler (SktConversation sender, OnConversationMetaGuidelinesArgs e);
    
    internal void OnConversationMetaGuidelinesInNewThread(object o)
    {
        OnConversationMetaGuidelinesArgs e = (OnConversationMetaGuidelinesArgs)o;
        OnConversationMetaGuidelines(e.sender, e);
    }
    
    internal void FireOnConversationMetaGuidelines(SktConversation sender, String value)
    {
        if (OnConversationMetaGuidelines == null) return; // Event not assigned    
        OnConversationMetaGuidelinesArgs args = new OnConversationMetaGuidelinesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationMetaGuidelinesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationMetaGuidelines, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnConversationMetaPictureArgs : EventArgs
    {
        public SktConversation sender;
        public byte[] value;
        public OnConversationMetaPictureArgs(SktConversation sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnConversationMetaPictureHandler OnConversationMetaPicture;    
    public delegate void OnConversationMetaPictureHandler (SktConversation sender, OnConversationMetaPictureArgs e);
    
    internal void OnConversationMetaPictureInNewThread(object o)
    {
        OnConversationMetaPictureArgs e = (OnConversationMetaPictureArgs)o;
        OnConversationMetaPicture(e.sender, e);
    }
    
    internal void FireOnConversationMetaPicture(SktConversation sender, byte[] value)
    {
        if (OnConversationMetaPicture == null) return; // Event not assigned    
        OnConversationMetaPictureArgs args = new OnConversationMetaPictureArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnConversationMetaPictureInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnConversationMetaPicture, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    public event OnConversationParticipantListChangeHandler OnConversationParticipantListChange;
    
    public delegate void OnConversationParticipantListChangeHandler (SktConversation sender, OnConversationParticipantListChangeArgs e);
    
    public class OnConversationParticipantListChangeArgs : EventArgs
    {
        public SktConversation senderobj;
        public OnConversationParticipantListChangeArgs () {}
    }
    
    internal void OnConversationParticipantListChangeInNewThread(object e)
    {
        OnConversationParticipantListChangeArgs args = (OnConversationParticipantListChangeArgs)e;
        OnConversationParticipantListChange(args.senderobj, args);
    }
    
    internal void FireOnConversationParticipantListChange(SktConversation sender, OnConversationParticipantListChangeArgs e)
    {
        if (OnConversationParticipantListChange == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnConversationParticipantListChangeInNewThread); return; }
        gui.BeginInvoke(OnConversationParticipantListChange, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnConversationParticipantListChange (SktConversation sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnConversationParticipantListChange");
        OnConversationParticipantListChangeArgs args = new OnConversationParticipantListChangeArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnConversationParticipantListChange", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnConversationParticipantListChange(sender, args);
    }
    
    public event OnConversationMessageHandler OnConversationMessage;
    
    public delegate void OnConversationMessageHandler (SktConversation sender, OnConversationMessageArgs e);
    
    public class OnConversationMessageArgs : EventArgs
    {
        public SktConversation senderobj;
        public SktMessage message;
        public OnConversationMessageArgs () {}
    }
    
    internal void OnConversationMessageInNewThread(object e)
    {
        OnConversationMessageArgs args = (OnConversationMessageArgs)e;
        OnConversationMessage(args.senderobj, args);
    }
    
    internal void FireOnConversationMessage(SktConversation sender, OnConversationMessageArgs e)
    {
        if (OnConversationMessage == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnConversationMessageInNewThread); return; }
        gui.BeginInvoke(OnConversationMessage, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnConversationMessage (SktConversation sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnConversationMessage");
        OnConversationMessageArgs args = new OnConversationMessageArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.message = (SktMessage)skypeRef.decoder.DecodeObject(9); // SktMessage class ID = 9
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnConversationMessage", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnConversationMessage(sender, args);
    }
    
    public event OnConversationSpawnConferenceHandler OnConversationSpawnConference;
    
    public delegate void OnConversationSpawnConferenceHandler (SktConversation sender, OnConversationSpawnConferenceArgs e);
    
    public class OnConversationSpawnConferenceArgs : EventArgs
    {
        public SktConversation senderobj;
        public SktConversation spawned;
        public OnConversationSpawnConferenceArgs () {}
    }
    
    internal void OnConversationSpawnConferenceInNewThread(object e)
    {
        OnConversationSpawnConferenceArgs args = (OnConversationSpawnConferenceArgs)e;
        OnConversationSpawnConference(args.senderobj, args);
    }
    
    internal void FireOnConversationSpawnConference(SktConversation sender, OnConversationSpawnConferenceArgs e)
    {
        if (OnConversationSpawnConference == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnConversationSpawnConferenceInNewThread); return; }
        gui.BeginInvoke(OnConversationSpawnConference, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnConversationSpawnConference (SktConversation sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnConversationSpawnConference");
        OnConversationSpawnConferenceArgs args = new OnConversationSpawnConferenceArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.spawned = (SktConversation)skypeRef.decoder.DecodeObject(18); // SktConversation class ID = 18
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnConversationSpawnConference", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnConversationSpawnConference(sender, args);
    }
    
    
    public class OnContactSearchContactSearchStatusArgs : EventArgs
    {
        public SktContactSearch sender;
        public SktContactSearch.STATUS value;
        public OnContactSearchContactSearchStatusArgs(SktContactSearch sender, SktContactSearch.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnContactSearchContactSearchStatusHandler OnContactSearchContactSearchStatus;    
    public delegate void OnContactSearchContactSearchStatusHandler (SktContactSearch sender, OnContactSearchContactSearchStatusArgs e);
    
    internal void OnContactSearchContactSearchStatusInNewThread(object o)
    {
        OnContactSearchContactSearchStatusArgs e = (OnContactSearchContactSearchStatusArgs)o;
        OnContactSearchContactSearchStatus(e.sender, e);
    }
    
    internal void FireOnContactSearchContactSearchStatus(SktContactSearch sender, SktContactSearch.STATUS value)
    {
        if (OnContactSearchContactSearchStatus == null) return; // Event not assigned    
        OnContactSearchContactSearchStatusArgs args = new OnContactSearchContactSearchStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnContactSearchContactSearchStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnContactSearchContactSearchStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    public event OnContactSearchNewResultHandler OnContactSearchNewResult;
    
    public delegate void OnContactSearchNewResultHandler (SktContactSearch sender, OnContactSearchNewResultArgs e);
    
    public class OnContactSearchNewResultArgs : EventArgs
    {
        public SktContactSearch senderobj;
        public SktContact contact;
        public uint rankValue;
        public OnContactSearchNewResultArgs () {}
    }
    
    internal void OnContactSearchNewResultInNewThread(object e)
    {
        OnContactSearchNewResultArgs args = (OnContactSearchNewResultArgs)e;
        OnContactSearchNewResult(args.senderobj, args);
    }
    
    internal void FireOnContactSearchNewResult(SktContactSearch sender, OnContactSearchNewResultArgs e)
    {
        if (OnContactSearchNewResult == null) return; // No event assigned
        if (gui == null) { FireCallbackInSeparateThread(e, OnContactSearchNewResultInNewThread); return; }
        gui.BeginInvoke(OnContactSearchNewResult, new object[] { sender, e }); // Synchronizing to gui thread
    }
    
    internal void ProcessOnContactSearchNewResult (SktContactSearch sender)
    {
        if (skypeRef.logging) skypeRef.Log("Processing event OnContactSearchNewResult");
        OnContactSearchNewResultArgs args = new OnContactSearchNewResultArgs();
        int marker = 0;
        int typeTag = 0;
        do
        {
            typeTag = skypeRef.transport.ReadByte();
            if (typeTag == 122) break;
            marker = skypeRef.transport.ReadByte();
            switch (marker)
            {
                case 1:
                    args.contact = (SktContact)skypeRef.decoder.DecodeObject(2); // SktContact class ID = 2
                    break;
                case 2:
                    args.rankValue = skypeRef.decoder.DecodeUint();
                    break;
                default:
                    if (marker != 122) skypeRef.Error(String.Format("Invalid event argument tag {0} in OnContactSearchNewResult", marker));
                    break;
            }
        } while (marker != 'z');
        skypeRef.transport.ResumeSocketReaderFromEvent();
        args.senderobj = sender;
        FireOnContactSearchNewResult(sender, args);
    }
    
    
    public class OnSmsTypeArgs : EventArgs
    {
        public SktSms sender;
        public SktSms.TYPE value;
        public OnSmsTypeArgs(SktSms sender, SktSms.TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsTypeHandler OnSmsType;    
    public delegate void OnSmsTypeHandler (SktSms sender, OnSmsTypeArgs e);
    
    internal void OnSmsTypeInNewThread(object o)
    {
        OnSmsTypeArgs e = (OnSmsTypeArgs)o;
        OnSmsType(e.sender, e);
    }
    
    internal void FireOnSmsType(SktSms sender, SktSms.TYPE value)
    {
        if (OnSmsType == null) return; // Event not assigned    
        OnSmsTypeArgs args = new OnSmsTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsOutgoingReplyTypeArgs : EventArgs
    {
        public SktSms sender;
        public SktSms.OUTGOING_REPLY_TYPE value;
        public OnSmsOutgoingReplyTypeArgs(SktSms sender, SktSms.OUTGOING_REPLY_TYPE newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsOutgoingReplyTypeHandler OnSmsOutgoingReplyType;    
    public delegate void OnSmsOutgoingReplyTypeHandler (SktSms sender, OnSmsOutgoingReplyTypeArgs e);
    
    internal void OnSmsOutgoingReplyTypeInNewThread(object o)
    {
        OnSmsOutgoingReplyTypeArgs e = (OnSmsOutgoingReplyTypeArgs)o;
        OnSmsOutgoingReplyType(e.sender, e);
    }
    
    internal void FireOnSmsOutgoingReplyType(SktSms sender, SktSms.OUTGOING_REPLY_TYPE value)
    {
        if (OnSmsOutgoingReplyType == null) return; // Event not assigned    
        OnSmsOutgoingReplyTypeArgs args = new OnSmsOutgoingReplyTypeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsOutgoingReplyTypeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsOutgoingReplyType, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsStatusArgs : EventArgs
    {
        public SktSms sender;
        public SktSms.STATUS value;
        public OnSmsStatusArgs(SktSms sender, SktSms.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsStatusHandler OnSmsStatus;    
    public delegate void OnSmsStatusHandler (SktSms sender, OnSmsStatusArgs e);
    
    internal void OnSmsStatusInNewThread(object o)
    {
        OnSmsStatusArgs e = (OnSmsStatusArgs)o;
        OnSmsStatus(e.sender, e);
    }
    
    internal void FireOnSmsStatus(SktSms sender, SktSms.STATUS value)
    {
        if (OnSmsStatus == null) return; // Event not assigned    
        OnSmsStatusArgs args = new OnSmsStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsFailurereasonArgs : EventArgs
    {
        public SktSms sender;
        public SktSms.FAILUREREASON value;
        public OnSmsFailurereasonArgs(SktSms sender, SktSms.FAILUREREASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsFailurereasonHandler OnSmsFailurereason;    
    public delegate void OnSmsFailurereasonHandler (SktSms sender, OnSmsFailurereasonArgs e);
    
    internal void OnSmsFailurereasonInNewThread(object o)
    {
        OnSmsFailurereasonArgs e = (OnSmsFailurereasonArgs)o;
        OnSmsFailurereason(e.sender, e);
    }
    
    internal void FireOnSmsFailurereason(SktSms sender, SktSms.FAILUREREASON value)
    {
        if (OnSmsFailurereason == null) return; // Event not assigned    
        OnSmsFailurereasonArgs args = new OnSmsFailurereasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsFailurereasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsFailurereason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsIsFailedUnseenArgs : EventArgs
    {
        public SktSms sender;
        public Boolean value;
        public OnSmsIsFailedUnseenArgs(SktSms sender, Boolean newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsIsFailedUnseenHandler OnSmsIsFailedUnseen;    
    public delegate void OnSmsIsFailedUnseenHandler (SktSms sender, OnSmsIsFailedUnseenArgs e);
    
    internal void OnSmsIsFailedUnseenInNewThread(object o)
    {
        OnSmsIsFailedUnseenArgs e = (OnSmsIsFailedUnseenArgs)o;
        OnSmsIsFailedUnseen(e.sender, e);
    }
    
    internal void FireOnSmsIsFailedUnseen(SktSms sender, Boolean value)
    {
        if (OnSmsIsFailedUnseen == null) return; // Event not assigned    
        OnSmsIsFailedUnseenArgs args = new OnSmsIsFailedUnseenArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsIsFailedUnseenInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsIsFailedUnseen, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsTimestampArgs : EventArgs
    {
        public SktSms sender;
        public DateTime value;
        public OnSmsTimestampArgs(SktSms sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsTimestampHandler OnSmsTimestamp;    
    public delegate void OnSmsTimestampHandler (SktSms sender, OnSmsTimestampArgs e);
    
    internal void OnSmsTimestampInNewThread(object o)
    {
        OnSmsTimestampArgs e = (OnSmsTimestampArgs)o;
        OnSmsTimestamp(e.sender, e);
    }
    
    internal void FireOnSmsTimestamp(SktSms sender, DateTime value)
    {
        if (OnSmsTimestamp == null) return; // Event not assigned    
        OnSmsTimestampArgs args = new OnSmsTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsPriceArgs : EventArgs
    {
        public SktSms sender;
        public uint value;
        public OnSmsPriceArgs(SktSms sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsPriceHandler OnSmsPrice;    
    public delegate void OnSmsPriceHandler (SktSms sender, OnSmsPriceArgs e);
    
    internal void OnSmsPriceInNewThread(object o)
    {
        OnSmsPriceArgs e = (OnSmsPriceArgs)o;
        OnSmsPrice(e.sender, e);
    }
    
    internal void FireOnSmsPrice(SktSms sender, uint value)
    {
        if (OnSmsPrice == null) return; // Event not assigned    
        OnSmsPriceArgs args = new OnSmsPriceArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsPriceInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsPrice, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsPricePrecisionArgs : EventArgs
    {
        public SktSms sender;
        public uint value;
        public OnSmsPricePrecisionArgs(SktSms sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsPricePrecisionHandler OnSmsPricePrecision;    
    public delegate void OnSmsPricePrecisionHandler (SktSms sender, OnSmsPricePrecisionArgs e);
    
    internal void OnSmsPricePrecisionInNewThread(object o)
    {
        OnSmsPricePrecisionArgs e = (OnSmsPricePrecisionArgs)o;
        OnSmsPricePrecision(e.sender, e);
    }
    
    internal void FireOnSmsPricePrecision(SktSms sender, uint value)
    {
        if (OnSmsPricePrecision == null) return; // Event not assigned    
        OnSmsPricePrecisionArgs args = new OnSmsPricePrecisionArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsPricePrecisionInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsPricePrecision, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsPriceCurrencyArgs : EventArgs
    {
        public SktSms sender;
        public String value;
        public OnSmsPriceCurrencyArgs(SktSms sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsPriceCurrencyHandler OnSmsPriceCurrency;    
    public delegate void OnSmsPriceCurrencyHandler (SktSms sender, OnSmsPriceCurrencyArgs e);
    
    internal void OnSmsPriceCurrencyInNewThread(object o)
    {
        OnSmsPriceCurrencyArgs e = (OnSmsPriceCurrencyArgs)o;
        OnSmsPriceCurrency(e.sender, e);
    }
    
    internal void FireOnSmsPriceCurrency(SktSms sender, String value)
    {
        if (OnSmsPriceCurrency == null) return; // Event not assigned    
        OnSmsPriceCurrencyArgs args = new OnSmsPriceCurrencyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsPriceCurrencyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsPriceCurrency, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsReplyToNumberArgs : EventArgs
    {
        public SktSms sender;
        public String value;
        public OnSmsReplyToNumberArgs(SktSms sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsReplyToNumberHandler OnSmsReplyToNumber;    
    public delegate void OnSmsReplyToNumberHandler (SktSms sender, OnSmsReplyToNumberArgs e);
    
    internal void OnSmsReplyToNumberInNewThread(object o)
    {
        OnSmsReplyToNumberArgs e = (OnSmsReplyToNumberArgs)o;
        OnSmsReplyToNumber(e.sender, e);
    }
    
    internal void FireOnSmsReplyToNumber(SktSms sender, String value)
    {
        if (OnSmsReplyToNumber == null) return; // Event not assigned    
        OnSmsReplyToNumberArgs args = new OnSmsReplyToNumberArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsReplyToNumberInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsReplyToNumber, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsTargetNumbersArgs : EventArgs
    {
        public SktSms sender;
        public String value;
        public OnSmsTargetNumbersArgs(SktSms sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsTargetNumbersHandler OnSmsTargetNumbers;    
    public delegate void OnSmsTargetNumbersHandler (SktSms sender, OnSmsTargetNumbersArgs e);
    
    internal void OnSmsTargetNumbersInNewThread(object o)
    {
        OnSmsTargetNumbersArgs e = (OnSmsTargetNumbersArgs)o;
        OnSmsTargetNumbers(e.sender, e);
    }
    
    internal void FireOnSmsTargetNumbers(SktSms sender, String value)
    {
        if (OnSmsTargetNumbers == null) return; // Event not assigned    
        OnSmsTargetNumbersArgs args = new OnSmsTargetNumbersArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsTargetNumbersInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsTargetNumbers, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsTargetStatusesArgs : EventArgs
    {
        public SktSms sender;
        public byte[] value;
        public OnSmsTargetStatusesArgs(SktSms sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsTargetStatusesHandler OnSmsTargetStatuses;    
    public delegate void OnSmsTargetStatusesHandler (SktSms sender, OnSmsTargetStatusesArgs e);
    
    internal void OnSmsTargetStatusesInNewThread(object o)
    {
        OnSmsTargetStatusesArgs e = (OnSmsTargetStatusesArgs)o;
        OnSmsTargetStatuses(e.sender, e);
    }
    
    internal void FireOnSmsTargetStatuses(SktSms sender, byte[] value)
    {
        if (OnSmsTargetStatuses == null) return; // Event not assigned    
        OnSmsTargetStatusesArgs args = new OnSmsTargetStatusesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsTargetStatusesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsTargetStatuses, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsBodyArgs : EventArgs
    {
        public SktSms sender;
        public String value;
        public OnSmsBodyArgs(SktSms sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsBodyHandler OnSmsBody;    
    public delegate void OnSmsBodyHandler (SktSms sender, OnSmsBodyArgs e);
    
    internal void OnSmsBodyInNewThread(object o)
    {
        OnSmsBodyArgs e = (OnSmsBodyArgs)o;
        OnSmsBody(e.sender, e);
    }
    
    internal void FireOnSmsBody(SktSms sender, String value)
    {
        if (OnSmsBody == null) return; // Event not assigned    
        OnSmsBodyArgs args = new OnSmsBodyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsBodyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsBody, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnSmsChatmsgIdArgs : EventArgs
    {
        public SktSms sender;
        public SktMessage value;
        public OnSmsChatmsgIdArgs(SktSms sender, SktMessage newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnSmsChatmsgIdHandler OnSmsChatmsgId;    
    public delegate void OnSmsChatmsgIdHandler (SktSms sender, OnSmsChatmsgIdArgs e);
    
    internal void OnSmsChatmsgIdInNewThread(object o)
    {
        OnSmsChatmsgIdArgs e = (OnSmsChatmsgIdArgs)o;
        OnSmsChatmsgId(e.sender, e);
    }
    
    internal void FireOnSmsChatmsgId(SktSms sender, SktMessage value)
    {
        if (OnSmsChatmsgId == null) return; // Event not assigned    
        OnSmsChatmsgIdArgs args = new OnSmsChatmsgIdArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnSmsChatmsgIdInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnSmsChatmsgId, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountStatusArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.STATUS value;
        public OnAccountStatusArgs(SktAccount sender, SktAccount.STATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountStatusHandler OnAccountStatus;    
    public delegate void OnAccountStatusHandler (SktAccount sender, OnAccountStatusArgs e);
    
    internal void OnAccountStatusInNewThread(object o)
    {
        OnAccountStatusArgs e = (OnAccountStatusArgs)o;
        OnAccountStatus(e.sender, e);
    }
    
    internal void FireOnAccountStatus(SktAccount sender, SktAccount.STATUS value)
    {
        if (OnAccountStatus == null) return; // Event not assigned    
        OnAccountStatusArgs args = new OnAccountStatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountStatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountStatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPwdchangestatusArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.PWDCHANGESTATUS value;
        public OnAccountPwdchangestatusArgs(SktAccount sender, SktAccount.PWDCHANGESTATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPwdchangestatusHandler OnAccountPwdchangestatus;    
    public delegate void OnAccountPwdchangestatusHandler (SktAccount sender, OnAccountPwdchangestatusArgs e);
    
    internal void OnAccountPwdchangestatusInNewThread(object o)
    {
        OnAccountPwdchangestatusArgs e = (OnAccountPwdchangestatusArgs)o;
        OnAccountPwdchangestatus(e.sender, e);
    }
    
    internal void FireOnAccountPwdchangestatus(SktAccount sender, SktAccount.PWDCHANGESTATUS value)
    {
        if (OnAccountPwdchangestatus == null) return; // Event not assigned    
        OnAccountPwdchangestatusArgs args = new OnAccountPwdchangestatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPwdchangestatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPwdchangestatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountLogoutreasonArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.LOGOUTREASON value;
        public OnAccountLogoutreasonArgs(SktAccount sender, SktAccount.LOGOUTREASON newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountLogoutreasonHandler OnAccountLogoutreason;    
    public delegate void OnAccountLogoutreasonHandler (SktAccount sender, OnAccountLogoutreasonArgs e);
    
    internal void OnAccountLogoutreasonInNewThread(object o)
    {
        OnAccountLogoutreasonArgs e = (OnAccountLogoutreasonArgs)o;
        OnAccountLogoutreason(e.sender, e);
    }
    
    internal void FireOnAccountLogoutreason(SktAccount sender, SktAccount.LOGOUTREASON value)
    {
        if (OnAccountLogoutreason == null) return; // Event not assigned    
        OnAccountLogoutreasonArgs args = new OnAccountLogoutreasonArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountLogoutreasonInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountLogoutreason, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountCommitstatusArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.COMMITSTATUS value;
        public OnAccountCommitstatusArgs(SktAccount sender, SktAccount.COMMITSTATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountCommitstatusHandler OnAccountCommitstatus;    
    public delegate void OnAccountCommitstatusHandler (SktAccount sender, OnAccountCommitstatusArgs e);
    
    internal void OnAccountCommitstatusInNewThread(object o)
    {
        OnAccountCommitstatusArgs e = (OnAccountCommitstatusArgs)o;
        OnAccountCommitstatus(e.sender, e);
    }
    
    internal void FireOnAccountCommitstatus(SktAccount sender, SktAccount.COMMITSTATUS value)
    {
        if (OnAccountCommitstatus == null) return; // Event not assigned    
        OnAccountCommitstatusArgs args = new OnAccountCommitstatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountCommitstatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountCommitstatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSuggestedSkypenameArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountSuggestedSkypenameArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSuggestedSkypenameHandler OnAccountSuggestedSkypename;    
    public delegate void OnAccountSuggestedSkypenameHandler (SktAccount sender, OnAccountSuggestedSkypenameArgs e);
    
    internal void OnAccountSuggestedSkypenameInNewThread(object o)
    {
        OnAccountSuggestedSkypenameArgs e = (OnAccountSuggestedSkypenameArgs)o;
        OnAccountSuggestedSkypename(e.sender, e);
    }
    
    internal void FireOnAccountSuggestedSkypename(SktAccount sender, String value)
    {
        if (OnAccountSuggestedSkypename == null) return; // Event not assigned    
        OnAccountSuggestedSkypenameArgs args = new OnAccountSuggestedSkypenameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSuggestedSkypenameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSuggestedSkypename, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypeoutBalanceCurrencyArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountSkypeoutBalanceCurrencyArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypeoutBalanceCurrencyHandler OnAccountSkypeoutBalanceCurrency;    
    public delegate void OnAccountSkypeoutBalanceCurrencyHandler (SktAccount sender, OnAccountSkypeoutBalanceCurrencyArgs e);
    
    internal void OnAccountSkypeoutBalanceCurrencyInNewThread(object o)
    {
        OnAccountSkypeoutBalanceCurrencyArgs e = (OnAccountSkypeoutBalanceCurrencyArgs)o;
        OnAccountSkypeoutBalanceCurrency(e.sender, e);
    }
    
    internal void FireOnAccountSkypeoutBalanceCurrency(SktAccount sender, String value)
    {
        if (OnAccountSkypeoutBalanceCurrency == null) return; // Event not assigned    
        OnAccountSkypeoutBalanceCurrencyArgs args = new OnAccountSkypeoutBalanceCurrencyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypeoutBalanceCurrencyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypeoutBalanceCurrency, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypeoutBalanceArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountSkypeoutBalanceArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypeoutBalanceHandler OnAccountSkypeoutBalance;    
    public delegate void OnAccountSkypeoutBalanceHandler (SktAccount sender, OnAccountSkypeoutBalanceArgs e);
    
    internal void OnAccountSkypeoutBalanceInNewThread(object o)
    {
        OnAccountSkypeoutBalanceArgs e = (OnAccountSkypeoutBalanceArgs)o;
        OnAccountSkypeoutBalance(e.sender, e);
    }
    
    internal void FireOnAccountSkypeoutBalance(SktAccount sender, uint value)
    {
        if (OnAccountSkypeoutBalance == null) return; // Event not assigned    
        OnAccountSkypeoutBalanceArgs args = new OnAccountSkypeoutBalanceArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypeoutBalanceInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypeoutBalance, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypeoutPrecisionArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountSkypeoutPrecisionArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypeoutPrecisionHandler OnAccountSkypeoutPrecision;    
    public delegate void OnAccountSkypeoutPrecisionHandler (SktAccount sender, OnAccountSkypeoutPrecisionArgs e);
    
    internal void OnAccountSkypeoutPrecisionInNewThread(object o)
    {
        OnAccountSkypeoutPrecisionArgs e = (OnAccountSkypeoutPrecisionArgs)o;
        OnAccountSkypeoutPrecision(e.sender, e);
    }
    
    internal void FireOnAccountSkypeoutPrecision(SktAccount sender, uint value)
    {
        if (OnAccountSkypeoutPrecision == null) return; // Event not assigned    
        OnAccountSkypeoutPrecisionArgs args = new OnAccountSkypeoutPrecisionArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypeoutPrecisionInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypeoutPrecision, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypeinNumbersArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountSkypeinNumbersArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypeinNumbersHandler OnAccountSkypeinNumbers;    
    public delegate void OnAccountSkypeinNumbersHandler (SktAccount sender, OnAccountSkypeinNumbersArgs e);
    
    internal void OnAccountSkypeinNumbersInNewThread(object o)
    {
        OnAccountSkypeinNumbersArgs e = (OnAccountSkypeinNumbersArgs)o;
        OnAccountSkypeinNumbers(e.sender, e);
    }
    
    internal void FireOnAccountSkypeinNumbers(SktAccount sender, String value)
    {
        if (OnAccountSkypeinNumbers == null) return; // Event not assigned    
        OnAccountSkypeinNumbersArgs args = new OnAccountSkypeinNumbersArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypeinNumbersInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypeinNumbers, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountCblsyncstatusArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.CBLSYNCSTATUS value;
        public OnAccountCblsyncstatusArgs(SktAccount sender, SktAccount.CBLSYNCSTATUS newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountCblsyncstatusHandler OnAccountCblsyncstatus;    
    public delegate void OnAccountCblsyncstatusHandler (SktAccount sender, OnAccountCblsyncstatusArgs e);
    
    internal void OnAccountCblsyncstatusInNewThread(object o)
    {
        OnAccountCblsyncstatusArgs e = (OnAccountCblsyncstatusArgs)o;
        OnAccountCblsyncstatus(e.sender, e);
    }
    
    internal void FireOnAccountCblsyncstatus(SktAccount sender, SktAccount.CBLSYNCSTATUS value)
    {
        if (OnAccountCblsyncstatus == null) return; // Event not assigned    
        OnAccountCblsyncstatusArgs args = new OnAccountCblsyncstatusArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountCblsyncstatusInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountCblsyncstatus, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountOfflineCallforwardArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountOfflineCallforwardArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountOfflineCallforwardHandler OnAccountOfflineCallforward;    
    public delegate void OnAccountOfflineCallforwardHandler (SktAccount sender, OnAccountOfflineCallforwardArgs e);
    
    internal void OnAccountOfflineCallforwardInNewThread(object o)
    {
        OnAccountOfflineCallforwardArgs e = (OnAccountOfflineCallforwardArgs)o;
        OnAccountOfflineCallforward(e.sender, e);
    }
    
    internal void FireOnAccountOfflineCallforward(SktAccount sender, String value)
    {
        if (OnAccountOfflineCallforward == null) return; // Event not assigned    
        OnAccountOfflineCallforwardArgs args = new OnAccountOfflineCallforwardArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountOfflineCallforwardInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountOfflineCallforward, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountChatPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.CHATPOLICY value;
        public OnAccountChatPolicyArgs(SktAccount sender, SktAccount.CHATPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountChatPolicyHandler OnAccountChatPolicy;    
    public delegate void OnAccountChatPolicyHandler (SktAccount sender, OnAccountChatPolicyArgs e);
    
    internal void OnAccountChatPolicyInNewThread(object o)
    {
        OnAccountChatPolicyArgs e = (OnAccountChatPolicyArgs)o;
        OnAccountChatPolicy(e.sender, e);
    }
    
    internal void FireOnAccountChatPolicy(SktAccount sender, SktAccount.CHATPOLICY value)
    {
        if (OnAccountChatPolicy == null) return; // Event not assigned    
        OnAccountChatPolicyArgs args = new OnAccountChatPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountChatPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountChatPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypeCallPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.SKYPECALLPOLICY value;
        public OnAccountSkypeCallPolicyArgs(SktAccount sender, SktAccount.SKYPECALLPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypeCallPolicyHandler OnAccountSkypeCallPolicy;    
    public delegate void OnAccountSkypeCallPolicyHandler (SktAccount sender, OnAccountSkypeCallPolicyArgs e);
    
    internal void OnAccountSkypeCallPolicyInNewThread(object o)
    {
        OnAccountSkypeCallPolicyArgs e = (OnAccountSkypeCallPolicyArgs)o;
        OnAccountSkypeCallPolicy(e.sender, e);
    }
    
    internal void FireOnAccountSkypeCallPolicy(SktAccount sender, SktAccount.SKYPECALLPOLICY value)
    {
        if (OnAccountSkypeCallPolicy == null) return; // Event not assigned    
        OnAccountSkypeCallPolicyArgs args = new OnAccountSkypeCallPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypeCallPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypeCallPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPstnCallPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.PSTNCALLPOLICY value;
        public OnAccountPstnCallPolicyArgs(SktAccount sender, SktAccount.PSTNCALLPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPstnCallPolicyHandler OnAccountPstnCallPolicy;    
    public delegate void OnAccountPstnCallPolicyHandler (SktAccount sender, OnAccountPstnCallPolicyArgs e);
    
    internal void OnAccountPstnCallPolicyInNewThread(object o)
    {
        OnAccountPstnCallPolicyArgs e = (OnAccountPstnCallPolicyArgs)o;
        OnAccountPstnCallPolicy(e.sender, e);
    }
    
    internal void FireOnAccountPstnCallPolicy(SktAccount sender, SktAccount.PSTNCALLPOLICY value)
    {
        if (OnAccountPstnCallPolicy == null) return; // Event not assigned    
        OnAccountPstnCallPolicyArgs args = new OnAccountPstnCallPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPstnCallPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPstnCallPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountAvatarPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.AVATARPOLICY value;
        public OnAccountAvatarPolicyArgs(SktAccount sender, SktAccount.AVATARPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountAvatarPolicyHandler OnAccountAvatarPolicy;    
    public delegate void OnAccountAvatarPolicyHandler (SktAccount sender, OnAccountAvatarPolicyArgs e);
    
    internal void OnAccountAvatarPolicyInNewThread(object o)
    {
        OnAccountAvatarPolicyArgs e = (OnAccountAvatarPolicyArgs)o;
        OnAccountAvatarPolicy(e.sender, e);
    }
    
    internal void FireOnAccountAvatarPolicy(SktAccount sender, SktAccount.AVATARPOLICY value)
    {
        if (OnAccountAvatarPolicy == null) return; // Event not assigned    
        OnAccountAvatarPolicyArgs args = new OnAccountAvatarPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountAvatarPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountAvatarPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountBuddycountPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.BUDDYCOUNTPOLICY value;
        public OnAccountBuddycountPolicyArgs(SktAccount sender, SktAccount.BUDDYCOUNTPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountBuddycountPolicyHandler OnAccountBuddycountPolicy;    
    public delegate void OnAccountBuddycountPolicyHandler (SktAccount sender, OnAccountBuddycountPolicyArgs e);
    
    internal void OnAccountBuddycountPolicyInNewThread(object o)
    {
        OnAccountBuddycountPolicyArgs e = (OnAccountBuddycountPolicyArgs)o;
        OnAccountBuddycountPolicy(e.sender, e);
    }
    
    internal void FireOnAccountBuddycountPolicy(SktAccount sender, SktAccount.BUDDYCOUNTPOLICY value)
    {
        if (OnAccountBuddycountPolicy == null) return; // Event not assigned    
        OnAccountBuddycountPolicyArgs args = new OnAccountBuddycountPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountBuddycountPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountBuddycountPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountTimezonePolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.TIMEZONEPOLICY value;
        public OnAccountTimezonePolicyArgs(SktAccount sender, SktAccount.TIMEZONEPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountTimezonePolicyHandler OnAccountTimezonePolicy;    
    public delegate void OnAccountTimezonePolicyHandler (SktAccount sender, OnAccountTimezonePolicyArgs e);
    
    internal void OnAccountTimezonePolicyInNewThread(object o)
    {
        OnAccountTimezonePolicyArgs e = (OnAccountTimezonePolicyArgs)o;
        OnAccountTimezonePolicy(e.sender, e);
    }
    
    internal void FireOnAccountTimezonePolicy(SktAccount sender, SktAccount.TIMEZONEPOLICY value)
    {
        if (OnAccountTimezonePolicy == null) return; // Event not assigned    
        OnAccountTimezonePolicyArgs args = new OnAccountTimezonePolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountTimezonePolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountTimezonePolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountWebpresencePolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.WEBPRESENCEPOLICY value;
        public OnAccountWebpresencePolicyArgs(SktAccount sender, SktAccount.WEBPRESENCEPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountWebpresencePolicyHandler OnAccountWebpresencePolicy;    
    public delegate void OnAccountWebpresencePolicyHandler (SktAccount sender, OnAccountWebpresencePolicyArgs e);
    
    internal void OnAccountWebpresencePolicyInNewThread(object o)
    {
        OnAccountWebpresencePolicyArgs e = (OnAccountWebpresencePolicyArgs)o;
        OnAccountWebpresencePolicy(e.sender, e);
    }
    
    internal void FireOnAccountWebpresencePolicy(SktAccount sender, SktAccount.WEBPRESENCEPOLICY value)
    {
        if (OnAccountWebpresencePolicy == null) return; // Event not assigned    
        OnAccountWebpresencePolicyArgs args = new OnAccountWebpresencePolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountWebpresencePolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountWebpresencePolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPhonenumbersPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.PHONENUMBERSPOLICY value;
        public OnAccountPhonenumbersPolicyArgs(SktAccount sender, SktAccount.PHONENUMBERSPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPhonenumbersPolicyHandler OnAccountPhonenumbersPolicy;    
    public delegate void OnAccountPhonenumbersPolicyHandler (SktAccount sender, OnAccountPhonenumbersPolicyArgs e);
    
    internal void OnAccountPhonenumbersPolicyInNewThread(object o)
    {
        OnAccountPhonenumbersPolicyArgs e = (OnAccountPhonenumbersPolicyArgs)o;
        OnAccountPhonenumbersPolicy(e.sender, e);
    }
    
    internal void FireOnAccountPhonenumbersPolicy(SktAccount sender, SktAccount.PHONENUMBERSPOLICY value)
    {
        if (OnAccountPhonenumbersPolicy == null) return; // Event not assigned    
        OnAccountPhonenumbersPolicyArgs args = new OnAccountPhonenumbersPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPhonenumbersPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPhonenumbersPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountVoicemailPolicyArgs : EventArgs
    {
        public SktAccount sender;
        public SktAccount.VOICEMAILPOLICY value;
        public OnAccountVoicemailPolicyArgs(SktAccount sender, SktAccount.VOICEMAILPOLICY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountVoicemailPolicyHandler OnAccountVoicemailPolicy;    
    public delegate void OnAccountVoicemailPolicyHandler (SktAccount sender, OnAccountVoicemailPolicyArgs e);
    
    internal void OnAccountVoicemailPolicyInNewThread(object o)
    {
        OnAccountVoicemailPolicyArgs e = (OnAccountVoicemailPolicyArgs)o;
        OnAccountVoicemailPolicy(e.sender, e);
    }
    
    internal void FireOnAccountVoicemailPolicy(SktAccount sender, SktAccount.VOICEMAILPOLICY value)
    {
        if (OnAccountVoicemailPolicy == null) return; // Event not assigned    
        OnAccountVoicemailPolicyArgs args = new OnAccountVoicemailPolicyArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountVoicemailPolicyInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountVoicemailPolicy, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPartnerOptedoutArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountPartnerOptedoutArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPartnerOptedoutHandler OnAccountPartnerOptedout;    
    public delegate void OnAccountPartnerOptedoutHandler (SktAccount sender, OnAccountPartnerOptedoutArgs e);
    
    internal void OnAccountPartnerOptedoutInNewThread(object o)
    {
        OnAccountPartnerOptedoutArgs e = (OnAccountPartnerOptedoutArgs)o;
        OnAccountPartnerOptedout(e.sender, e);
    }
    
    internal void FireOnAccountPartnerOptedout(SktAccount sender, String value)
    {
        if (OnAccountPartnerOptedout == null) return; // Event not assigned    
        OnAccountPartnerOptedoutArgs args = new OnAccountPartnerOptedoutArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPartnerOptedoutInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPartnerOptedout, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountServiceProviderInfoArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountServiceProviderInfoArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountServiceProviderInfoHandler OnAccountServiceProviderInfo;    
    public delegate void OnAccountServiceProviderInfoHandler (SktAccount sender, OnAccountServiceProviderInfoArgs e);
    
    internal void OnAccountServiceProviderInfoInNewThread(object o)
    {
        OnAccountServiceProviderInfoArgs e = (OnAccountServiceProviderInfoArgs)o;
        OnAccountServiceProviderInfo(e.sender, e);
    }
    
    internal void FireOnAccountServiceProviderInfo(SktAccount sender, String value)
    {
        if (OnAccountServiceProviderInfo == null) return; // Event not assigned    
        OnAccountServiceProviderInfoArgs args = new OnAccountServiceProviderInfoArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountServiceProviderInfoInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountServiceProviderInfo, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountRegistrationTimestampArgs : EventArgs
    {
        public SktAccount sender;
        public DateTime value;
        public OnAccountRegistrationTimestampArgs(SktAccount sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountRegistrationTimestampHandler OnAccountRegistrationTimestamp;    
    public delegate void OnAccountRegistrationTimestampHandler (SktAccount sender, OnAccountRegistrationTimestampArgs e);
    
    internal void OnAccountRegistrationTimestampInNewThread(object o)
    {
        OnAccountRegistrationTimestampArgs e = (OnAccountRegistrationTimestampArgs)o;
        OnAccountRegistrationTimestamp(e.sender, e);
    }
    
    internal void FireOnAccountRegistrationTimestamp(SktAccount sender, DateTime value)
    {
        if (OnAccountRegistrationTimestamp == null) return; // Event not assigned    
        OnAccountRegistrationTimestampArgs args = new OnAccountRegistrationTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountRegistrationTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountRegistrationTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountNrOfOtherInstancesArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountNrOfOtherInstancesArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountNrOfOtherInstancesHandler OnAccountNrOfOtherInstances;    
    public delegate void OnAccountNrOfOtherInstancesHandler (SktAccount sender, OnAccountNrOfOtherInstancesArgs e);
    
    internal void OnAccountNrOfOtherInstancesInNewThread(object o)
    {
        OnAccountNrOfOtherInstancesArgs e = (OnAccountNrOfOtherInstancesArgs)o;
        OnAccountNrOfOtherInstances(e.sender, e);
    }
    
    internal void FireOnAccountNrOfOtherInstances(SktAccount sender, uint value)
    {
        if (OnAccountNrOfOtherInstances == null) return; // Event not assigned    
        OnAccountNrOfOtherInstancesArgs args = new OnAccountNrOfOtherInstancesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountNrOfOtherInstancesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountNrOfOtherInstances, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountSkypenameArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountSkypenameArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountSkypenameHandler OnAccountSkypename;    
    public delegate void OnAccountSkypenameHandler (SktAccount sender, OnAccountSkypenameArgs e);
    
    internal void OnAccountSkypenameInNewThread(object o)
    {
        OnAccountSkypenameArgs e = (OnAccountSkypenameArgs)o;
        OnAccountSkypename(e.sender, e);
    }
    
    internal void FireOnAccountSkypename(SktAccount sender, String value)
    {
        if (OnAccountSkypename == null) return; // Event not assigned    
        OnAccountSkypenameArgs args = new OnAccountSkypenameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountSkypenameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountSkypename, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountFullnameArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountFullnameArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountFullnameHandler OnAccountFullname;    
    public delegate void OnAccountFullnameHandler (SktAccount sender, OnAccountFullnameArgs e);
    
    internal void OnAccountFullnameInNewThread(object o)
    {
        OnAccountFullnameArgs e = (OnAccountFullnameArgs)o;
        OnAccountFullname(e.sender, e);
    }
    
    internal void FireOnAccountFullname(SktAccount sender, String value)
    {
        if (OnAccountFullname == null) return; // Event not assigned    
        OnAccountFullnameArgs args = new OnAccountFullnameArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountFullnameInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountFullname, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountBirthdayArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountBirthdayArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountBirthdayHandler OnAccountBirthday;    
    public delegate void OnAccountBirthdayHandler (SktAccount sender, OnAccountBirthdayArgs e);
    
    internal void OnAccountBirthdayInNewThread(object o)
    {
        OnAccountBirthdayArgs e = (OnAccountBirthdayArgs)o;
        OnAccountBirthday(e.sender, e);
    }
    
    internal void FireOnAccountBirthday(SktAccount sender, uint value)
    {
        if (OnAccountBirthday == null) return; // Event not assigned    
        OnAccountBirthdayArgs args = new OnAccountBirthdayArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountBirthdayInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountBirthday, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountGenderArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountGenderArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountGenderHandler OnAccountGender;    
    public delegate void OnAccountGenderHandler (SktAccount sender, OnAccountGenderArgs e);
    
    internal void OnAccountGenderInNewThread(object o)
    {
        OnAccountGenderArgs e = (OnAccountGenderArgs)o;
        OnAccountGender(e.sender, e);
    }
    
    internal void FireOnAccountGender(SktAccount sender, uint value)
    {
        if (OnAccountGender == null) return; // Event not assigned    
        OnAccountGenderArgs args = new OnAccountGenderArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountGenderInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountGender, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountLanguagesArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountLanguagesArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountLanguagesHandler OnAccountLanguages;    
    public delegate void OnAccountLanguagesHandler (SktAccount sender, OnAccountLanguagesArgs e);
    
    internal void OnAccountLanguagesInNewThread(object o)
    {
        OnAccountLanguagesArgs e = (OnAccountLanguagesArgs)o;
        OnAccountLanguages(e.sender, e);
    }
    
    internal void FireOnAccountLanguages(SktAccount sender, String value)
    {
        if (OnAccountLanguages == null) return; // Event not assigned    
        OnAccountLanguagesArgs args = new OnAccountLanguagesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountLanguagesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountLanguages, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountCountryArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountCountryArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountCountryHandler OnAccountCountry;    
    public delegate void OnAccountCountryHandler (SktAccount sender, OnAccountCountryArgs e);
    
    internal void OnAccountCountryInNewThread(object o)
    {
        OnAccountCountryArgs e = (OnAccountCountryArgs)o;
        OnAccountCountry(e.sender, e);
    }
    
    internal void FireOnAccountCountry(SktAccount sender, String value)
    {
        if (OnAccountCountry == null) return; // Event not assigned    
        OnAccountCountryArgs args = new OnAccountCountryArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountCountryInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountCountry, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountProvinceArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountProvinceArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountProvinceHandler OnAccountProvince;    
    public delegate void OnAccountProvinceHandler (SktAccount sender, OnAccountProvinceArgs e);
    
    internal void OnAccountProvinceInNewThread(object o)
    {
        OnAccountProvinceArgs e = (OnAccountProvinceArgs)o;
        OnAccountProvince(e.sender, e);
    }
    
    internal void FireOnAccountProvince(SktAccount sender, String value)
    {
        if (OnAccountProvince == null) return; // Event not assigned    
        OnAccountProvinceArgs args = new OnAccountProvinceArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountProvinceInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountProvince, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountCityArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountCityArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountCityHandler OnAccountCity;    
    public delegate void OnAccountCityHandler (SktAccount sender, OnAccountCityArgs e);
    
    internal void OnAccountCityInNewThread(object o)
    {
        OnAccountCityArgs e = (OnAccountCityArgs)o;
        OnAccountCity(e.sender, e);
    }
    
    internal void FireOnAccountCity(SktAccount sender, String value)
    {
        if (OnAccountCity == null) return; // Event not assigned    
        OnAccountCityArgs args = new OnAccountCityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountCityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountCity, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPhoneHomeArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountPhoneHomeArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPhoneHomeHandler OnAccountPhoneHome;    
    public delegate void OnAccountPhoneHomeHandler (SktAccount sender, OnAccountPhoneHomeArgs e);
    
    internal void OnAccountPhoneHomeInNewThread(object o)
    {
        OnAccountPhoneHomeArgs e = (OnAccountPhoneHomeArgs)o;
        OnAccountPhoneHome(e.sender, e);
    }
    
    internal void FireOnAccountPhoneHome(SktAccount sender, String value)
    {
        if (OnAccountPhoneHome == null) return; // Event not assigned    
        OnAccountPhoneHomeArgs args = new OnAccountPhoneHomeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPhoneHomeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPhoneHome, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPhoneOfficeArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountPhoneOfficeArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPhoneOfficeHandler OnAccountPhoneOffice;    
    public delegate void OnAccountPhoneOfficeHandler (SktAccount sender, OnAccountPhoneOfficeArgs e);
    
    internal void OnAccountPhoneOfficeInNewThread(object o)
    {
        OnAccountPhoneOfficeArgs e = (OnAccountPhoneOfficeArgs)o;
        OnAccountPhoneOffice(e.sender, e);
    }
    
    internal void FireOnAccountPhoneOffice(SktAccount sender, String value)
    {
        if (OnAccountPhoneOffice == null) return; // Event not assigned    
        OnAccountPhoneOfficeArgs args = new OnAccountPhoneOfficeArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPhoneOfficeInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPhoneOffice, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountPhoneMobileArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountPhoneMobileArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountPhoneMobileHandler OnAccountPhoneMobile;    
    public delegate void OnAccountPhoneMobileHandler (SktAccount sender, OnAccountPhoneMobileArgs e);
    
    internal void OnAccountPhoneMobileInNewThread(object o)
    {
        OnAccountPhoneMobileArgs e = (OnAccountPhoneMobileArgs)o;
        OnAccountPhoneMobile(e.sender, e);
    }
    
    internal void FireOnAccountPhoneMobile(SktAccount sender, String value)
    {
        if (OnAccountPhoneMobile == null) return; // Event not assigned    
        OnAccountPhoneMobileArgs args = new OnAccountPhoneMobileArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountPhoneMobileInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountPhoneMobile, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountEmailsArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountEmailsArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountEmailsHandler OnAccountEmails;    
    public delegate void OnAccountEmailsHandler (SktAccount sender, OnAccountEmailsArgs e);
    
    internal void OnAccountEmailsInNewThread(object o)
    {
        OnAccountEmailsArgs e = (OnAccountEmailsArgs)o;
        OnAccountEmails(e.sender, e);
    }
    
    internal void FireOnAccountEmails(SktAccount sender, String value)
    {
        if (OnAccountEmails == null) return; // Event not assigned    
        OnAccountEmailsArgs args = new OnAccountEmailsArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountEmailsInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountEmails, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountHomepageArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountHomepageArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountHomepageHandler OnAccountHomepage;    
    public delegate void OnAccountHomepageHandler (SktAccount sender, OnAccountHomepageArgs e);
    
    internal void OnAccountHomepageInNewThread(object o)
    {
        OnAccountHomepageArgs e = (OnAccountHomepageArgs)o;
        OnAccountHomepage(e.sender, e);
    }
    
    internal void FireOnAccountHomepage(SktAccount sender, String value)
    {
        if (OnAccountHomepage == null) return; // Event not assigned    
        OnAccountHomepageArgs args = new OnAccountHomepageArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountHomepageInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountHomepage, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountAboutArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountAboutArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountAboutHandler OnAccountAbout;    
    public delegate void OnAccountAboutHandler (SktAccount sender, OnAccountAboutArgs e);
    
    internal void OnAccountAboutInNewThread(object o)
    {
        OnAccountAboutArgs e = (OnAccountAboutArgs)o;
        OnAccountAbout(e.sender, e);
    }
    
    internal void FireOnAccountAbout(SktAccount sender, String value)
    {
        if (OnAccountAbout == null) return; // Event not assigned    
        OnAccountAboutArgs args = new OnAccountAboutArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountAboutInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountAbout, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountProfileTimestampArgs : EventArgs
    {
        public SktAccount sender;
        public DateTime value;
        public OnAccountProfileTimestampArgs(SktAccount sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountProfileTimestampHandler OnAccountProfileTimestamp;    
    public delegate void OnAccountProfileTimestampHandler (SktAccount sender, OnAccountProfileTimestampArgs e);
    
    internal void OnAccountProfileTimestampInNewThread(object o)
    {
        OnAccountProfileTimestampArgs e = (OnAccountProfileTimestampArgs)o;
        OnAccountProfileTimestamp(e.sender, e);
    }
    
    internal void FireOnAccountProfileTimestamp(SktAccount sender, DateTime value)
    {
        if (OnAccountProfileTimestamp == null) return; // Event not assigned    
        OnAccountProfileTimestampArgs args = new OnAccountProfileTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountProfileTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountProfileTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountMoodTextArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountMoodTextArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountMoodTextHandler OnAccountMoodText;    
    public delegate void OnAccountMoodTextHandler (SktAccount sender, OnAccountMoodTextArgs e);
    
    internal void OnAccountMoodTextInNewThread(object o)
    {
        OnAccountMoodTextArgs e = (OnAccountMoodTextArgs)o;
        OnAccountMoodText(e.sender, e);
    }
    
    internal void FireOnAccountMoodText(SktAccount sender, String value)
    {
        if (OnAccountMoodText == null) return; // Event not assigned    
        OnAccountMoodTextArgs args = new OnAccountMoodTextArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountMoodTextInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountMoodText, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountTimezoneArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountTimezoneArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountTimezoneHandler OnAccountTimezone;    
    public delegate void OnAccountTimezoneHandler (SktAccount sender, OnAccountTimezoneArgs e);
    
    internal void OnAccountTimezoneInNewThread(object o)
    {
        OnAccountTimezoneArgs e = (OnAccountTimezoneArgs)o;
        OnAccountTimezone(e.sender, e);
    }
    
    internal void FireOnAccountTimezone(SktAccount sender, uint value)
    {
        if (OnAccountTimezone == null) return; // Event not assigned    
        OnAccountTimezoneArgs args = new OnAccountTimezoneArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountTimezoneInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountTimezone, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountNrofAuthedBuddiesArgs : EventArgs
    {
        public SktAccount sender;
        public uint value;
        public OnAccountNrofAuthedBuddiesArgs(SktAccount sender, uint newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountNrofAuthedBuddiesHandler OnAccountNrofAuthedBuddies;    
    public delegate void OnAccountNrofAuthedBuddiesHandler (SktAccount sender, OnAccountNrofAuthedBuddiesArgs e);
    
    internal void OnAccountNrofAuthedBuddiesInNewThread(object o)
    {
        OnAccountNrofAuthedBuddiesArgs e = (OnAccountNrofAuthedBuddiesArgs)o;
        OnAccountNrofAuthedBuddies(e.sender, e);
    }
    
    internal void FireOnAccountNrofAuthedBuddies(SktAccount sender, uint value)
    {
        if (OnAccountNrofAuthedBuddies == null) return; // Event not assigned    
        OnAccountNrofAuthedBuddiesArgs args = new OnAccountNrofAuthedBuddiesArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountNrofAuthedBuddiesInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountNrofAuthedBuddies, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountAvailabilityArgs : EventArgs
    {
        public SktAccount sender;
        public SktContact.AVAILABILITY value;
        public OnAccountAvailabilityArgs(SktAccount sender, SktContact.AVAILABILITY newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountAvailabilityHandler OnAccountAvailability;    
    public delegate void OnAccountAvailabilityHandler (SktAccount sender, OnAccountAvailabilityArgs e);
    
    internal void OnAccountAvailabilityInNewThread(object o)
    {
        OnAccountAvailabilityArgs e = (OnAccountAvailabilityArgs)o;
        OnAccountAvailability(e.sender, e);
    }
    
    internal void FireOnAccountAvailability(SktAccount sender, SktContact.AVAILABILITY value)
    {
        if (OnAccountAvailability == null) return; // Event not assigned    
        OnAccountAvailabilityArgs args = new OnAccountAvailabilityArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountAvailabilityInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountAvailability, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountAvatarImageArgs : EventArgs
    {
        public SktAccount sender;
        public byte[] value;
        public OnAccountAvatarImageArgs(SktAccount sender, byte[] newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountAvatarImageHandler OnAccountAvatarImage;    
    public delegate void OnAccountAvatarImageHandler (SktAccount sender, OnAccountAvatarImageArgs e);
    
    internal void OnAccountAvatarImageInNewThread(object o)
    {
        OnAccountAvatarImageArgs e = (OnAccountAvatarImageArgs)o;
        OnAccountAvatarImage(e.sender, e);
    }
    
    internal void FireOnAccountAvatarImage(SktAccount sender, byte[] value)
    {
        if (OnAccountAvatarImage == null) return; // Event not assigned    
        OnAccountAvatarImageArgs args = new OnAccountAvatarImageArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountAvatarImageInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountAvatarImage, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountAvatarTimestampArgs : EventArgs
    {
        public SktAccount sender;
        public DateTime value;
        public OnAccountAvatarTimestampArgs(SktAccount sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountAvatarTimestampHandler OnAccountAvatarTimestamp;    
    public delegate void OnAccountAvatarTimestampHandler (SktAccount sender, OnAccountAvatarTimestampArgs e);
    
    internal void OnAccountAvatarTimestampInNewThread(object o)
    {
        OnAccountAvatarTimestampArgs e = (OnAccountAvatarTimestampArgs)o;
        OnAccountAvatarTimestamp(e.sender, e);
    }
    
    internal void FireOnAccountAvatarTimestamp(SktAccount sender, DateTime value)
    {
        if (OnAccountAvatarTimestamp == null) return; // Event not assigned    
        OnAccountAvatarTimestampArgs args = new OnAccountAvatarTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountAvatarTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountAvatarTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountMoodTimestampArgs : EventArgs
    {
        public SktAccount sender;
        public DateTime value;
        public OnAccountMoodTimestampArgs(SktAccount sender, DateTime newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountMoodTimestampHandler OnAccountMoodTimestamp;    
    public delegate void OnAccountMoodTimestampHandler (SktAccount sender, OnAccountMoodTimestampArgs e);
    
    internal void OnAccountMoodTimestampInNewThread(object o)
    {
        OnAccountMoodTimestampArgs e = (OnAccountMoodTimestampArgs)o;
        OnAccountMoodTimestamp(e.sender, e);
    }
    
    internal void FireOnAccountMoodTimestamp(SktAccount sender, DateTime value)
    {
        if (OnAccountMoodTimestamp == null) return; // Event not assigned    
        OnAccountMoodTimestampArgs args = new OnAccountMoodTimestampArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountMoodTimestampInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountMoodTimestamp, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
    
    public class OnAccountRichMoodTextArgs : EventArgs
    {
        public SktAccount sender;
        public String value;
        public OnAccountRichMoodTextArgs(SktAccount sender, String newValue) { this.sender = sender;  value = newValue; }
    }
    
    public event OnAccountRichMoodTextHandler OnAccountRichMoodText;    
    public delegate void OnAccountRichMoodTextHandler (SktAccount sender, OnAccountRichMoodTextArgs e);
    
    internal void OnAccountRichMoodTextInNewThread(object o)
    {
        OnAccountRichMoodTextArgs e = (OnAccountRichMoodTextArgs)o;
        OnAccountRichMoodText(e.sender, e);
    }
    
    internal void FireOnAccountRichMoodText(SktAccount sender, String value)
    {
        if (OnAccountRichMoodText == null) return; // Event not assigned    
        OnAccountRichMoodTextArgs args = new OnAccountRichMoodTextArgs(sender, value);    
        if (gui == null) { FireCallbackInSeparateThread(args, OnAccountRichMoodTextInNewThread); return; } // No gui firing in separate thread
        gui.BeginInvoke(OnAccountRichMoodText, new object[] { sender, args }); // Syncing to GUI thread
    }    
    
}
/*! \class SktSetup
  \brief
  SkypeKit setupkeys. These can be read or written to with SktSkype GetInt, SetInt, GetStr, SetStr
  GetBin and SetBin methods. This is an abstract class and cannot be instantiated.
*/
public abstract class SktSetup
{
    /*! \class AccountBased
      \brief
      Account-based setup keys. These affect an account, wherever the account is logged in.
      They do not affect other accounts on the same machine. This is an abstract class and cannot be instantiated.
    */
    public abstract class AccountBased
    {
        /**  The number of seconds a formerly live conversation will remain the SktConversation.LIVE_CONVERSATIONS
          filter. Note that while the conversation remains in SktConversation.LIVE_CONVERSATIONS filter, SktSkype.OnConversationListChange
          events will not fire if there is another call coming up within the same conversation. Seeting this key
          to 0 will cause conversations to exit the SktConversation.LIVE_CONVERSATIONS list immediately, after
          live state drops. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string RECENTLY_LIVE_TIMEOUT = "Lib/Conversation/RecentlyLiveTimeout";
        
        /**  Full local path to save incoming file transfers (used for AutoAccept feature) This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string FT_SAVEPATH = "Lib/FileTransfer/SavePath";
        
        /**  Enables/disables birthday notification messages. @li 0 - disable; @li 1 - enable; This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string ENABLE_BIRTHDAY_NOTIFICATION = "Lib/Conversation/EnableBirthday";
        
        /**  Country code for emergency calls This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string CALL_EMERGENCY_COUNTRY = "Lib/Call/EmergencyCountry";
        
        /**  Disables chat (for voice only clients). This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_CHAT = "Lib/Chat/DisableChat";
        
        /**  Autoforwarding of incoming calls to voicemail. @li 0 - off @li 1 - on This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string CALL_SEND_TO_VM = "Lib/Call/SendToVM";
        
        /**  noone | contacts | callpolicy This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string VIDEO_RECVPOLICY = "Lib/Video/RecvPolicy";
        
        /**  Number of seconds since the last keyboard or mouse activity, after which the online status of currently
          logged in account should be set to AWAY. See SktAccount.SetAvailability method for more information.
          This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string IDLE_TIME_FOR_AWAY = "Lib/Account/IdleTimeForAway";
        
        /**  Time limit for keeping local chat message history. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string CHAT_HISTORY_DAYS = "Lib/Chat/HistoryDays";
        
        /**  Controls file transfer auto-accept. @li 0 - off @li 1 - on This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string FT_AUTOACCEPT = "Lib/FileTransfer/AutoAccept";
        
        /**  Selected video device name This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string VIDEO_DEVICE = "Lib/Video/Device";
        
        /**  The SktContact.AVAILABILITY.NOT_AVAILABLE online status has been deprecated. This setup key is no longer
          in use.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string IDLE_TIME_FOR_NA = "Lib/Account/IdleTimeForNA";
        
        /**  noone | contacts | everyone This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string VIDEO_ADVERTPOLICY = "Lib/Video/AdvertPolicy";
        
        /**  Number of simultaneous incoming file transfers (per user). Value 0 means no limitation. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>uint</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string FT_INCOMING_LIMIT = "Lib/FileTransfer/IncomingLimit";
        
        /**  Timeout in seconds after which the incoming live session will stop ringing (and if possible, proceed
          to voicemail or call forward). This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string CALL_NOANSWER_TIMEOUT = "Lib/Call/NoAnswerTimeout";
        
        /**  Timeout in seconds, how old the SktConversation.P_INBOX_TIMESTAMP has to be for it to be re-sorted in
          the inbox. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string INBOX_UPDATE_TIMEOUT = "Lib/Conversation/InboxUpdateTimeout";
        
        /**  Enables/disables transmitting typing indicator signals to othe participants of conversations. @li 0 -
          disable; @li 1 - enable; This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_CHAT_ACTIVITY_INDICATION = "Lib/Chat/DisableActivityIndication";
        
        /**  Use this key to limit the size of the chat db. Value is in KB. By default there is no limit. A minimum
          of 16 MB is recommended.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string CHATDB_LIMIT_KB = "Lib/Chat/ChatDBLimitKb";
        
        /**  Enables/disables call forwarding. @li 0 - disable; @li 1 - enable; This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string CALL_APPLY_CF = "Lib/Call/ApplyCF";
        
        /**  Setting this to 1 starts sending video automatically when call starts This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string VIDEO_AUTOSEND = "Lib/Video/AutoSend";
        
        /**  Currently selected video device path. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string VIDEO_DEVICE_PATH = "Lib/Video/DevicePath";
        
        /**  Disables storage of chat history. This is account-specific setup key. It can only be used while an account is logged in.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_CHAT_HISTORY = "Lib/Message/DisableHistory";
        
    }
    
    /*! \class LocalMachine
      \brief
      Local machine based setup keys. These affect an all the accounts on this particular device.
      They do not affect the same account on other devides. This is an abstract class and cannot be instantiated.
    */
    public abstract class LocalMachine
    {
        /**  1 disables listening of alternative ports (80, 443) This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_PORT80 = "*Lib/Connection/DisablePort80";
        
        /**  HTTPS proxy server username This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string HTTPS_PROXY_USER = "*Lib/Connection/HttpsProxy/User";
        
        /**  Disables Skype echo canceller This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_AEC = "*Lib/Audio/DisableAEC";
        
        /**  Disables audio devices probing This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_AUDIO_DEVICE_PROBING = "*Lib/QualityMonitor/DisableAudioDeviceProbing";
        
        /**  Suggested port number (lib will *try* to use that) This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string PORT = "*Lib/Connection/Port";
        
        /**  1 disables UDP port binding. should be set before connect This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_UDP = "*Lib/Connection/DisableUDP";
        
        /**  Setting this to 1 disables all video functionality. This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string VIDEO_DISABLE = "*Lib/Video/Disable";
        
        /**  name:port of HTTP proxy server This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string HTTPS_PROXY_ADDR = "*Lib/Connection/HttpsProxy/Addr";
        
        /**  local interface to listen to This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string LOCALADDRESS = "*Lib/Connection/LocalAddress";
        
        /**  Disables Skype digital far-end gain controller This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_DIGITAL_FAR_END_AGC = "*Lib/Audio/DisableDigitalFarEndAGC";
        
        /**  name:port of SOCKS proxy server This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string SOCKS_PROXY_ADDR = "*Lib/Connection/SocksProxy/Addr";
        
        /**  Space-separated array of disabled codecs This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string DISABLED_CODECS = "*Lib/Audio/DisableCodecs";
        
        /**  Disables Skype digital near-end gain controller This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_DIGITAL_NEAR_END_AGC = "*Lib/Audio/DisableDigitalNearEndAGC";
        
        /**  HTTPS proxy server password (base64 encoded) This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string HTTPS_PROXY_PWD = "*Lib/Connection/HttpsProxy/Pwd";
        
        /**  Disables Skype noise suppressor This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_NOISE_SUPPRESSOR = "*Lib/Audio/DisableNS";
        
        /**  Disables Skype automatic gain controller This setup key is machine-specific and affects all local accounts.
        @n Type: <b>boolean</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DISABLE_AGC = "*Lib/Audio/DisableAGC";
        
        /**  SOCKS proxy server password (base64 encoded) This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string SOCKS_PROXY_PWD = "*Lib/Connection/SocksProxy/Pwd";
        
        /**  SOCKS proxy server username This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string SOCKS_PROXY_USER = "*Lib/Connection/SocksProxy/User";
        
        /**  Set to non-zero to enable socks proxy support This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string SOCKS_PROXY_ENABLE = "*Lib/Connection/SocksProxy/Enable";
        
        /**  Use this key to limit the size of the main.db file. Value is in KB. Quota are disabled by default. This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DB_STORAGE_QUOTA_KB = "*Lib/DbManager/StorageQuotaKb";
        
        /**  Page size of the databases. Value is in bytes, the default is 4096.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string DB_PAGE_SIZE = "*Lib/DbManager/PageSize";
        
        /**  Set to 0 for automatic proxy detect, 1 to use proxy config below This setup key is machine-specific and affects all local accounts.
        @n Type: <b>int</b> - use SktSkype.GetInt and SktSkype.SetInt methods for access. */
        public static string HTTPS_PROXY_ENABLE = "*Lib/Connection/HttpsProxy/Enable";
        
        /**  Space-separated array of 1 (in case of 2 microphones) or 2 (in case of 4 microphones) integers. SAL beamforming
          currently only supports 2 and 4-microphone configurations. The values represent the spacing between microphones
          (in millimeters). In case of 2-microphone setup, Only the first value is used. In case of 4-microphone setup, The first value is the distance between inner pair of microphones. The
          second value is the distance between inner pair of microphones and the outer pair. Like this: Let the microphones be on straight line, A B C D. Microphones B and C form the inner pair, while A and D form the outer pair. The first value in the setup string would be distance between B and C. The second value would be distance between A and B (which is the same as distance between C and D). With 4-mic setup, you will need to use two channels. The inner pair should go to one channel (left) and
          the outer pair should go to another (right). This setup key is machine-specific and affects all local accounts.
        @n Type: <b>string</b> - use SktSkype.GetStr and SktSkype.SetStr methods for access. */
        public static string BEAMFORMER_MIC_SPACING = "*Lib/Audio/BeamformerMicSpacing";
        
    }
}

} // SkypeKit

