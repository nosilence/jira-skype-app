<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SkypeKit .NET Wrapper Reference Manual: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="islander3.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>SkypeKit .NET Wrapper Reference Manual Documentation</h1>  </div>
</div>
<div class="contents">
<h3 class="version">4.3 </h3><h2><a class="anchor" id="OnlineResources"></a>
Online Resources</h2>
<ul>
<li><a href="http://developer.skype.com/skypekit/releasenotes" target="_blank">Release notes</a> </li>
<li><a href="http://developer.skype.com/skypekit/development-guide" target="_blank">SkypeKit overview</a> </li>
<li><a href="http://developer.skype.com/skypekit/runtimes" target="_blank">SkypeKit runtime versions</a> </li>
<li><a href="http://developer.skype.com/sso" target="_blank">Developer Forum</a></li>
</ul>
<h2><a class="anchor" id="intro_sec"></a>
Welcome to the developer preview of the SkypeKit .NET wrapper</h2>
<p>The .NET wrapper is currently in a state of functional developer preview. None of the SkypeKit API parts are missing, but the wrapper has not been extensively tested, so there is no guarantee that all the parts yet work quite as intended. Backward compatibility breaking changes to the function signatures, while not currently planned, are also possible. Writing commercial products based on this wrapper is therefore not recommended. On the other hand, feedback on bugs and other such inconveniences is much anticipated. Have fun.</p>
<p><b>Getting Started</b> </p>
<ul>
<li>The first assumption is that you have Visual Studio 2010 (or VS2008) and C# installed. If you happen to be adventorous, VS2011 works as well. </li>
<li>The second assumption is that you have SkypeKit runtime and a valid keyfile. </li>
<li>Then you need to build the wrapper library. The wrapper solution files are in the build/xxx directory, where xxx is Visual Studio version. </li>
<li>The .NET class library (SkypeKit_VS2010.dll or SkypeKit_VS2008.dll) will be placed in the build directory. </li>
<li>Your key file needs to be converted to pfx format (see Converting Keypairs section below) </li>
<li>To use the library, start a new Windows Forms application in Visual Studio </li>
<li>Add a reference to either SkypeKit_VS2010.dll or SkypeKit_VS2008.dll, depending on which Visual Studio you have. </li>
<li>Add <code>using SkypeKit;</code> to your source code. </li>
<li>Add <code>System.Security.Cryptography.X509Certificates;</code> to your source code. </li>
<li>For further reading, take a look at the "Hello world" examples below. More elaborate tutorials are available under the Examples section of this manual and as projects in the &lt;distro&gt;\examples\dotnet\tutorials directory.</li>
</ul>
<p><b>Known problems and missing features:</b> </p>
<ul>
<li>No thread safety (accessing properties actually might be, methods from non-main threads are definitely a no-go)</li>
</ul>
<p><b>Source file locations:</b> </p>
<ul>
<li>The wrapper source code is in the src directory. The main API source file - <code>skt_skypekit</code> exists in two versions - one for Visual Studio 2010 and another one vor Visual Studio 2008. The difference is that the VS2008 version does not have optional method arguments.</li>
</ul>
<h2><a class="anchor" id="converting_keypairs"></a>
Converting Keypairs</h2>
<p>Your X.509 certificates (the .pem files) that you can download from the developer program website do not work directly with the .NET wrapper. They need to be converted to the .pfx format.</p>
<p>Command line for converting a certificate from pem to pfx looks like this: </p>
<div class="fragment"><pre class="fragment">openssl pkcs12 -in &lt;keyfilename&gt;.pem -inkey &lt;keyfilename&gt;.pem -export -out &lt;keyfilename&gt;.pfx
</pre></div><p>This looks a bit scary, but with some luck, you will only need to do it once.</p>
<p>OpenSSL binaries for Windows can be had from <a href="http://www.openssl.org/related/binaries.html" target="_blank">www.openssl.org</a>.</p>
<p>You will need to download and install the full version of the OpenSSL-Win32 package.</p>
<p><b>WARNING!</b> If the OpenSSL-Win32 installer propmts you to install VS2008 distributables - ignore it. You will only need the openssl.exe in that package anyway. In at least one case, re-installing the VS2008 redistro has caused something horrible to happen to the converted .pfx file.</p>
<p>By default, it installs itself in the <code>C:\OpenSSL-Win32</code> directory. The easiest way to convert the pem file is to copy it in the <code>C:\OpenSSL-Win32\bin</code> directory, move to the same directory in windows cmd prompt and run the command line from above.</p>
<p>If you happen to have a spare Linux running somewhere, you can also do the conversion there - openssl is in system path, in Ubuntu family of linuxes, et least.</p>
<h2><a class="anchor" id="skypekit_classes"></a>
SkypeKit Classes</h2>
<p>SkypeKit classes represent objects in SkypeKit Runtime, such as Account, Conversation, Message etc. The naming convention in the .NET wrapper is that all these classes are presented with "Skt" prefix. The .NET Skype class is named SktSkype, Message class is SktMessage, etc.</p>
<p>All the SkypeKit class instances are reflections of corresponding objects in the SkypeKit Runtime. They are descended from the <code>SktObject</code> class. When the SkypeKit Runtime spawns an instance of some class, that instance may or may not be communicated to the wrapper. (Not all objects are sent over immediately, to conserve IPC bandwidth.) Thus, you do not normally construct SkypeKit objects (such as Account, Conversation, or even Message objects) directly. All of those are constructed by the wrapper, as the corresponding objects are created in the SkypeKit Runtime. There is only one exception: your <code>SktSkype</code> object. All other SkypeKit class instances will be given to you, pre-constructed, as return arguments of some SkypeKit wrapper method or in event callbacks.</p>
<p>Each SkypeKit class (except the SktSkype) also has a corresponding list class. The list class is used for holding objects of that class.</p>
<p>For example, to retrieve a list of <code>SktContact</code> objects, you would use <code>SktContact.List</code> class. </p>
<div class="fragment"><pre class="fragment">SktContactGroup contactGroup;
contactGroup = skype.GetHardwiredContactGroup(SktContactGroup.TYPE.ALL_BUDDIES);
SktContact.List contactList;
contactList = contactGroup.GetContacts();
</pre></div><p>Note that the list classes are nested within the SkypeKit classes they are lists of.</p>
<p>For simple types, such as Strings and integers, generic lists, such as <code>List&lt;String&gt;</code> and <code>List&lt;uint&gt;</code> are used in the wrapper. The reason for not using generic lists for SkypeKit classes is the need to internally typecast the lists into more abstract classes, which turned out to be difficult to do with generics.</p>
<h2><a class="anchor" id="events"></a>
Events and Event Callbacks</h2>
<p>Events are propagated to your client via events field of the SktSkype class.</p>
<p>This enables you to assign callbacks globally, without need to subclass every single class in order to override a virtual callback method.</p>
<p>The event signatures are formed as <code>SktEvents.&lt;ClassName&gt;On&lt;EventName&gt;</code>, where the class name is without "Skt" prefix.</p>
<p>Example: the actual name for <code>SktSkype</code> class <code>OnMessage</code> event is <code>SktEvents.OnSkypeMessage</code></p>
<p>Each of the these events has its own callback function signature.</p>
<p>All the callbacks have a standard set of two arguments: </p>
<ul>
<li>sender - the originator object, with type of the originator object </li>
<li>e - strongly typed event-specific arguments object</li>
</ul>
<p>The event-specific argument class names are formed as <code>SktEvents.On&lt;Class&gt;&lt;EventName&gt;Args</code></p>
<p>For example, in case of <code>SktEvents.OnSkypeMessage</code>, the e argument will be of type <code>SktEvents.OnSkypeMessageArgs</code></p>
<p>More elaborate example: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* custom callback */</span>
<span class="keyword">public</span> <span class="keywordtype">void</span> OnSkypeMessage (SktSkype sender, SktEvents.OnSkypeMessageArgs e)
{
    Log( e.message );
} 

<span class="comment">/* callback assignment */</span>
skype.events.OnSkypeMessage += OnSkypeMessage;
</pre></div><h2><a class="anchor" id="properties"></a>
Properties and Property Update Callbacks</h2>
<p>The SkypeKit class properties in the .NET wrapper are accessible directly, like this: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (account.P_STATUS == SktAccount.STATUS.LOGGED_IN) { ... };
</pre></div><p><b>WARNING!</b> Properties are <b>not accessible</b> from within class constructors! Writing something like this: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span> <span class="keyword">class </span>MyContact : SktContact
{
    <span class="keyword">public</span> MyContact(uint oid, SktSkype skype)
        : base(oid, skype) 
    {
        String this_causes_lockup = this.P_DISPLAYNAME;
    }
}
</pre></div><p>..will cause your application to lock up. You will need to find a way around using properties from within constructors.</p>
<p>Every time a property changes value, a property update is sent from the runtime to your application. Property updates are quite similar to events. They basically are events that get fired every time the runtime notifies your application, that a value of a property of an object has changed.</p>
<p>Each property callback signature has two arguments, the same as Events - sender and the SktEvents.&lt;EventName&gt;Args argument named e. The updated value of the property can be accessed via e.value field.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span> <span class="keywordtype">void</span> OnAccountStatus(SktAccount sender, SktEvents.OnAccountStatusArgs e)
{
    <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_IN) { <span class="comment">/* */</span> }
}
</pre></div><p>Note that there are two ways of getting the property value in the callbacks. Firstly, via the e.value field and secondly, you can explicitly get the property via sender.P_&lt;PROPNAME&gt; accessor. <b>NB!</b> It is important to realize that these values are not necessarily equal. The reason for this is timing. A property can change state several times in quick succession. Each time a property changes a corresponding event is scheduled to be fired in the GUI thread. Scheduled, not fired directly. By the time it actually ends up being executed in the GUI - the very same property may have already changed again. In such a case, using the object.P_PROPERTY accessor will give you the current value of the property. Which may be more recent than the event you are currently handling. The e.value field, however, will contain the "historically correct" value of the property - that is, the value of the property at the time of the event you are currently reacting to.</p>
<p>Lets look at a case where a property P_PROP quickly changes three times in a row, from "A" to "B" to "C", like this: </p>
<div class="fragment"><pre class="fragment">P_PROP = <span class="stringliteral">&quot;A&quot;</span> - <span class="keyword">property</span> cache is updated to <span class="stringliteral">&quot;A&quot;</span> and prop update Event1 gets scheduled.
P_PROP = <span class="stringliteral">&quot;B&quot;</span> - <span class="keyword">property</span> cache is updated to <span class="stringliteral">&quot;B&quot;</span> and prop update Event2 gets scheduled.
P_PROP = <span class="stringliteral">&quot;C&quot;</span> - <span class="keyword">property</span> cache is updated to <span class="stringliteral">&quot;C&quot;</span> and prop update Event3 gets scheduled.
Event1 gets fired in the GUI - sender.P_PROP is <span class="stringliteral">&quot;C&quot;</span>; e.value is <span class="stringliteral">&quot;A&quot;</span>
Event2 gets fired in the GUI - sender.P_PROP is <span class="stringliteral">&quot;C&quot;</span>; e.value is <span class="stringliteral">&quot;B&quot;</span>
Event3 gets fired in the GUI - sender.P_PROP is <span class="stringliteral">&quot;C&quot;</span>; e.value is <span class="stringliteral">&quot;C&quot;</span>
</pre></div><p>Generally, the e.value tends to be more useful, as it maintains strict sequentiality of state changes.</p>
<p>The signature for property update callbacks is <code>SktEvents.&lt;ClassName&gt;On&lt;PropName&gt;</code>, where the PropName is in CamelCase and without the "P_" prefix and the class name is without "Skt".</p>
<p>Example: <code>SktContact.P_MOOD_TEXT</code> property change callback can be assigned to <code>SktEvents.OnContactMoodText</code></p>
<p>More elaborate example: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* custom callback */</span>
<span class="keyword">public</span> <span class="keywordtype">void</span> OnAccountStatus(SktAccount sender, EventArgs e)
{
    Log(e.value.ToString());
    <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_OUT)
    {
        Log(<span class="stringliteral">&quot;Cause of logout: &quot;</span> + sender.P_LOGOUTREASON.ToString());
    }
}

<span class="comment">/* callback assignment */</span>
skype.events.OnAccountStatus += OnAccountStatus;
</pre></div><h2><a class="anchor" id="subclassing"></a>
Subclassing SkypeKit Classes</h2>
<p>As you can assign property change and event callbacks of the SkypeKit classes globally, there is often no immediate need to actually derive your own custom classes from the SkypeKit ones. Should you still need to do this, you will have to register each of your custom classes with your SktSkype instance.</p>
<p>The reason for this is that you do not instantiate those classes yourself. The objects are created by the wrapper library and returned to you by SkypeKit methods or events. Thus, the wrapper will need to know, which classes to instantiate.</p>
<p>For that, the SktSkype has an assignable <code>New&lt;Class&gt;</code> field for each class. That field is of type <code>SktNewObjectDelegate</code></p>
<p>The SktNewObjectDelegate is defined as: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span> delegate SktObject SktNewObjectDelegate (uint objectId, SktSkype skype);
</pre></div><p>So, for every class you descend from a SkypeKit class, you would need to add the following line, somewhere between creating skype object and <code>Connect()</code>: </p>
<div class="fragment"><pre class="fragment">skype.New&lt;Class&gt; = (oid, skp) =&gt; { <span class="keywordflow">return</span> new &lt;YourClass&gt;(oid, skp); };
</pre></div><p>Where the <code>&lt;Class&gt;</code> is without the Skt prefix, i.e. <code>Participant</code>, rather than <code>SktParticipant</code>.</p>
<p>For example, to introduce a new <code>SktContact</code>-based <code>MyContact</code> class, you would need to:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/* Subclassing MyContact */</span>

<span class="keyword">public</span> <span class="keyword">class </span>MyContact : SktContact
{
    <span class="keyword">public</span> <span class="keywordtype">string</span> someString;

    <span class="keyword">public</span> MyContact(uint oid, SktSkype skype)
        : base(oid, skype) 
    {
        someString = <span class="stringliteral">&quot;some additional field i need for my contacts&quot;</span>;
    }
}

<span class="comment">// In your form init, this is the registration bit:</span>
skype.NewContact = (oid, skp) =&gt; { <span class="keywordflow">return</span> <span class="keyword">new</span> MyContact(oid, skp); };

<span class="comment">// And as a result, we can do this:</span>
SktContactGroup contactGroup;
contactGroup = skype.GetHardwiredContactGroup(SktContactGroup.TYPE.ALL_BUDDIES);
SktContact.List contactList;
contactList = contactGroup.GetContacts();

<span class="keywordflow">foreach</span> (MyContact contact <span class="keywordflow">in</span> contactList) 
{ 
    Log(contact.P_DISPLAYNAME + <span class="charliteral">&#39; &#39;</span> + contact.someString); 
}
</pre></div><p>Unfortunately, this does not play entirely too well with events. The delegate types for event callbacks still have the original class - <code>SktContact</code> - in their callback signature. Suppose, if you wrote a contact mood text change callback, like this: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> OnContactMoodText(MyContact sender, EventArgs e) { <span class="comment">/* .. */</span> }
</pre></div><p> You could not assign it to <code>skype.events.OnContactMoodText</code> - as that event still expects to see the sender as <code>SktContact</code> in it's signature.</p>
<p>A somewhat inelegant but workable way around this is to use a local variable of your custom class variety, and in the callback, typecast it from the <code>SktContact sender</code>, like this: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> OnContactMoodText(SktContact sender, EventArgs e)
{
    SktContact contact = (SktContact)sender;
    contact.someString = contact.P_MOOD_TEXT + <span class="stringliteral">&quot;-- the mood is sad, as we need to typecast for this --&quot;</span>;
}
</pre></div><p>In case your language does not support lambdas, you can also register your classes by assigning methods in a more orthodox way, like this: </p>
<div class="fragment"><pre class="fragment">Public Class MyContact
    Inherits SktContact

    Public SomeString As String

    Public Sub New(ByVal objectId As UInteger, ByRef skype As SktSkype)
        MyBase.New(objectId, skype)
        SomeString = <span class="stringliteral">&quot;some additional field i need for my contacts&quot;</span>
    End Sub
End Class

Function NewMyContact(ByVal objectId As UInteger, ByVal skype As SktSkype) As MyContact
    Return New MyContact(objectId, skype)
End Function

&#39; In your form constructor
skype.NewContact = AddressOf NewMyContact

&#39; and after login, you can do this:
someContact = skype.GetContact(&quot;somecontact&quot;)
TextBox1.AppendText(someContact.SomeString)
</pre></div><h2><a class="anchor" id="logging"></a>
Logging Features</h2>
<p>The <code>SktSkype</code> constructors have two boolean swithces to enable or disable logging.</p>
<p>Firstly, the wrapper log. This log records wrapper internal activity, such as property changes, events, method calls and object creations. This is quite helpful if you need to determine the exact sequence of property changes or events during debugging.</p>
<p>You can use this two ways. By default, simply switching this argument true, will create a "wrapper.log" file in your application's executable directory. The name of this file cannot be changed, each client run will overwrite the existing file. Secondly, you can assign your own callback to <code>skype.events.OnLog</code> event. With this callback you can get the log in real time, in your UI.</p>
<p>The simplest way would be to add a special debug form to your application, with one big multiline TextBox in it (remember to turn on the Public modifier for the TextBox, so you can access it from everywhere). After that, you can add this to your main form: </p>
<div class="fragment"><pre class="fragment">Form2 logform = <span class="keyword">new</span> Form2();

DateTime lastLogEntryTimepstamp = DateTime.Now;

<span class="keyword">public</span> <span class="keywordtype">void</span> OnLog(<span class="keywordtype">object</span> sender, SktEvents.OnLogArgs e)
{
    TimeSpan diff = DateTime.Now.Subtract(lastLogEntryTimepstamp);
    lastLogEntryTimepstamp = DateTime.Now;           
    logform.textBox1.AppendText(diff.TotalMilliseconds.ToString(<span class="stringliteral">&quot;00000&quot;</span>) + <span class="stringliteral">&quot;  &quot;</span> + e.message + <span class="stringliteral">&quot;\r\n&quot;</span>);
}

<span class="comment">// in your main Form constructor</span>
skype = <span class="keyword">new</span> SktSkype(<span class="keyword">this</span>, cert, <span class="keyword">true</span>, <span class="keyword">false</span>, 8963);
skype.events.OnLog += OnLog;
logform.Show();
</pre></div><p>The <code>OnLog</code> callback also adds a time difference (in milliseconds) between each log entry, so you can see if something takes unusually long. The log will end up looking like this: </p>
<div align="center">
<img src="logwindow.png" alt="logwindow.png"/>
</div>
<p>The screenshot above is of the built-in "debug window" for the tutorials. If you wish to enable this window in the tutorials, simply set the wrapperLog argument in SktSkype constructor and add the following line at the end of the main form constructor: </p>
<div class="fragment"><pre class="fragment">tutorials.ShowLogWindow(<span class="keyword">this</span>, skype);
</pre></div><p><b>NB!</b> If the <code>OnLog</code> event is assigned, the "wrapper.log" will no longer be generated.</p>
<p>The second logging option is the transport log. The transport log contains IPC traffic between the wrapper and the runtime. The log file is named "transport.log" and is also placed in your application's executable directory.</p>
<p><b>NB!</b> You should only use the logging switches during development and testing. Do not leave them ON in your production code. The logging, particularly transport logging, can cause substantial drop in your application's performane. To give you the picture - transport logging does a file append operation every time a byte is read from or written to the IPC socket.</p>
<h2><a class="anchor" id="threading"></a>
Threading</h2>
<p>The .NET wrapper is currently not thread-safe. I.e. you cannot spawn additional threads to access class properties or call class methods. The bright side of this is that as all the IPC traffic between the wrapper and the runtime is serialized through a TCP socket, your application would be bottlenecked by the socket communication in any case. Performance gains from multi-threading would be minimal at best. However, non-performance related reasons - namely not blocking the GUI unnecessarily, are still quite valid. Thus, thread-safety is on the ToDo list.</p>
<p>The wrapper threading is dependant on whether it is being used from Windows Forms application or a console app. The SktSkype class has two constructors - one with a Form argument and the other one without it. Depending on whether the form argument is supplied, the wrapper will run in either GUI or console mode.</p>
<p>In GUI mode, the wrapper uses just two threads - the main GUI thread and the IPC socket reader thread to handle incoming traffic from the runtime. All the incoming events and property updates are asynchronously synchronized into the main thread, with <code>BeginInvoke</code>. Thus, you do not need to worry about invoking UI updates from inside your event and property change callbacks.</p>
<p>In console applications, <code>BeginInvoke</code> is not available. Thus, on every incoming event or property update, a temporary thread is created and the callback method executed inside it. This means that all the callbacks that you assign to skype.events will execute in individual threads. Data exchange is still quite possible, with volatile variables or locks, but in console applications, managing these is your responsibility.</p>
<h2><a class="anchor" id="hello_cs"></a>
"Hello world" in C#</h2>
<p>You will need a multiline TextBox in your <code>Form1</code>. Also, don't forget to connect the form's <code>FormClosing</code> event! Unless the client disconnects gracefully, you may have orphaned skypekit runtimes running on your system. It is annoying to kill those manually from the process list.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Windows.Forms;
<span class="keyword">using</span> SkypeKit;
<span class="keyword">using</span> System.Security.Cryptography.X509Certificates;

<span class="keyword">namespace </span>WindowsFormsApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial class </span>Form1 : Form
    {
        <span class="comment">// path to both runtime and keyfile, relative to your application executable</span>
        <span class="comment">// you might want to change it</span>
        <span class="keywordtype">string</span> path = <span class="stringliteral">&quot;..\\..\\..\\..\\..\\&quot;</span>;
        <span class="keywordtype">string</span> runtime = <span class="stringliteral">&quot;windows-x86-skypekit.exe&quot;</span>;    
        
        <span class="keywordtype">string</span> keyfile = <span class="stringliteral">&quot;&lt;your keyfile&gt;&quot;</span>;
        <span class="keywordtype">string</span> username = <span class="stringliteral">&quot;&lt;your skypename&gt;&quot;</span>;    <span class="comment">// your skypename</span>
        <span class="keywordtype">string</span> password = <span class="stringliteral">&quot;&lt;your password&gt;&quot;</span>;     <span class="comment">// your password</span>

        SktSkype skype;
        SktAccount account;
        
        <span class="keyword">public</span> <span class="keywordtype">void</span> OnConnect(<span class="keywordtype">object</span> sender, SktEvents.OnConnectArgs e)
        {
            <span class="keywordflow">if</span> (e.success)
            {
                textBox1.AppendText(<span class="stringliteral">&quot;Connection to runtime is up. Lets see if we can log in..\r\n&quot;</span>);
                account = skype.GetAccount(username);
                account.LoginWithPassword(password, <span class="keyword">false</span>, <span class="keyword">false</span>);
            }
            <span class="keywordflow">else</span>
            {
                textBox1.AppendText(<span class="stringliteral">&quot;IPC handshake failed with: &quot;</span> + e.handshakeResult + <span class="stringliteral">&quot;\r\n&quot;</span>);
            }
        }

        <span class="keyword">public</span> <span class="keywordtype">void</span> OnAccountStatus(SktAccount sender, SktEvents.OnAccountStatusArgs e)
        {
            textBox1.AppendText(e.value.ToString() + <span class="stringliteral">&#39;\r\n&#39;</span>);

            <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_IN)
            {
                textBox1.AppendText(<span class="stringliteral">&quot;Hello, we are logged in now.&quot;</span> + <span class="stringliteral">&#39;\r\n&#39;</span>);
            }

            <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_OUT)
            {
                textBox1.AppendText(<span class="stringliteral">&quot;Login failed because of &quot;</span> + sender.P_LOGOUTREASON + <span class="stringliteral">&#39;\r\n&#39;</span>);
            }
        }

        <span class="keyword">public</span> Form1()
        {
            InitializeComponent();
            
            X509Certificate2 cert = <span class="keyword">new</span> X509Certificate2(path + keyfile, <span class="stringliteral">&quot;&quot;</span>);

            skype = <span class="keyword">new</span> SktSkype(<span class="keyword">this</span>, cert, <span class="keyword">true</span>, <span class="keyword">true</span>, 8963);
            skype.events.OnConnect += OnConnect;
            skype.events.OnAccountStatus += OnAccountStatus;
            
            skype.LaunchRuntime(path + runtime, <span class="keyword">true</span>);
            skype.Connect();
        }

        <span class="keyword">private</span> <span class="keywordtype">void</span> Form1_FormClosing(<span class="keywordtype">object</span> sender, FormClosingEventArgs e)
        {
            skype.Disconnect();
        }
    }
}
</pre></div><h2><a class="anchor" id="hello_basic"></a>
"Hello world" in Visual Basic</h2>
<p>You will need to add a 1 multiline <code>TextBox</code> and 1 <code>Button</code> component to your main form. Again - dont forget to connect the <code>FormClosing</code> event.</p>
<div class="fragment"><pre class="fragment">Imports SkypeKit
Imports System.Security.Cryptography.X509Certificates

Public Class Form1

    <span class="stringliteral">&#39; path to both runtime and keyfile, relative to your application executable</span>
<span class="stringliteral">    &#39;</span> you might want to change it
    Dim path As String = <span class="stringliteral">&quot;..\\..\\..\\..\\..\\&quot;</span>

    Dim keyfile As String = <span class="stringliteral">&quot;&lt;keyfile&gt;&quot;</span> <span class="stringliteral">&#39; the .pfx file</span>
<span class="stringliteral">    Dim runtime As String = &quot;windows-x86-skypekit.exe&quot;</span>
<span class="stringliteral"></span>
<span class="stringliteral">    Dim username As String = &quot;&lt;your skypename here&gt;&quot;</span>
<span class="stringliteral">    Dim password As String = &quot;&lt;your password here&gt;&quot;</span>
<span class="stringliteral"></span>
<span class="stringliteral">    Dim skype As SktSkype</span>
<span class="stringliteral">    Dim account As SktAccount</span>
<span class="stringliteral">    </span>
<span class="stringliteral">    &#39;</span> Runtime connection callback
    Public Sub OnConnect(ByVal sender As System.Object, ByVal e As SktEvents.OnConnectArgs)

        If e.success Then
            TextBox1.AppendText(<span class="stringliteral">&quot;Connection to runtime is up. Lets see if we can log in..&quot;</span> + vbNewLine)
            account = skype.GetAccount(username)
            account.LoginWithPassword(password, False, False)
        Else
            TextBox1.AppendText(<span class="stringliteral">&quot;IPC handshake failed&quot;</span>)
        End If

    End Sub

    Public Sub OnAccountStatus(ByVal sender As SktAccount, ByVal e As SktEvents.OnAccountStatusArgs)

        TextBox1.AppendText(e.value.ToString() + vbNewLine)

        If e.value = SktAccount.STATUS.LOGGED_IN Then
            TextBox1.AppendText(<span class="stringliteral">&quot;Hello, we are logged in now.&quot;</span> + vbNewLine)
        End If

        If e.value = SktAccount.STATUS.LOGGED_OUT Then
            TextBox1.AppendText(<span class="stringliteral">&quot;Login failed because of &quot;</span> + sender.P_LOGOUTREASON.ToString() + vbNewLine)
        End If

    End Sub

    Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click

        Dim cert = New X509Certificate2(path + keyfile, <span class="stringliteral">&quot;&quot;</span>)
        skype = New SktSkype(Me, cert, True, False, 8963)
       
        AddHandler skype.events.OnConnect, AddressOf OnConnect
        AddHandler skype.events.OnAccountStatus, AddressOf OnAccountStatus

        skype.LaunchRuntime(path + &quot;windows-x86-skypekit.exe&quot;)
        skype.Connect() &#39;&lt;- if connection comes up, OnConnect callback will fire
    End Sub

    Private Sub Form1_FormClosing(
        ByVal sender As System.Object,
        ByVal e As System.Windows.Forms.FormClosingEventArgs) Handles MyBase.FormClosing

        skype.Disconnect()
    End Sub

End Class
</pre></div><h2><a class="anchor" id="hello_cs_console"></a>
"Hello world" in C# - Console Application</h2>
<div class="fragment"><pre class="fragment"><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Security.Cryptography.X509Certificates;
<span class="keyword">using</span> SkypeKit;
<span class="keyword">using</span> System.Threading;

<span class="keyword">namespace </span>console1
{
    <span class="keyword">class </span>Program
    {
        <span class="keyword">static</span> <span class="keywordtype">string</span> runtimePath = <span class="stringliteral">&quot;..\\..\\..\\..\\..\\&quot;</span>;     <span class="comment">// Path to both SkypeKit runtime executable and key file</span>
        <span class="keyword">static</span> <span class="keywordtype">string</span> keyFileName = <span class="stringliteral">&quot;somekey.pfx&quot;</span>;              <span class="comment">// Keyfile name</span>
        <span class="keyword">static</span> <span class="keywordtype">string</span> runtimeName = <span class="stringliteral">&quot;windows-x86-skypekit.exe&quot;</span>; <span class="comment">// Filename of runtime executable</span>

        <span class="keyword">static</span> String loginName     = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keyword">static</span> String password      = <span class="stringliteral">&quot;&quot;</span>;

        <span class="keyword">static</span> <span class="keyword">volatile</span> Boolean loginFinished   = <span class="keyword">false</span>;
        <span class="keyword">static</span> <span class="keyword">volatile</span> Boolean logoutFinished  = <span class="keyword">false</span>;

        <span class="keyword">static</span> SktSkype skype           = null;
        <span class="keyword">static</span> SktAccount account       = null;
        <span class="keyword">static</span> X509Certificate2 cert    = null;

        <span class="keyword">static</span> <span class="keywordtype">void</span> OnConnect(<span class="keywordtype">object</span> sender, SktEvents.OnConnectArgs e)
        {
            <span class="keywordflow">if</span> (!e.success)
            {
                Console.WriteLine(<span class="stringliteral">&quot;Runtime connection failed with error code: &quot;</span> + e.handshakeResult);
                <span class="keywordflow">return</span>;
            }

            Console.WriteLine(<span class="stringliteral">&quot;Runtime connection established&quot;</span>);

            Console.Write(<span class="stringliteral">&quot;login:&quot;</span>);
            loginName = Console.ReadLine();
            Console.Write(<span class="stringliteral">&quot;password:&quot;</span>);
            password = Console.ReadLine();

            account = skype.GetAccount(loginName);

            Console.WriteLine(<span class="stringliteral">&quot;Logging in..&quot;</span>);
            account.LoginWithPassword(password, <span class="keyword">false</span>, <span class="keyword">false</span>);
        }

        <span class="keyword">static</span> <span class="keywordtype">void</span> OnAccountStatus(SktAccount sender, SktEvents.OnAccountStatusArgs e)
        {
            Console.WriteLine(e.value.ToString());
            <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_OUT) 
            {
                String s = account.P_LOGOUTREASON.ToString();
                Console.WriteLine(s);
            }

            <span class="keywordflow">if</span> ((e.value == SktAccount.STATUS.LOGGED_IN) || 
                (e.value == SktAccount.STATUS.LOGGED_OUT)) loginFinished = <span class="keyword">true</span>;
                
            <span class="keywordflow">if</span> (e.value == SktAccount.STATUS.LOGGED_OUT) logoutFinished = <span class="keyword">true</span>;
        }

        <span class="keyword">static</span> <span class="keywordtype">void</span> OnSkypeMessage(SktSkype sender, SktEvents.OnSkypeMessageArgs e)
        {
            Console.WriteLine(<span class="stringliteral">&quot;message received&quot;</span>);
            Console.WriteLine(e.message.P_BODY_XML);
        }


        <span class="keyword">static</span> <span class="keywordtype">void</span> Main(<span class="keywordtype">string</span>[] args)
        {
            cert = <span class="keyword">new</span> X509Certificate2(runtimePath + keyFileName, <span class="stringliteral">&quot;&quot;</span>);
            skype = <span class="keyword">new</span> SktSkype(cert, wrapperLog:<span class="keyword">true</span>);

            skype.events.OnConnect += OnConnect;
            skype.events.OnAccountStatus += OnAccountStatus;
            skype.events.OnSkypeMessage += OnSkypeMessage;

            skype.LaunchRuntime(runtimePath + runtimeName, <span class="keyword">true</span>);
            skype.Connect();

            <span class="keywordflow">while</span> (!loginFinished) Thread.Sleep(10);

            <span class="keywordflow">if</span> (account.P_STATUS == SktAccount.STATUS.LOGGED_IN)
            {
                Console.WriteLine(<span class="stringliteral">&quot;You should now see this account from other Skype instances as online.&quot;</span>);
                Console.WriteLine(<span class="stringliteral">&quot;Press ENTER to log out&quot;</span>);
                Console.ReadLine();
                account.Logout(<span class="keyword">true</span>);
                <span class="keywordflow">while</span> (!logoutFinished) Thread.Sleep(10);
                Console.WriteLine(<span class="stringliteral">&quot;Cause of logout: &quot;</span> + account.P_LOGOUTREASON.ToString());
                Console.WriteLine(<span class="stringliteral">&quot;Press ENTER to exit&quot;</span>);
                Console.ReadLine();
                Console.WriteLine(<span class="stringliteral">&quot;Exiting&quot;</span>);
            }
            <span class="keywordflow">else</span>
            {
                Console.WriteLine(<span class="stringliteral">&quot;Login failed&quot;</span>);
                Console.WriteLine(<span class="stringliteral">&quot;Press ENTER to exit&quot;</span>);
                Console.ReadLine();
            }
        }
    }
}
</pre></div><h2><a class="anchor" id="troubleshooting"></a>
Troubleshooting</h2>
<p><b>Q:</b> I subclassed my own class from one of the Skt classes and now the debugger seems to make wierd jumps when I typecast between the parent and my own class.</p>
<p><b>A:</b> Did you forget to add the new class registration line? The one that looks like this: </p>
<div class="fragment"><pre class="fragment">skype.NewParticipant = (oid, skp) =&gt; { <span class="keywordflow">return</span> <span class="keyword">new</span> MyParticipant(oid, skp); };
</pre></div> <hr/>
<p><b>Q:</b> I am getting the following: </p>
<div class="fragment"><pre class="fragment"><span class="stringliteral">&quot;Error 1 The type System.Windows.Forms.Form is defined in an assembly that is not referenced.&quot;</span> 
</pre></div><p> in my console application and I don't want to reference Forms.</p>
<p><b>A:</b> This is likely caused by C# getting confused while misinterpreting optional arguments to your skype constructor. Try supplying the optional arguments explicitly, like this: </p>
<div class="fragment"><pre class="fragment">skype = <span class="keyword">new</span> SktSkype(cert, wrapperLog:<span class="keyword">true</span>);
</pre></div><hr/>
<p><b>Q:</b> <code>SktSkype.OnConnect</code> fails to fire.</p>
<p><b>A1:</b> Check with task manager for orphaned runtimes from previous sessions. If multiple runtimes try to serve at the same local port, additional runtimes will fail to connect.</p>
<p><b>A2:</b> Re-check if you assigned your OnConnect callback to skype.events - it's easy to forget.</p>
<hr/>
 </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<hr/>	
		<p><b>(c) Skype</b></p>		
		<p>Last updated: Wed Jul 4 2012</p>		
		</BODY>
</HTML>
